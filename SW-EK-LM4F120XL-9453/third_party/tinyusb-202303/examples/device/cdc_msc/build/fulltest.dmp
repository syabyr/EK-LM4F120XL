
fulltest:     file format elf32-littlearm


Disassembly of section .text:

00000000 <vectors>:
       0:	00 80 00 20 6d 29 00 00 bd 02 00 00 bd 02 00 00     ... m)..........
      10:	bd 02 00 00 bd 02 00 00 bd 02 00 00 00 00 00 00     ................
	...
      2c:	bd 02 00 00 bd 02 00 00 00 00 00 00 bd 02 00 00     ................
      3c:	7d 02 00 00 bd 02 00 00 bd 02 00 00 bd 02 00 00     }...............
      4c:	bd 02 00 00 bd 02 00 00 bd 02 00 00 bd 02 00 00     ................
      5c:	bd 02 00 00 bd 02 00 00 bd 02 00 00 bd 02 00 00     ................
      6c:	bd 02 00 00 bd 02 00 00 bd 02 00 00 bd 02 00 00     ................
      7c:	bd 02 00 00 bd 02 00 00 bd 02 00 00 bd 02 00 00     ................
      8c:	bd 02 00 00 bd 02 00 00 bd 02 00 00 bd 02 00 00     ................
      9c:	bd 02 00 00 bd 02 00 00 bd 02 00 00 bd 02 00 00     ................
      ac:	00 00 00 00 bd 02 00 00 bd 02 00 00 bd 02 00 00     ................
	...
      c4:	bd 02 00 00 bd 02 00 00 bd 02 00 00 bd 02 00 00     ................
      d4:	bd 02 00 00 bd 02 00 00 bd 02 00 00 bd 02 00 00     ................
      e4:	bd 02 00 00 00 00 00 00 bd 02 00 00 91 10 00 00     ................
      f4:	bd 02 00 00 bd 02 00 00 bd 02 00 00 bd 02 00 00     ................
     104:	bd 02 00 00 bd 02 00 00 bd 02 00 00 00 00 00 00     ................
     114:	00 00 00 00 bd 02 00 00 bd 02 00 00 bd 02 00 00     ................
     124:	bd 02 00 00 bd 02 00 00 bd 02 00 00 bd 02 00 00     ................
     134:	bd 02 00 00 bd 02 00 00 bd 02 00 00 00 00 00 00     ................
	...
     150:	bd 02 00 00 bd 02 00 00 bd 02 00 00 bd 02 00 00     ................
	...
     1b0:	bd 02 00 00 bd 02 00 00 bd 02 00 00 bd 02 00 00     ................
     1c0:	bd 02 00 00 bd 02 00 00 bd 02 00 00 bd 02 00 00     ................
     1d0:	bd 02 00 00 bd 02 00 00 bd 02 00 00 bd 02 00 00     ................
     1e0:	bd 02 00 00 bd 02 00 00 bd 02 00 00 00 00 00 00     ................
     1f0:	00 00 00 00 bd 02 00 00 bd 02 00 00 bd 02 00 00     ................
     200:	bd 02 00 00 bd 02 00 00 00 00 00 00 00 00 00 00     ................
     210:	bd 02 00 00 bd 02 00 00 bd 02 00 00 bd 02 00 00     ................
     220:	bd 02 00 00 bd 02 00 00 bd 02 00 00 bd 02 00 00     ................
     230:	bd 02 00 00 bd 02 00 00 bd 02 00 00 bd 02 00 00     ................
     240:	bd 02 00 00 bd 02 00 00 bd 02 00 00 bd 02 00 00     ................
     250:	bd 02 00 00 bd 02 00 00 bd 02 00 00 bd 02 00 00     ................
     260:	bd 02 00 00 bd 02 00 00 bd 02 00 00                 ............

0000026c <strlen>:
     26c:	4603      	mov	r3, r0
     26e:	f813 2b01 	ldrb.w	r2, [r3], #1
     272:	2a00      	cmp	r2, #0
     274:	d1fb      	bne.n	26e <strlen+0x2>
     276:	1a18      	subs	r0, r3, r0
     278:	3801      	subs	r0, #1
     27a:	4770      	bx	lr

0000027c <SysTick_Handler>:

#if CFG_TUSB_OS == OPT_OS_NONE
volatile uint32_t system_ticks = 0;
void SysTick_Handler (void)
{
  system_ticks++;
     27c:	4a02      	ldr	r2, [pc, #8]	; (288 <SysTick_Handler+0xc>)
     27e:	6813      	ldr	r3, [r2, #0]
     280:	3301      	adds	r3, #1
     282:	6013      	str	r3, [r2, #0]
}
     284:	4770      	bx	lr
     286:	bf00      	nop
     288:	200025a8 	.word	0x200025a8

0000028c <getOscClk>:
  Get the OSC clock
 *----------------------------------------------------------------------------*/
__INLINE static uint32_t getOscClk (uint32_t xtal, uint32_t oscSrc) {
  uint32_t oscClk = XTALI;

  switch (oscSrc) {                      /* switch OSCSRC */
     28c:	2902      	cmp	r1, #2
     28e:	d008      	beq.n	2a2 <getOscClk+0x16>
     290:	2903      	cmp	r1, #3
     292:	d008      	beq.n	2a6 <getOscClk+0x1a>
     294:	b951      	cbnz	r1, 2ac <getOscClk+0x20>
    case 0:                              /* MOSC Main oscillator */
      switch (xtal) {                    /* switch XTAL */
     296:	2816      	cmp	r0, #22
     298:	d808      	bhi.n	2ac <getOscClk+0x20>
     29a:	4b05      	ldr	r3, [pc, #20]	; (2b0 <getOscClk+0x24>)
     29c:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
     2a0:	4770      	bx	lr
  switch (oscSrc) {                      /* switch OSCSRC */
     2a2:	4804      	ldr	r0, [pc, #16]	; (2b4 <getOscClk+0x28>)
     2a4:	4770      	bx	lr
      break;
    case 2:                         /* IOSC/4 Internal oscillator/4 */
      oscClk = XTALI/4;
      break;
    case 3:                         /* 30kHz internal oscillator  */
      oscClk = XTAL30K;
     2a6:	f247 5030 	movw	r0, #30000	; 0x7530
     2aa:	4770      	bx	lr
  switch (oscSrc) {                      /* switch OSCSRC */
     2ac:	4802      	ldr	r0, [pc, #8]	; (2b8 <getOscClk+0x2c>)
      break;
  }

  return oscClk;
}
     2ae:	4770      	bx	lr
     2b0:	00002ad8 	.word	0x00002ad8
     2b4:	003d0900 	.word	0x003d0900
     2b8:	00f42400 	.word	0x00f42400

000002bc <ADC0SS0_Handler>:
extern volatile uint32_t __la_data;

void Default_Handler(void) 
{

    while(1); 
     2bc:	e7fe      	b.n	2bc <ADC0SS0_Handler>

000002be <advance_index>:
static uint16_t advance_index(uint16_t depth, uint16_t idx, uint16_t offset)
{
  // We limit the index space of p such that a correct wrap around happens
  // Check for a wrap around or if we are in unused index space - This has to be checked first!!
  // We are exploiting the wrap around to the correct index
  uint16_t new_idx = (uint16_t) (idx + offset);
     2be:	440a      	add	r2, r1
     2c0:	b292      	uxth	r2, r2
  if ( (idx > new_idx) || (new_idx >= 2*depth) )
     2c2:	4291      	cmp	r1, r2
     2c4:	ea4f 0040 	mov.w	r0, r0, lsl #1
     2c8:	d801      	bhi.n	2ce <advance_index+0x10>
     2ca:	4282      	cmp	r2, r0
     2cc:	db01      	blt.n	2d2 <advance_index+0x14>
  {
    uint16_t const non_used_index_space = (uint16_t) (UINT16_MAX - (2*depth-1));
    new_idx = (uint16_t) (new_idx + non_used_index_space);
     2ce:	1a12      	subs	r2, r2, r0
     2d0:	b292      	uxth	r2, r2
  }

  return new_idx;
}
     2d2:	4610      	mov	r0, r2
     2d4:	4770      	bx	lr

000002d6 <tu_fifo_count>:
    @returns Number of items in FIFO
 */
/******************************************************************************/
uint16_t tu_fifo_count(tu_fifo_t* f)
{
  return tu_min16(_ff_count(f->depth, f->wr_idx, f->rd_idx), f->depth);
     2d6:	8903      	ldrh	r3, [r0, #8]
     2d8:	8942      	ldrh	r2, [r0, #10]
     2da:	8881      	ldrh	r1, [r0, #4]
     2dc:	b29b      	uxth	r3, r3
     2de:	b292      	uxth	r2, r2
  if (wr_idx >= rd_idx)
     2e0:	4293      	cmp	r3, r2
    return (uint16_t) (2*depth - (rd_idx - wr_idx));
     2e2:	bf36      	itet	cc
     2e4:	ebc2 0241 	rsbcc	r2, r2, r1, lsl #1
    return (uint16_t) (wr_idx - rd_idx);
     2e8:	1a9b      	subcs	r3, r3, r2
    return (uint16_t) (2*depth - (rd_idx - wr_idx));
     2ea:	189b      	addcc	r3, r3, r2
     2ec:	b298      	uxth	r0, r3
}
     2ee:	4288      	cmp	r0, r1
     2f0:	bf28      	it	cs
     2f2:	4608      	movcs	r0, r1
     2f4:	4770      	bx	lr

000002f6 <tu_fifo_remaining>:
    @returns Number of items in FIFO
 */
/******************************************************************************/
uint16_t tu_fifo_remaining(tu_fifo_t* f)
{
  return _ff_remaining(f->depth, f->wr_idx, f->rd_idx);
     2f6:	8882      	ldrh	r2, [r0, #4]
     2f8:	8903      	ldrh	r3, [r0, #8]
     2fa:	8940      	ldrh	r0, [r0, #10]
     2fc:	b29b      	uxth	r3, r3
     2fe:	b280      	uxth	r0, r0
  if (wr_idx >= rd_idx)
     300:	4283      	cmp	r3, r0
    return (uint16_t) (2*depth - (rd_idx - wr_idx));
     302:	bf36      	itet	cc
     304:	ebc0 0042 	rsbcc	r0, r0, r2, lsl #1
    return (uint16_t) (wr_idx - rd_idx);
     308:	1a18      	subcs	r0, r3, r0
    return (uint16_t) (2*depth - (rd_idx - wr_idx));
     30a:	18c0      	addcc	r0, r0, r3
     30c:	b280      	uxth	r0, r0
  return (depth > count) ? (depth - count) : 0;
     30e:	4282      	cmp	r2, r0
     310:	bf86      	itte	hi
     312:	1a10      	subhi	r0, r2, r0
     314:	b280      	uxthhi	r0, r0
     316:	2000      	movls	r0, #0
}
     318:	4770      	bx	lr

0000031a <tu_fifo_advance_write_pointer>:
    @param[in]  n
                Number of items the write pointer moves forward
 */
/******************************************************************************/
void tu_fifo_advance_write_pointer(tu_fifo_t *f, uint16_t n)
{
     31a:	b508      	push	{r3, lr}
     31c:	460a      	mov	r2, r1
  f->wr_idx = advance_index(f->depth, f->wr_idx, n);
     31e:	8901      	ldrh	r1, [r0, #8]
{
     320:	4603      	mov	r3, r0
  f->wr_idx = advance_index(f->depth, f->wr_idx, n);
     322:	b289      	uxth	r1, r1
     324:	8880      	ldrh	r0, [r0, #4]
     326:	f7ff ffca 	bl	2be <advance_index>
     32a:	8118      	strh	r0, [r3, #8]
}
     32c:	bd08      	pop	{r3, pc}

0000032e <tu_fifo_advance_read_pointer>:
    @param[in]  n
                Number of items the read pointer moves forward
 */
/******************************************************************************/
void tu_fifo_advance_read_pointer(tu_fifo_t *f, uint16_t n)
{
     32e:	b508      	push	{r3, lr}
     330:	460a      	mov	r2, r1
  f->rd_idx = advance_index(f->depth, f->rd_idx, n);
     332:	8941      	ldrh	r1, [r0, #10]
{
     334:	4603      	mov	r3, r0
  f->rd_idx = advance_index(f->depth, f->rd_idx, n);
     336:	b289      	uxth	r1, r1
     338:	8880      	ldrh	r0, [r0, #4]
     33a:	f7ff ffc0 	bl	2be <advance_index>
     33e:	8158      	strh	r0, [r3, #10]
}
     340:	bd08      	pop	{r3, pc}

00000342 <tu_fifo_get_read_info>:
   @param[out]      *info
                    Pointer to struct which holds the desired infos
 */
/******************************************************************************/
void tu_fifo_get_read_info(tu_fifo_t *f, tu_fifo_buffer_info_t *info)
{
     342:	b530      	push	{r4, r5, lr}
  // Operate on temporary values in case they change in between
  uint16_t wr_idx = f->wr_idx;
     344:	8904      	ldrh	r4, [r0, #8]
  uint16_t rd_idx = f->rd_idx;
     346:	8943      	ldrh	r3, [r0, #10]

  uint16_t cnt = _ff_count(f->depth, wr_idx, rd_idx);
     348:	8885      	ldrh	r5, [r0, #4]
  uint16_t wr_idx = f->wr_idx;
     34a:	b2a4      	uxth	r4, r4
  uint16_t rd_idx = f->rd_idx;
     34c:	b29b      	uxth	r3, r3
  if (wr_idx >= rd_idx)
     34e:	429c      	cmp	r4, r3
    return (uint16_t) (2*depth - (rd_idx - wr_idx));
     350:	bf36      	itet	cc
     352:	ebc3 0245 	rsbcc	r2, r3, r5, lsl #1
    return (uint16_t) (wr_idx - rd_idx);
     356:	1ae2      	subcs	r2, r4, r3
    return (uint16_t) (2*depth - (rd_idx - wr_idx));
     358:	1912      	addcc	r2, r2, r4
     35a:	b292      	uxth	r2, r2

  // Check overflow and correct if required - may happen in case a DMA wrote too fast
  if (cnt > f->depth)
     35c:	4295      	cmp	r5, r2
     35e:	d206      	bcs.n	36e <tu_fifo_get_read_info+0x2c>
  if ( wr_idx >= f->depth )
     360:	42a5      	cmp	r5, r4
    rd_idx = wr_idx - f->depth;
     362:	bf94      	ite	ls
     364:	1b63      	subls	r3, r4, r5
    rd_idx = wr_idx + f->depth;
     366:	192b      	addhi	r3, r5, r4
     368:	b29b      	uxth	r3, r3
  f->rd_idx = rd_idx;
     36a:	8143      	strh	r3, [r0, #10]
     36c:	462a      	mov	r2, r5

    cnt = f->depth;
  }

  // Check if fifo is empty
  if (cnt == 0)
     36e:	b92a      	cbnz	r2, 37c <tu_fifo_get_read_info+0x3a>
  {
    info->len_lin  = 0;
    info->len_wrap = 0;
    info->ptr_lin  = NULL;
     370:	e9c1 2200 	strd	r2, r2, [r1]
    info->ptr_wrap = NULL;
     374:	608a      	str	r2, [r1, #8]
    info->len_lin  = f->depth - rd_ptr;   // Also the case if FIFO was full

    info->len_wrap = cnt - info->len_lin;
    info->ptr_wrap = f->buffer;
  }
}
     376:	bd30      	pop	{r4, r5, pc}
  while ( idx >= depth ) idx -= depth;
     378:	1b64      	subs	r4, r4, r5
     37a:	b2a4      	uxth	r4, r4
     37c:	42a5      	cmp	r5, r4
     37e:	d9fb      	bls.n	378 <tu_fifo_get_read_info+0x36>
     380:	429d      	cmp	r5, r3
     382:	d909      	bls.n	398 <tu_fifo_get_read_info+0x56>
  info->ptr_lin = &f->buffer[rd_ptr];
     384:	6805      	ldr	r5, [r0, #0]
  if (wr_ptr > rd_ptr)
     386:	42a3      	cmp	r3, r4
  info->ptr_lin = &f->buffer[rd_ptr];
     388:	441d      	add	r5, r3
     38a:	604d      	str	r5, [r1, #4]
  if (wr_ptr > rd_ptr)
     38c:	d207      	bcs.n	39e <tu_fifo_get_read_info+0x5c>
    info->len_wrap = 0;
     38e:	2300      	movs	r3, #0
    info->len_lin  = cnt;
     390:	800a      	strh	r2, [r1, #0]
    info->len_wrap = 0;
     392:	804b      	strh	r3, [r1, #2]
    info->ptr_wrap = f->buffer;
     394:	608b      	str	r3, [r1, #8]
     396:	e7ee      	b.n	376 <tu_fifo_get_read_info+0x34>
  while ( idx >= depth ) idx -= depth;
     398:	1b5b      	subs	r3, r3, r5
     39a:	b29b      	uxth	r3, r3
     39c:	e7f0      	b.n	380 <tu_fifo_get_read_info+0x3e>
    info->len_lin  = f->depth - rd_ptr;   // Also the case if FIFO was full
     39e:	8884      	ldrh	r4, [r0, #4]
    info->len_wrap = cnt - info->len_lin;
     3a0:	1b12      	subs	r2, r2, r4
    info->len_lin  = f->depth - rd_ptr;   // Also the case if FIFO was full
     3a2:	1ae5      	subs	r5, r4, r3
    info->len_wrap = cnt - info->len_lin;
     3a4:	441a      	add	r2, r3
    info->len_lin  = f->depth - rd_ptr;   // Also the case if FIFO was full
     3a6:	800d      	strh	r5, [r1, #0]
    info->len_wrap = cnt - info->len_lin;
     3a8:	804a      	strh	r2, [r1, #2]
    info->ptr_wrap = f->buffer;
     3aa:	6803      	ldr	r3, [r0, #0]
     3ac:	e7f2      	b.n	394 <tu_fifo_get_read_info+0x52>

000003ae <tu_fifo_get_write_info>:
                    Pointer to struct which holds the desired infos
 */
/******************************************************************************/
void tu_fifo_get_write_info(tu_fifo_t *f, tu_fifo_buffer_info_t *info)
{
  uint16_t wr_idx = f->wr_idx;
     3ae:	8903      	ldrh	r3, [r0, #8]
  uint16_t rd_idx = f->rd_idx;
     3b0:	8942      	ldrh	r2, [r0, #10]
{
     3b2:	b570      	push	{r4, r5, r6, lr}
  uint16_t wr_idx = f->wr_idx;
     3b4:	b29b      	uxth	r3, r3
  uint16_t rd_idx = f->rd_idx;
     3b6:	b292      	uxth	r2, r2
  uint16_t remain = _ff_remaining(f->depth, wr_idx, rd_idx);
     3b8:	8884      	ldrh	r4, [r0, #4]
  if (wr_idx >= rd_idx)
     3ba:	4293      	cmp	r3, r2
    return (uint16_t) (2*depth - (rd_idx - wr_idx));
     3bc:	bf36      	itet	cc
     3be:	ebc2 0544 	rsbcc	r5, r2, r4, lsl #1
    return (uint16_t) (wr_idx - rd_idx);
     3c2:	1a9d      	subcs	r5, r3, r2
    return (uint16_t) (2*depth - (rd_idx - wr_idx));
     3c4:	18ed      	addcc	r5, r5, r3
     3c6:	b2ad      	uxth	r5, r5
  return (depth > count) ? (depth - count) : 0;
     3c8:	42ac      	cmp	r4, r5
     3ca:	d806      	bhi.n	3da <tu_fifo_get_write_info+0x2c>

  if (remain == 0)
  {
    info->len_lin  = 0;
     3cc:	2300      	movs	r3, #0
    info->len_wrap = 0;
    info->ptr_lin  = NULL;
     3ce:	e9c1 3300 	strd	r3, r3, [r1]
  }
  else
  {
    info->len_lin  = f->depth - wr_ptr;
    info->len_wrap = remain - info->len_lin; // Remaining length - n already was limited to remain or FIFO depth
    info->ptr_wrap = f->buffer;              // Always start of buffer
     3d2:	608b      	str	r3, [r1, #8]
  }
}
     3d4:	bd70      	pop	{r4, r5, r6, pc}
  while ( idx >= depth ) idx -= depth;
     3d6:	1b1b      	subs	r3, r3, r4
     3d8:	b29b      	uxth	r3, r3
     3da:	429c      	cmp	r4, r3
     3dc:	d9fb      	bls.n	3d6 <tu_fifo_get_write_info+0x28>
     3de:	4294      	cmp	r4, r2
     3e0:	d909      	bls.n	3f6 <tu_fifo_get_write_info+0x48>
  info->ptr_lin = &f->buffer[wr_ptr];
     3e2:	6806      	ldr	r6, [r0, #0]
  if (wr_ptr < rd_ptr)
     3e4:	429a      	cmp	r2, r3
  info->ptr_lin = &f->buffer[wr_ptr];
     3e6:	441e      	add	r6, r3
     3e8:	604e      	str	r6, [r1, #4]
  if (wr_ptr < rd_ptr)
     3ea:	d907      	bls.n	3fc <tu_fifo_get_write_info+0x4e>
    info->len_lin  = rd_ptr-wr_ptr;
     3ec:	1ad3      	subs	r3, r2, r3
     3ee:	800b      	strh	r3, [r1, #0]
    info->len_wrap = 0;
     3f0:	2300      	movs	r3, #0
     3f2:	804b      	strh	r3, [r1, #2]
    info->ptr_wrap = NULL;
     3f4:	e7ed      	b.n	3d2 <tu_fifo_get_write_info+0x24>
  while ( idx >= depth ) idx -= depth;
     3f6:	1b12      	subs	r2, r2, r4
     3f8:	b292      	uxth	r2, r2
     3fa:	e7f0      	b.n	3de <tu_fifo_get_write_info+0x30>
    info->len_lin  = f->depth - wr_ptr;
     3fc:	8882      	ldrh	r2, [r0, #4]
    info->len_wrap = remain - info->len_lin; // Remaining length - n already was limited to remain or FIFO depth
     3fe:	1aa4      	subs	r4, r4, r2
     400:	1b64      	subs	r4, r4, r5
    info->len_lin  = f->depth - wr_ptr;
     402:	1ad6      	subs	r6, r2, r3
    info->len_wrap = remain - info->len_lin; // Remaining length - n already was limited to remain or FIFO depth
     404:	4423      	add	r3, r4
    info->len_lin  = f->depth - wr_ptr;
     406:	800e      	strh	r6, [r1, #0]
    info->len_wrap = remain - info->len_lin; // Remaining length - n already was limited to remain or FIFO depth
     408:	804b      	strh	r3, [r1, #2]
    info->ptr_wrap = f->buffer;              // Always start of buffer
     40a:	6803      	ldr	r3, [r0, #0]
     40c:	e7e1      	b.n	3d2 <tu_fifo_get_write_info+0x24>
	...

00000410 <get_driver>:
// virtually joins built-in and application drivers together.
// Application is positioned first to allow overwriting built-in ones.
static inline usbd_class_driver_t const * get_driver(uint8_t drvid)
{
  // Application drivers
  if ( usbd_app_driver_get_cb )
     410:	4b0b      	ldr	r3, [pc, #44]	; (440 <get_driver+0x30>)
     412:	b163      	cbz	r3, 42e <get_driver+0x1e>
  {
    if ( drvid < _app_driver_count ) return &_app_driver[drvid];
     414:	4b0b      	ldr	r3, [pc, #44]	; (444 <get_driver+0x34>)
     416:	781b      	ldrb	r3, [r3, #0]
     418:	4283      	cmp	r3, r0
     41a:	d906      	bls.n	42a <get_driver+0x1a>
     41c:	4b0a      	ldr	r3, [pc, #40]	; (448 <get_driver+0x38>)
     41e:	681b      	ldr	r3, [r3, #0]
     420:	eb00 0040 	add.w	r0, r0, r0, lsl #1
    drvid -= _app_driver_count;
  }

  // Built-in drivers
  if (drvid < BUILTIN_DRIVER_COUNT) return &_usbd_driver[drvid];
     424:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
     428:	4770      	bx	lr
    drvid -= _app_driver_count;
     42a:	1ac0      	subs	r0, r0, r3
     42c:	b2c0      	uxtb	r0, r0
  if (drvid < BUILTIN_DRIVER_COUNT) return &_usbd_driver[drvid];
     42e:	2801      	cmp	r0, #1
     430:	d803      	bhi.n	43a <get_driver+0x2a>
     432:	4b06      	ldr	r3, [pc, #24]	; (44c <get_driver+0x3c>)
     434:	eb00 0040 	add.w	r0, r0, r0, lsl #1
     438:	e7f4      	b.n	424 <get_driver+0x14>

  return NULL;
     43a:	2000      	movs	r0, #0
}
     43c:	4770      	bx	lr
     43e:	bf00      	nop
     440:	00000000 	.word	0x00000000
     444:	20002020 	.word	0x20002020
     448:	2000201c 	.word	0x2000201c
     44c:	00002b38 	.word	0x00002b38

00000450 <invoke_class_control>:
//--------------------------------------------------------------------+

// Helper to invoke class driver control request handler
static bool invoke_class_control(uint8_t rhport, usbd_class_driver_t const * driver, tusb_control_request_t const * request)
{
  usbd_control_set_complete_callback(driver->control_xfer_cb);
     450:	68cb      	ldr	r3, [r1, #12]
}

// Set complete callback
void usbd_control_set_complete_callback( usbd_control_xfer_cb_t fp )
{
  _ctrl_xfer.complete_cb = fp;
     452:	4902      	ldr	r1, [pc, #8]	; (45c <invoke_class_control+0xc>)
     454:	610b      	str	r3, [r1, #16]
  TU_LOG(USBD_DBG, "  %s control request\r\n", driver->name);
  return driver->control_xfer_cb(rhport, CONTROL_STAGE_SETUP, request);
     456:	2101      	movs	r1, #1
     458:	4718      	bx	r3
     45a:	bf00      	nop
     45c:	2000214c 	.word	0x2000214c

00000460 <usbd_int_set>:
// USBD API For Class Driver
//--------------------------------------------------------------------+

void usbd_int_set(bool enabled)
{
  if (enabled)
     460:	4b06      	ldr	r3, [pc, #24]	; (47c <usbd_int_set+0x1c>)
     462:	f44f 5280 	mov.w	r2, #4096	; 0x1000
     466:	b108      	cbz	r0, 46c <usbd_int_set+0xc>
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
     468:	605a      	str	r2, [r3, #4]
    __COMPILER_BARRIER();
     46a:	4770      	bx	lr
 */
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
     46c:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
     470:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
     474:	f3bf 8f6f 	isb	sy
    dcd_int_enable(_usbd_rhport);
  }else
  {
    dcd_int_disable(_usbd_rhport);
  }
}
     478:	4770      	bx	lr
     47a:	bf00      	nop
     47c:	e000e100 	.word	0xe000e100

00000480 <update_free_block_list>:
  for (; cur < end && ((addr < cur->beg) || (cur->end <= addr)); ++cur) ;
  return cur;
}

static inline int update_free_block_list(free_block_t *blks, unsigned num, uint_fast16_t addr, uint_fast16_t size)
{
     480:	b538      	push	{r3, r4, r5, lr}
  free_block_t *p = find_containing_block(blks, blks + num, addr);
     482:	eb00 01c1 	add.w	r1, r0, r1, lsl #3
  for (; cur < end && ((addr < cur->beg) || (cur->end <= addr)); ++cur) ;
     486:	4281      	cmp	r1, r0
     488:	d91e      	bls.n	4c8 <update_free_block_list+0x48>
     48a:	6804      	ldr	r4, [r0, #0]
     48c:	42a2      	cmp	r2, r4
     48e:	d319      	bcc.n	4c4 <update_free_block_list+0x44>
     490:	6844      	ldr	r4, [r0, #4]
     492:	42a2      	cmp	r2, r4
     494:	d216      	bcs.n	4c4 <update_free_block_list+0x44>
  TU_ASSERT(p != blks + num, -2);
  if (p->beg == addr) {
     496:	e9d0 5400 	ldrd	r5, r4, [r0]
     49a:	4295      	cmp	r5, r2
    /* Shrink block */
    p->beg = addr + size;
     49c:	4413      	add	r3, r2
  if (p->beg == addr) {
     49e:	d120      	bne.n	4e2 <update_free_block_list+0x62>
    if (p->beg != p->end) return 0;
     4a0:	42a3      	cmp	r3, r4
    p->beg = addr + size;
     4a2:	6003      	str	r3, [r0, #0]
    if (p->beg != p->end) return 0;
     4a4:	d11b      	bne.n	4de <update_free_block_list+0x5e>
    /* remove block */
    free_block_t *end = blks + num;
    while (p + 1 < end) {
      *p = *(p + 1);
     4a6:	1e4a      	subs	r2, r1, #1
     4a8:	1a12      	subs	r2, r2, r0
     4aa:	1c43      	adds	r3, r0, #1
     4ac:	f022 0207 	bic.w	r2, r2, #7
     4b0:	428b      	cmp	r3, r1
     4b2:	bf88      	it	hi
     4b4:	2200      	movhi	r2, #0
     4b6:	f100 0108 	add.w	r1, r0, #8
     4ba:	f002 fac9 	bl	2a50 <memmove>
      ++p;
    }
    return -1;
     4be:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    }
    if (tmp.beg == tmp.end) return 0;
    blks[num] = tmp;
    return 1;
  }
}
     4c2:	bd38      	pop	{r3, r4, r5, pc}
  for (; cur < end && ((addr < cur->beg) || (cur->end <= addr)); ++cur) ;
     4c4:	3008      	adds	r0, #8
     4c6:	e7de      	b.n	486 <update_free_block_list+0x6>
  TU_ASSERT(p != blks + num, -2);
     4c8:	d1e5      	bne.n	496 <update_free_block_list+0x16>
     4ca:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
     4ce:	f8d3 3df0 	ldr.w	r3, [r3, #3568]	; 0xdf0
     4d2:	07db      	lsls	r3, r3, #31
     4d4:	d500      	bpl.n	4d8 <update_free_block_list+0x58>
     4d6:	be00      	bkpt	0x0000
     4d8:	f06f 0001 	mvn.w	r0, #1
     4dc:	e7f1      	b.n	4c2 <update_free_block_list+0x42>
    if (p->beg != p->end) return 0;
     4de:	2000      	movs	r0, #0
     4e0:	e7ef      	b.n	4c2 <update_free_block_list+0x42>
    if (tmp.beg == tmp.end) return 0;
     4e2:	42a3      	cmp	r3, r4
    p->end = addr;
     4e4:	6042      	str	r2, [r0, #4]
    if (tmp.beg == tmp.end) return 0;
     4e6:	d0fa      	beq.n	4de <update_free_block_list+0x5e>
    blks[num] = tmp;
     4e8:	e9c1 3400 	strd	r3, r4, [r1]
    return 1;
     4ec:	2001      	movs	r0, #1
     4ee:	e7e8      	b.n	4c2 <update_free_block_list+0x42>

000004f0 <pipe_write_packet>:
  volatile hw_endpoint_t *regs = (volatile hw_endpoint_t*)((uintptr_t)&USB0->TXMAXP1);
  return regs + epnum_minus1;
}

static void pipe_write_packet(void *buf, volatile void *fifo, unsigned len)
{
     4f0:	b570      	push	{r4, r5, r6, lr}
     4f2:	f022 0403 	bic.w	r4, r2, #3
     4f6:	0893      	lsrs	r3, r2, #2
     4f8:	4404      	add	r4, r0
  volatile hw_fifo_t *reg = (volatile hw_fifo_t*)fifo;
  uintptr_t addr = (uintptr_t)buf;
     4fa:	4605      	mov	r5, r0
  while (len >= 4) {
     4fc:	42a5      	cmp	r5, r4
     4fe:	d110      	bne.n	522 <pipe_write_packet+0x32>
     500:	f06f 0403 	mvn.w	r4, #3
     504:	fb04 2303 	mla	r3, r4, r3, r2
     508:	4022      	ands	r2, r4
    reg->u32 = *(uint32_t const *)addr;
    addr += 4;
    len  -= 4;
  }
  if (len >= 2) {
     50a:	2b01      	cmp	r3, #1
     50c:	eb00 0402 	add.w	r4, r0, r2
    reg->u16 = *(uint16_t const *)addr;
    addr += 2;
    len  -= 2;
     510:	bf81      	itttt	hi
     512:	3b02      	subhi	r3, #2
    reg->u16 = *(uint16_t const *)addr;
     514:	5a82      	ldrhhi	r2, [r0, r2]
     516:	800a      	strhhi	r2, [r1, #0]
    addr += 2;
     518:	3402      	addhi	r4, #2
  }
  if (len) {
     51a:	b10b      	cbz	r3, 520 <pipe_write_packet+0x30>
    reg->u8 = *(uint8_t const *)addr;
     51c:	7823      	ldrb	r3, [r4, #0]
     51e:	700b      	strb	r3, [r1, #0]
  }
}
     520:	bd70      	pop	{r4, r5, r6, pc}
    reg->u32 = *(uint32_t const *)addr;
     522:	f855 6b04 	ldr.w	r6, [r5], #4
     526:	600e      	str	r6, [r1, #0]
    len  -= 4;
     528:	e7e8      	b.n	4fc <pipe_write_packet+0xc>

0000052a <pipe_read_packet>:

static void pipe_read_packet(void *buf, volatile void *fifo, unsigned len)
{
     52a:	b570      	push	{r4, r5, r6, lr}
     52c:	f022 0403 	bic.w	r4, r2, #3
     530:	0893      	lsrs	r3, r2, #2
     532:	4404      	add	r4, r0
  volatile hw_fifo_t *reg = (volatile hw_fifo_t*)fifo;
  uintptr_t addr = (uintptr_t)buf;
     534:	4605      	mov	r5, r0
  while (len >= 4) {
     536:	42a5      	cmp	r5, r4
     538:	d112      	bne.n	560 <pipe_read_packet+0x36>
     53a:	f06f 0403 	mvn.w	r4, #3
     53e:	fb04 2303 	mla	r3, r4, r3, r2
    *(uint32_t *)addr = reg->u32;
    addr += 4;
    len  -= 4;
  }
  if (len >= 2) {
     542:	2b01      	cmp	r3, #1
     544:	ea02 0204 	and.w	r2, r2, r4
    *(uint16_t *)addr = reg->u16;
     548:	bf84      	itt	hi
     54a:	880d      	ldrhhi	r5, [r1, #0]
     54c:	5285      	strhhi	r5, [r0, r2]
     54e:	eb00 0402 	add.w	r4, r0, r2
    addr += 2;
    len  -= 2;
     552:	bf84      	itt	hi
     554:	3b02      	subhi	r3, #2
    addr += 2;
     556:	3402      	addhi	r4, #2
  }
  if (len) {
     558:	b10b      	cbz	r3, 55e <pipe_read_packet+0x34>
    *(uint8_t *)addr = reg->u8;
     55a:	780b      	ldrb	r3, [r1, #0]
     55c:	7023      	strb	r3, [r4, #0]
  }
}
     55e:	bd70      	pop	{r4, r5, r6, pc}
    *(uint32_t *)addr = reg->u32;
     560:	680e      	ldr	r6, [r1, #0]
     562:	f845 6b04 	str.w	r6, [r5], #4
    len  -= 4;
     566:	e7e6      	b.n	536 <pipe_read_packet+0xc>

00000568 <pipe_read_write_packet_ff>:

static void pipe_read_write_packet_ff(tu_fifo_t *f, volatile void *fifo, unsigned len, unsigned dir)
{
     568:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     56c:	4698      	mov	r8, r3
  } ops[] = {
    /* OUT */ {tu_fifo_get_write_info,tu_fifo_advance_write_pointer,pipe_read_packet},
    /* IN  */ {tu_fifo_get_read_info, tu_fifo_advance_read_pointer, pipe_write_packet},
  };
  tu_fifo_buffer_info_t info;
  ops[dir].tu_fifo_get_info(f, &info);
     56e:	230c      	movs	r3, #12
     570:	4e17      	ldr	r6, [pc, #92]	; (5d0 <pipe_read_write_packet_ff+0x68>)
     572:	fb03 f308 	mul.w	r3, r3, r8
{
     576:	b085      	sub	sp, #20
     578:	4689      	mov	r9, r1
  ops[dir].tu_fifo_get_info(f, &info);
     57a:	eb06 0a03 	add.w	sl, r6, r3
     57e:	a901      	add	r1, sp, #4
     580:	58f3      	ldr	r3, [r6, r3]
{
     582:	4615      	mov	r5, r2
     584:	4607      	mov	r7, r0
  ops[dir].tu_fifo_get_info(f, &info);
     586:	4798      	blx	r3
  unsigned total_len = len;
  len = TU_MIN(total_len, info.len_lin);
     588:	f8bd 4004 	ldrh.w	r4, [sp, #4]
  ops[dir].pipe_read_write(info.ptr_lin, fifo, len);
     58c:	f8da b008 	ldr.w	fp, [sl, #8]
     590:	9802      	ldr	r0, [sp, #8]
  len = TU_MIN(total_len, info.len_lin);
     592:	42ac      	cmp	r4, r5
     594:	bf28      	it	cs
     596:	462c      	movcs	r4, r5
  ops[dir].pipe_read_write(info.ptr_lin, fifo, len);
     598:	4622      	mov	r2, r4
     59a:	4649      	mov	r1, r9
     59c:	47d8      	blx	fp
  unsigned rem = total_len - len;
  if (rem) {
     59e:	1b2c      	subs	r4, r5, r4
     5a0:	d00a      	beq.n	5b8 <pipe_read_write_packet_ff+0x50>
    len = TU_MIN(rem, info.len_wrap);
     5a2:	f8bd a006 	ldrh.w	sl, [sp, #6]
    ops[dir].pipe_read_write(info.ptr_wrap, fifo, len);
     5a6:	9803      	ldr	r0, [sp, #12]
    len = TU_MIN(rem, info.len_wrap);
     5a8:	45a2      	cmp	sl, r4
     5aa:	bf28      	it	cs
     5ac:	46a2      	movcs	sl, r4
    ops[dir].pipe_read_write(info.ptr_wrap, fifo, len);
     5ae:	4652      	mov	r2, sl
     5b0:	4649      	mov	r1, r9
     5b2:	47d8      	blx	fp
    rem -= len;
     5b4:	eba4 040a 	sub.w	r4, r4, sl
  }
  ops[dir].tu_fifo_advance(f, total_len - rem);
     5b8:	230c      	movs	r3, #12
     5ba:	fb03 6608 	mla	r6, r3, r8, r6
     5be:	1b29      	subs	r1, r5, r4
     5c0:	6873      	ldr	r3, [r6, #4]
     5c2:	b289      	uxth	r1, r1
     5c4:	4638      	mov	r0, r7
     5c6:	4798      	blx	r3
}
     5c8:	b005      	add	sp, #20
     5ca:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
     5ce:	bf00      	nop
     5d0:	00002bdc 	.word	0x00002bdc

000005d4 <handle_xfer_in>:
  /* Clear RX FIFO and reverse the transaction direction */
  if (len && dir_in) USB0->CSRL0 = USB_CSRL0_RXRDYC;
}

static bool handle_xfer_in(uint_fast8_t ep_addr)
{
     5d4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  unsigned epnum_minus1 = tu_edpt_number(ep_addr) - 1;
  pipe_state_t  *pipe = &_dcd.pipe[tu_edpt_dir(ep_addr)][epnum_minus1];
     5d8:	f3c0 18c0 	ubfx	r8, r0, #7, #1
  unsigned epnum_minus1 = tu_edpt_number(ep_addr) - 1;
     5dc:	f000 077f 	and.w	r7, r0, #127	; 0x7f
     5e0:	3f01      	subs	r7, #1
  const unsigned rem  = pipe->remaining;
     5e2:	ebc8 04c8 	rsb	r4, r8, r8, lsl #3
     5e6:	f8df 9084 	ldr.w	r9, [pc, #132]	; 66c <handle_xfer_in+0x98>
     5ea:	443c      	add	r4, r7
     5ec:	3402      	adds	r4, #2
     5ee:	eb09 04c4 	add.w	r4, r9, r4, lsl #3
     5f2:	ea4f 0bc8 	mov.w	fp, r8, lsl #3
     5f6:	f8b4 5009 	ldrh.w	r5, [r4, #9]

  if (!rem) {
     5fa:	b935      	cbnz	r5, 60a <handle_xfer_in+0x36>
    pipe->buf = NULL;
     5fc:	70e5      	strb	r5, [r4, #3]
     5fe:	7125      	strb	r5, [r4, #4]
     600:	7165      	strb	r5, [r4, #5]
     602:	71a5      	strb	r5, [r4, #6]
    return true;
     604:	2001      	movs	r0, #1
    pipe->remaining = rem - len;
  }
  regs->TXCSRL = USB_TXCSRL1_TXRDY;
  // TU_LOG1(" TXCSRL%d = %x %d\n", epnum_minus1 + 1, regs->TXCSRL, rem - len);
  return false;
}
     606:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  return regs + epnum_minus1;
     60a:	4a16      	ldr	r2, [pc, #88]	; (664 <handle_xfer_in+0x90>)
     60c:	013b      	lsls	r3, r7, #4
     60e:	eb02 1a07 	add.w	sl, r2, r7, lsl #4
  const unsigned mps = regs->TXMAXP;
     612:	5a9e      	ldrh	r6, [r3, r2]
     614:	b2b6      	uxth	r6, r6
  const unsigned len = TU_MIN(mps, rem);
     616:	42ae      	cmp	r6, r5
     618:	bf28      	it	cs
     61a:	462e      	movcs	r6, r5
  if (len) {
     61c:	b1ae      	cbz	r6, 64a <handle_xfer_in+0x76>
    if (_dcd.pipe_buf_is_fifo[TUSB_DIR_IN] & TU_BIT(epnum_minus1)) {
     61e:	f8b9 3086 	ldrh.w	r3, [r9, #134]	; 0x86
      pipe_read_write_packet_ff(buf, &USB0->FIFO1_WORD + epnum_minus1, len, TUSB_DIR_IN);
     622:	4911      	ldr	r1, [pc, #68]	; (668 <handle_xfer_in+0x94>)
  void          *buf = pipe->buf;
     624:	f8d4 0003 	ldr.w	r0, [r4, #3]
    if (_dcd.pipe_buf_is_fifo[TUSB_DIR_IN] & TU_BIT(epnum_minus1)) {
     628:	40fb      	lsrs	r3, r7
     62a:	07db      	lsls	r3, r3, #31
      pipe_read_write_packet_ff(buf, &USB0->FIFO1_WORD + epnum_minus1, len, TUSB_DIR_IN);
     62c:	eb01 0187 	add.w	r1, r1, r7, lsl #2
    if (_dcd.pipe_buf_is_fifo[TUSB_DIR_IN] & TU_BIT(epnum_minus1)) {
     630:	d510      	bpl.n	654 <handle_xfer_in+0x80>
      pipe_read_write_packet_ff(buf, &USB0->FIFO1_WORD + epnum_minus1, len, TUSB_DIR_IN);
     632:	2301      	movs	r3, #1
     634:	4632      	mov	r2, r6
     636:	f7ff ff97 	bl	568 <pipe_read_write_packet_ff>
    pipe->remaining = rem - len;
     63a:	ebab 0808 	sub.w	r8, fp, r8
     63e:	4447      	add	r7, r8
     640:	eb09 09c7 	add.w	r9, r9, r7, lsl #3
     644:	1bad      	subs	r5, r5, r6
     646:	f8a9 5019 	strh.w	r5, [r9, #25]
  regs->TXCSRL = USB_TXCSRL1_TXRDY;
     64a:	2301      	movs	r3, #1
     64c:	f88a 3002 	strb.w	r3, [sl, #2]
  return false;
     650:	2000      	movs	r0, #0
     652:	e7d8      	b.n	606 <handle_xfer_in+0x32>
      pipe_write_packet(buf, &USB0->FIFO1_WORD + epnum_minus1, len);
     654:	4632      	mov	r2, r6
     656:	f7ff ff4b 	bl	4f0 <pipe_write_packet>
      pipe->buf       = buf + len;
     65a:	4430      	add	r0, r6
     65c:	f8c4 0003 	str.w	r0, [r4, #3]
     660:	e7eb      	b.n	63a <handle_xfer_in+0x66>
     662:	bf00      	nop
     664:	40050110 	.word	0x40050110
     668:	40050024 	.word	0x40050024
     66c:	20002160 	.word	0x20002160

00000670 <dcd_edpt_stall.constprop.0>:
  if (ie) NVIC_EnableIRQ(USB0_IRQn);
  return ret;
}

// Stall endpoint
void dcd_edpt_stall(uint8_t rhport, uint8_t ep_addr)
     670:	b510      	push	{r4, lr}
    return((uint32_t)(((NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
     672:	4a1b      	ldr	r2, [pc, #108]	; (6e0 <dcd_edpt_stall.constprop.0+0x70>)
     674:	6851      	ldr	r1, [r2, #4]
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
     676:	f44f 5480 	mov.w	r4, #4096	; 0x1000
}

// Get Endpoint number from address
TU_ATTR_ALWAYS_INLINE static inline uint8_t tu_edpt_number(uint8_t addr)
{
  return (uint8_t)(addr & (~TUSB_DIR_IN_MASK));
     67a:	f000 037f 	and.w	r3, r0, #127	; 0x7f
    return((uint32_t)(((NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
     67e:	f3c1 3100 	ubfx	r1, r1, #12, #1
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
     682:	f8c2 4084 	str.w	r4, [r2, #132]	; 0x84
  __ASM volatile ("dsb 0xF":::"memory");
     686:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
     68a:	f3bf 8f6f 	isb	sy
{
  (void)rhport;
  unsigned const epn = tu_edpt_number(ep_addr);
  unsigned const ie  = NVIC_GetEnableIRQ(USB0_IRQn);
  NVIC_DisableIRQ(USB0_IRQn);
  if (0 == epn) {
     68e:	b98b      	cbnz	r3, 6b4 <dcd_edpt_stall.constprop.0+0x44>
    if (!ep_addr) { /* Ignore EP80 */
     690:	b950      	cbnz	r0, 6a8 <dcd_edpt_stall.constprop.0+0x38>
      _dcd.setup_packet.bmRequestType = REQUEST_TYPE_INVALID;
     692:	4b14      	ldr	r3, [pc, #80]	; (6e4 <dcd_edpt_stall.constprop.0+0x74>)
     694:	22ff      	movs	r2, #255	; 0xff
     696:	701a      	strb	r2, [r3, #0]
      _dcd.pipe0.buf = NULL;
     698:	72d8      	strb	r0, [r3, #11]
     69a:	7318      	strb	r0, [r3, #12]
     69c:	7358      	strb	r0, [r3, #13]
     69e:	7398      	strb	r0, [r3, #14]
      USB0->CSRL0 = USB_CSRL0_STALL;
     6a0:	4b11      	ldr	r3, [pc, #68]	; (6e8 <dcd_edpt_stall.constprop.0+0x78>)
     6a2:	2220      	movs	r2, #32
     6a4:	f883 2102 	strb.w	r2, [r3, #258]	; 0x102
    } else { /* OUT */
      TU_ASSERT(!(regs->RXCSRL & USB_RXCSRL1_RXRDY),);
      regs->RXCSRL = USB_RXCSRL1_STALL;
    }
  }
  if (ie) NVIC_EnableIRQ(USB0_IRQn);
     6a8:	b1b1      	cbz	r1, 6d8 <dcd_edpt_stall.constprop.0+0x68>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
     6aa:	4b0d      	ldr	r3, [pc, #52]	; (6e0 <dcd_edpt_stall.constprop.0+0x70>)
     6ac:	f44f 5280 	mov.w	r2, #4096	; 0x1000
     6b0:	605a      	str	r2, [r3, #4]
}
     6b2:	e011      	b.n	6d8 <dcd_edpt_stall.constprop.0+0x68>
  return regs + epnum_minus1;
     6b4:	011a      	lsls	r2, r3, #4
     6b6:	4b0d      	ldr	r3, [pc, #52]	; (6ec <dcd_edpt_stall.constprop.0+0x7c>)
     6b8:	4413      	add	r3, r2
    if (tu_edpt_dir(ep_addr)) { /* IN */
     6ba:	09c2      	lsrs	r2, r0, #7
     6bc:	d002      	beq.n	6c4 <dcd_edpt_stall.constprop.0+0x54>
      regs->TXCSRL = USB_TXCSRL1_STALL;
     6be:	2210      	movs	r2, #16
     6c0:	709a      	strb	r2, [r3, #2]
     6c2:	e7f1      	b.n	6a8 <dcd_edpt_stall.constprop.0+0x38>
      TU_ASSERT(!(regs->RXCSRL & USB_RXCSRL1_RXRDY),);
     6c4:	799a      	ldrb	r2, [r3, #6]
     6c6:	07d2      	lsls	r2, r2, #31
     6c8:	d507      	bpl.n	6da <dcd_edpt_stall.constprop.0+0x6a>
     6ca:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
     6ce:	f8d3 3df0 	ldr.w	r3, [r3, #3568]	; 0xdf0
     6d2:	07db      	lsls	r3, r3, #31
     6d4:	d500      	bpl.n	6d8 <dcd_edpt_stall.constprop.0+0x68>
     6d6:	be00      	bkpt	0x0000
}
     6d8:	bd10      	pop	{r4, pc}
      regs->RXCSRL = USB_RXCSRL1_STALL;
     6da:	2220      	movs	r2, #32
     6dc:	719a      	strb	r2, [r3, #6]
     6de:	e7e3      	b.n	6a8 <dcd_edpt_stall.constprop.0+0x38>
     6e0:	e000e100 	.word	0xe000e100
     6e4:	20002160 	.word	0x20002160
     6e8:	40050000 	.word	0x40050000
     6ec:	40050100 	.word	0x40050100

000006f0 <usbd_edpt_stall.constprop.0>:
  uint8_t const dir   = tu_edpt_dir(ep_addr);

  return _usbd_dev.ep_status[epnum][dir].busy;
}

void usbd_edpt_stall(uint8_t rhport, uint8_t ep_addr)
     6f0:	b510      	push	{r4, lr}

  uint8_t const epnum = tu_edpt_number(ep_addr);
  uint8_t const dir   = tu_edpt_dir(ep_addr);

  // only stalled if currently cleared
  if ( !_usbd_dev.ep_status[epnum][dir].stalled )
     6f2:	4b0b      	ldr	r3, [pc, #44]	; (720 <usbd_edpt_stall.constprop.0+0x30>)
     6f4:	f000 027f 	and.w	r2, r0, #127	; 0x7f
     6f8:	eb03 0342 	add.w	r3, r3, r2, lsl #1
     6fc:	eb03 14d0 	add.w	r4, r3, r0, lsr #7
     700:	3420      	adds	r4, #32
     702:	78e3      	ldrb	r3, [r4, #3]
     704:	079b      	lsls	r3, r3, #30
     706:	d409      	bmi.n	71c <usbd_edpt_stall.constprop.0+0x2c>
  {
    TU_LOG(USBD_DBG, "    Stall EP %02X\r\n", ep_addr);
    dcd_edpt_stall(rhport, ep_addr);
     708:	f7ff ffb2 	bl	670 <dcd_edpt_stall.constprop.0>
    _usbd_dev.ep_status[epnum][dir].stalled = true;
     70c:	78e3      	ldrb	r3, [r4, #3]
     70e:	f043 0302 	orr.w	r3, r3, #2
     712:	70e3      	strb	r3, [r4, #3]
    _usbd_dev.ep_status[epnum][dir].busy = true;
     714:	78e3      	ldrb	r3, [r4, #3]
     716:	f043 0301 	orr.w	r3, r3, #1
     71a:	70e3      	strb	r3, [r4, #3]
  }
}
     71c:	bd10      	pop	{r4, pc}
     71e:	bf00      	nop
     720:	200024a8 	.word	0x200024a8

00000724 <usbd_edpt_claim.constprop.0>:
bool tu_edpt_claim(tu_edpt_state_t* ep_state, osal_mutex_t mutex)
{
  (void) mutex;

  // pre-check to help reducing mutex lock
  TU_VERIFY((ep_state->busy == 0) && (ep_state->claimed == 0));
     724:	4a10      	ldr	r2, [pc, #64]	; (768 <usbd_edpt_claim.constprop.0+0x44>)
  tu_edpt_state_t* ep_state = &_usbd_dev.ep_status[epnum][dir];
     726:	f000 037f 	and.w	r3, r0, #127	; 0x7f
     72a:	eb02 0243 	add.w	r2, r2, r3, lsl #1
     72e:	eb02 13d0 	add.w	r3, r2, r0, lsr #7
     732:	3320      	adds	r3, #32
     734:	78d8      	ldrb	r0, [r3, #3]
     736:	f010 0001 	ands.w	r0, r0, #1
     73a:	d111      	bne.n	760 <usbd_edpt_claim.constprop.0+0x3c>
     73c:	78da      	ldrb	r2, [r3, #3]
     73e:	f3c2 0180 	ubfx	r1, r2, #2, #1
     742:	0752      	lsls	r2, r2, #29
     744:	d40f      	bmi.n	766 <usbd_edpt_claim.constprop.0+0x42>
  (void) osal_mutex_lock(mutex, OSAL_TIMEOUT_WAIT_FOREVER);

  // can only claim the endpoint if it is not busy and not claimed yet.
  bool const available = (ep_state->busy == 0) && (ep_state->claimed == 0);
     746:	78d8      	ldrb	r0, [r3, #3]
     748:	f010 0001 	ands.w	r0, r0, #1
     74c:	d10a      	bne.n	764 <usbd_edpt_claim.constprop.0+0x40>
     74e:	78da      	ldrb	r2, [r3, #3]
     750:	0752      	lsls	r2, r2, #29
     752:	d408      	bmi.n	766 <usbd_edpt_claim.constprop.0+0x42>
  if (available)
  {
    ep_state->claimed = 1;
     754:	78da      	ldrb	r2, [r3, #3]
     756:	f042 0204 	orr.w	r2, r2, #4
     75a:	70da      	strb	r2, [r3, #3]
     75c:	2001      	movs	r0, #1
     75e:	4770      	bx	lr
     760:	2000      	movs	r0, #0
     762:	4770      	bx	lr
     764:	4608      	mov	r0, r1
}
     766:	4770      	bx	lr
     768:	200024a8 	.word	0x200024a8

0000076c <usbd_edpt_release.constprop.0.isra.0>:
  (void) mutex;

  (void) osal_mutex_lock(mutex, OSAL_TIMEOUT_WAIT_FOREVER);

  // can only release the endpoint if it is claimed and not busy
  bool const ret = (ep_state->claimed == 1) && (ep_state->busy == 0);
     76c:	4b09      	ldr	r3, [pc, #36]	; (794 <usbd_edpt_release.constprop.0.isra.0+0x28>)
  tu_edpt_state_t* ep_state = &_usbd_dev.ep_status[epnum][dir];
     76e:	f000 027f 	and.w	r2, r0, #127	; 0x7f
     772:	eb03 0342 	add.w	r3, r3, r2, lsl #1
     776:	eb03 10d0 	add.w	r0, r3, r0, lsr #7
     77a:	3020      	adds	r0, #32
     77c:	78c3      	ldrb	r3, [r0, #3]
     77e:	075b      	lsls	r3, r3, #29
     780:	d507      	bpl.n	792 <usbd_edpt_release.constprop.0.isra.0+0x26>
     782:	78c3      	ldrb	r3, [r0, #3]
     784:	f013 0201 	ands.w	r2, r3, #1
  if (ret)
  {
    ep_state->claimed = 0;
     788:	bf02      	ittt	eq
     78a:	78c3      	ldrbeq	r3, [r0, #3]
     78c:	f362 0382 	bfieq	r3, r2, #2, #1
     790:	70c3      	strbeq	r3, [r0, #3]
}
     792:	4770      	bx	lr
     794:	200024a8 	.word	0x200024a8

00000798 <fail_scsi_op.constprop.0.isra.0>:
{
  p_msc->stage = MSC_STAGE_CMD;
  return usbd_edpt_xfer(rhport, p_msc->ep_out, (uint8_t*) &p_msc->cbw, sizeof(msc_cbw_t));
}

static void fail_scsi_op(uint8_t rhport, mscd_interface_t* p_msc, uint8_t status)
     798:	b410      	push	{r4}
{
  msc_cbw_t const * p_cbw = &p_msc->cbw;
  msc_csw_t       * p_csw = &p_msc->csw;

  p_csw->status       = status;
     79a:	4b11      	ldr	r3, [pc, #68]	; (7e0 <fail_scsi_op.constprop.0.isra.0+0x48>)
  p_csw->data_residue = p_msc->cbw.total_bytes - p_msc->xferred_len;
     79c:	6899      	ldr	r1, [r3, #8]
     79e:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  p_csw->status       = status;
     7a0:	f883 002c 	strb.w	r0, [r3, #44]	; 0x2c
  p_msc->stage        = MSC_STAGE_STATUS;
     7a4:	2002      	movs	r0, #2
     7a6:	f883 0030 	strb.w	r0, [r3, #48]	; 0x30

  // failed but sense key is not set: default to Illegal Request
  if ( p_msc->sense_key == 0 ) tud_msc_set_sense(p_cbw->lun, SCSI_SENSE_ILLEGAL_REQUEST, 0x20, 0x00);
     7aa:	f893 003c 	ldrb.w	r0, [r3, #60]	; 0x3c
  p_csw->data_residue = p_msc->cbw.total_bytes - p_msc->xferred_len;
     7ae:	1a8a      	subs	r2, r1, r2
     7b0:	629a      	str	r2, [r3, #40]	; 0x28
  if ( p_msc->sense_key == 0 ) tud_msc_set_sense(p_cbw->lun, SCSI_SENSE_ILLEGAL_REQUEST, 0x20, 0x00);
     7b2:	b920      	cbnz	r0, 7be <fail_scsi_op.constprop.0.isra.0+0x26>
//--------------------------------------------------------------------+
bool tud_msc_set_sense(uint8_t lun, uint8_t sense_key, uint8_t add_sense_code, uint8_t add_sense_qualifier)
{
  (void) lun;

  _mscd_itf.sense_key           = sense_key;
     7b4:	f242 0405 	movw	r4, #8197	; 0x2005
     7b8:	879c      	strh	r4, [r3, #60]	; 0x3c
  _mscd_itf.add_sense_code      = add_sense_code;
  _mscd_itf.add_sense_qualifier = add_sense_qualifier;
     7ba:	f883 003e 	strb.w	r0, [r3, #62]	; 0x3e
  if ( p_cbw->total_bytes && p_csw->data_residue )
     7be:	b159      	cbz	r1, 7d8 <fail_scsi_op.constprop.0.isra.0+0x40>
     7c0:	b152      	cbz	r2, 7d8 <fail_scsi_op.constprop.0.isra.0+0x40>
  return tu_bit_test(dir, 7);
     7c2:	7b1a      	ldrb	r2, [r3, #12]
}
     7c4:	f85d 4b04 	ldr.w	r4, [sp], #4
    if ( is_data_in(p_cbw->dir) )
     7c8:	09d2      	lsrs	r2, r2, #7
      usbd_edpt_stall(rhport, p_msc->ep_in);
     7ca:	bf14      	ite	ne
     7cc:	f893 002e 	ldrbne.w	r0, [r3, #46]	; 0x2e
      usbd_edpt_stall(rhport, p_msc->ep_out);
     7d0:	f893 002f 	ldrbeq.w	r0, [r3, #47]	; 0x2f
     7d4:	f7ff bf8c 	b.w	6f0 <usbd_edpt_stall.constprop.0>
}
     7d8:	f85d 4b04 	ldr.w	r4, [sp], #4
     7dc:	4770      	bx	lr
     7de:	bf00      	nop
     7e0:	20002428 	.word	0x20002428

000007e4 <tu_fifo_write>:
{
     7e4:	b570      	push	{r4, r5, r6, lr}
  uint16_t const wr_idx = f->wr_idx;
     7e6:	8905      	ldrh	r5, [r0, #8]
  return _ff_count(f->depth, f->wr_idx, f->rd_idx) >= f->depth;
     7e8:	8903      	ldrh	r3, [r0, #8]
     7ea:	8942      	ldrh	r2, [r0, #10]
     7ec:	8886      	ldrh	r6, [r0, #4]
     7ee:	b29b      	uxth	r3, r3
     7f0:	b292      	uxth	r2, r2
  if (wr_idx >= rd_idx)
     7f2:	4293      	cmp	r3, r2
    return (uint16_t) (2*depth - (rd_idx - wr_idx));
     7f4:	bf36      	itet	cc
     7f6:	ebc2 0246 	rsbcc	r2, r2, r6, lsl #1
    return (uint16_t) (wr_idx - rd_idx);
     7fa:	1a9b      	subcs	r3, r3, r2
    return (uint16_t) (2*depth - (rd_idx - wr_idx));
     7fc:	189b      	addcc	r3, r3, r2
     7fe:	b29b      	uxth	r3, r3
  if ( tu_fifo_full(f) && !f->overwritable )
     800:	429e      	cmp	r6, r3
{
     802:	4604      	mov	r4, r0
  uint16_t const wr_idx = f->wr_idx;
     804:	b2ad      	uxth	r5, r5
  if ( tu_fifo_full(f) && !f->overwritable )
     806:	d817      	bhi.n	838 <tu_fifo_write+0x54>
     808:	79c0      	ldrb	r0, [r0, #7]
     80a:	09c0      	lsrs	r0, r0, #7
     80c:	d114      	bne.n	838 <tu_fifo_write+0x54>
}
     80e:	bd70      	pop	{r4, r5, r6, pc}
  while ( idx >= depth ) idx -= depth;
     810:	1b9b      	subs	r3, r3, r6
     812:	b29b      	uxth	r3, r3
     814:	42b3      	cmp	r3, r6
     816:	d2fb      	bcs.n	810 <tu_fifo_write+0x2c>
  memcpy(f->buffer + (rel * f->item_size), app_buf, f->item_size);
     818:	88e2      	ldrh	r2, [r4, #6]
     81a:	6820      	ldr	r0, [r4, #0]
     81c:	f3c2 020e 	ubfx	r2, r2, #0, #15
     820:	fb02 0003 	mla	r0, r2, r3, r0
     824:	f002 f906 	bl	2a34 <memcpy>
    f->wr_idx = advance_index(f->depth, wr_idx, 1);
     828:	88a0      	ldrh	r0, [r4, #4]
     82a:	2201      	movs	r2, #1
     82c:	4629      	mov	r1, r5
     82e:	f7ff fd46 	bl	2be <advance_index>
     832:	8120      	strh	r0, [r4, #8]
    ret = true;
     834:	2001      	movs	r0, #1
     836:	e7ea      	b.n	80e <tu_fifo_write+0x2a>
     838:	462b      	mov	r3, r5
     83a:	e7eb      	b.n	814 <tu_fifo_write+0x30>

0000083c <dcd_event_handler>:
{
     83c:	b5f0      	push	{r4, r5, r6, r7, lr}
  switch (event->event_id)
     83e:	7843      	ldrb	r3, [r0, #1]
     840:	3b02      	subs	r3, #2
{
     842:	b085      	sub	sp, #20
     844:	4605      	mov	r5, r0
     846:	460c      	mov	r4, r1
  switch (event->event_id)
     848:	2b03      	cmp	r3, #3
     84a:	d812      	bhi.n	872 <dcd_event_handler+0x36>
     84c:	e8df f003 	tbb	[pc, r3]
     850:	21196302 	.word	0x21196302
      _usbd_dev.connected  = 0;
     854:	4b31      	ldr	r3, [pc, #196]	; (91c <dcd_event_handler+0xe0>)
     856:	781a      	ldrb	r2, [r3, #0]
     858:	f36f 0200 	bfc	r2, #0, #1
     85c:	701a      	strb	r2, [r3, #0]
      _usbd_dev.addressed  = 0;
     85e:	781a      	ldrb	r2, [r3, #0]
      _usbd_dev.cfg_num    = 0;
     860:	2100      	movs	r1, #0
      _usbd_dev.addressed  = 0;
     862:	f36f 0241 	bfc	r2, #1, #1
     866:	701a      	strb	r2, [r3, #0]
      _usbd_dev.cfg_num    = 0;
     868:	7059      	strb	r1, [r3, #1]
      _usbd_dev.suspended  = 0;
     86a:	781a      	ldrb	r2, [r3, #0]
     86c:	f361 0282 	bfi	r2, r1, #2, #1
        _usbd_dev.suspended = 1;
     870:	701a      	strb	r2, [r3, #0]
      osal_queue_send(_usbd_q, event, in_isr);
     872:	4b2b      	ldr	r3, [pc, #172]	; (920 <dcd_event_handler+0xe4>)
     874:	681e      	ldr	r6, [r3, #0]
  return success;
}

TU_ATTR_ALWAYS_INLINE static inline bool osal_queue_send(osal_queue_t qhdl, void const * data, bool in_isr)
{
  if (!in_isr) {
     876:	b914      	cbnz	r4, 87e <dcd_event_handler+0x42>
  qhdl->interrupt_set(false);
     878:	6833      	ldr	r3, [r6, #0]
     87a:	4620      	mov	r0, r4
     87c:	4798      	blx	r3
    _osal_q_lock(qhdl);
  }

  bool success = tu_fifo_write(&qhdl->ff, data);
     87e:	4629      	mov	r1, r5
     880:	e037      	b.n	8f2 <dcd_event_handler+0xb6>
      if ( _usbd_dev.connected )
     882:	4b26      	ldr	r3, [pc, #152]	; (91c <dcd_event_handler+0xe0>)
     884:	781a      	ldrb	r2, [r3, #0]
     886:	07d6      	lsls	r6, r2, #31
     888:	d543      	bpl.n	912 <dcd_event_handler+0xd6>
        _usbd_dev.suspended = 1;
     88a:	781a      	ldrb	r2, [r3, #0]
     88c:	f042 0204 	orr.w	r2, r2, #4
     890:	e7ee      	b.n	870 <dcd_event_handler+0x34>
      if ( _usbd_dev.connected )
     892:	4a22      	ldr	r2, [pc, #136]	; (91c <dcd_event_handler+0xe0>)
     894:	7813      	ldrb	r3, [r2, #0]
     896:	07d8      	lsls	r0, r3, #31
     898:	d53b      	bpl.n	912 <dcd_event_handler+0xd6>
        _usbd_dev.suspended = 0;
     89a:	7813      	ldrb	r3, [r2, #0]
     89c:	f36f 0382 	bfc	r3, #2, #1
     8a0:	7013      	strb	r3, [r2, #0]
        osal_queue_send(_usbd_q, event, in_isr);
     8a2:	e7e6      	b.n	872 <dcd_event_handler+0x36>
        usbd_class_driver_t const * driver = get_driver(i);
     8a4:	f7ff fdb4 	bl	410 <get_driver>
        if (driver && driver->sof)
     8a8:	b120      	cbz	r0, 8b4 <dcd_event_handler+0x78>
     8aa:	6943      	ldr	r3, [r0, #20]
     8ac:	b113      	cbz	r3, 8b4 <dcd_event_handler+0x78>
          driver->sof(event->rhport, event->sof.frame_count);
     8ae:	6869      	ldr	r1, [r5, #4]
     8b0:	7828      	ldrb	r0, [r5, #0]
     8b2:	4798      	blx	r3
      for (uint8_t i = 0; i < TOTAL_DRIVER_COUNT; i++)
     8b4:	3601      	adds	r6, #1
     8b6:	783b      	ldrb	r3, [r7, #0]
     8b8:	b2f0      	uxtb	r0, r6
     8ba:	3301      	adds	r3, #1
     8bc:	4283      	cmp	r3, r0
     8be:	daf1      	bge.n	8a4 <dcd_event_handler+0x68>
      if ( _usbd_dev.suspended )
     8c0:	4a16      	ldr	r2, [pc, #88]	; (91c <dcd_event_handler+0xe0>)
     8c2:	7813      	ldrb	r3, [r2, #0]
     8c4:	0759      	lsls	r1, r3, #29
     8c6:	d524      	bpl.n	912 <dcd_event_handler+0xd6>
        _usbd_dev.suspended = 0;
     8c8:	7813      	ldrb	r3, [r2, #0]
     8ca:	f36f 0382 	bfc	r3, #2, #1
     8ce:	7013      	strb	r3, [r2, #0]
        dcd_event_t const event_resume = { .rhport = event->rhport, .event_id = DCD_EVENT_RESUME };
     8d0:	2300      	movs	r3, #0
     8d2:	e9cd 3301 	strd	r3, r3, [sp, #4]
     8d6:	9303      	str	r3, [sp, #12]
     8d8:	782b      	ldrb	r3, [r5, #0]
     8da:	f88d 3004 	strb.w	r3, [sp, #4]
     8de:	2305      	movs	r3, #5
     8e0:	f88d 3005 	strb.w	r3, [sp, #5]
        osal_queue_send(_usbd_q, &event_resume, in_isr);
     8e4:	4b0e      	ldr	r3, [pc, #56]	; (920 <dcd_event_handler+0xe4>)
     8e6:	681e      	ldr	r6, [r3, #0]
  if (!in_isr) {
     8e8:	b914      	cbnz	r4, 8f0 <dcd_event_handler+0xb4>
  qhdl->interrupt_set(false);
     8ea:	6833      	ldr	r3, [r6, #0]
     8ec:	4620      	mov	r0, r4
     8ee:	4798      	blx	r3
  bool success = tu_fifo_write(&qhdl->ff, data);
     8f0:	a901      	add	r1, sp, #4
     8f2:	1d30      	adds	r0, r6, #4
     8f4:	f7ff ff76 	bl	7e4 <tu_fifo_write>
     8f8:	4605      	mov	r5, r0

  if (!in_isr) {
     8fa:	b914      	cbnz	r4, 902 <dcd_event_handler+0xc6>
  qhdl->interrupt_set(true);
     8fc:	6833      	ldr	r3, [r6, #0]
     8fe:	2001      	movs	r0, #1
     900:	4798      	blx	r3
    _osal_q_unlock(qhdl);
  }

  TU_ASSERT(success);
     902:	b935      	cbnz	r5, 912 <dcd_event_handler+0xd6>
     904:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
     908:	f8d3 3df0 	ldr.w	r3, [r3, #3568]	; 0xdf0
     90c:	07db      	lsls	r3, r3, #31
     90e:	d500      	bpl.n	912 <dcd_event_handler+0xd6>
     910:	be00      	bkpt	0x0000
}
     912:	b005      	add	sp, #20
     914:	bdf0      	pop	{r4, r5, r6, r7, pc}
      for (uint8_t i = 0; i < TOTAL_DRIVER_COUNT; i++)
     916:	4f03      	ldr	r7, [pc, #12]	; (924 <dcd_event_handler+0xe8>)
  switch (event->event_id)
     918:	2600      	movs	r6, #0
     91a:	e7cc      	b.n	8b6 <dcd_event_handler+0x7a>
     91c:	200024a8 	.word	0x200024a8
     920:	200024dc 	.word	0x200024dc
     924:	20002020 	.word	0x20002020

00000928 <process_edpt_n.constprop.0>:
static void process_edpt_n(uint8_t rhport, uint_fast8_t ep_addr)
     928:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     92c:	b089      	sub	sp, #36	; 0x24
  const unsigned dir_in     = tu_edpt_dir(ep_addr);
     92e:	b2c3      	uxtb	r3, r0
  return regs + epnum_minus1;
     930:	4c46      	ldr	r4, [pc, #280]	; (a4c <process_edpt_n.constprop.0+0x124>)
  const unsigned dir_in     = tu_edpt_dir(ep_addr);
     932:	9302      	str	r3, [sp, #8]
  const unsigned epn_minus1 = tu_edpt_number(ep_addr) - 1;
     934:	f000 077f 	and.w	r7, r0, #127	; 0x7f
     938:	f107 38ff 	add.w	r8, r7, #4294967295	; 0xffffffff
  if (dir_in) {
     93c:	0603      	lsls	r3, r0, #24
  return (addr & TUSB_DIR_IN_MASK) ? TUSB_DIR_IN : TUSB_DIR_OUT;
     93e:	f3c0 15c0 	ubfx	r5, r0, #7, #1
  return regs + epnum_minus1;
     942:	eb04 1408 	add.w	r4, r4, r8, lsl #4
  if (dir_in) {
     946:	d529      	bpl.n	99c <process_edpt_n.constprop.0+0x74>
    if (regs->TXCSRL & USB_TXCSRL1_STALLED) {
     948:	78a3      	ldrb	r3, [r4, #2]
     94a:	069e      	lsls	r6, r3, #26
     94c:	d506      	bpl.n	95c <process_edpt_n.constprop.0+0x34>
      regs->TXCSRL &= ~(USB_TXCSRL1_STALLED | USB_TXCSRL1_UNDRN);
     94e:	78a3      	ldrb	r3, [r4, #2]
     950:	f003 03db 	and.w	r3, r3, #219	; 0xdb
     954:	70a3      	strb	r3, [r4, #2]
}
     956:	b009      	add	sp, #36	; 0x24
     958:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    completed = handle_xfer_in(ep_addr);
     95c:	f7ff fe3a 	bl	5d4 <handle_xfer_in>
  if (completed) {
     960:	2800      	cmp	r0, #0
     962:	d0f8      	beq.n	956 <process_edpt_n.constprop.0+0x2e>
                            pipe->length - pipe->remaining,
     964:	ebc5 05c5 	rsb	r5, r5, r5, lsl #3
     968:	44a8      	add	r8, r5
     96a:	4d39      	ldr	r5, [pc, #228]	; (a50 <process_edpt_n.constprop.0+0x128>)
     96c:	f108 0802 	add.w	r8, r8, #2
     970:	eb05 08c8 	add.w	r8, r5, r8, lsl #3

  event.xfer_complete.ep_addr = ep_addr;
  event.xfer_complete.len     = xferred_bytes;
  event.xfer_complete.result  = result;

  dcd_event_handler(&event, in_isr);
     974:	2101      	movs	r1, #1
     976:	f8b8 2009 	ldrh.w	r2, [r8, #9]
     97a:	f8b8 3007 	ldrh.w	r3, [r8, #7]
     97e:	1a9b      	subs	r3, r3, r2
  dcd_event_t event = { .rhport = rhport, .event_id = DCD_EVENT_XFER_COMPLETE };
     980:	2200      	movs	r2, #0
     982:	e9cd 2205 	strd	r2, r2, [sp, #20]
     986:	2207      	movs	r2, #7
     988:	f88d 2015 	strb.w	r2, [sp, #21]
  dcd_event_handler(&event, in_isr);
     98c:	a805      	add	r0, sp, #20
  event.xfer_complete.ep_addr = ep_addr;
     98e:	9a02      	ldr	r2, [sp, #8]
     990:	f88d 2018 	strb.w	r2, [sp, #24]
  event.xfer_complete.len     = xferred_bytes;
     994:	9307      	str	r3, [sp, #28]
  dcd_event_handler(&event, in_isr);
     996:	f7ff ff51 	bl	83c <dcd_event_handler>
}
     99a:	e7dc      	b.n	956 <process_edpt_n.constprop.0+0x2e>
    if (regs->RXCSRL & USB_RXCSRL1_STALLED) {
     99c:	79a3      	ldrb	r3, [r4, #6]
     99e:	f013 0f40 	tst.w	r3, #64	; 0x40
      regs->RXCSRL &= ~(USB_RXCSRL1_STALLED | USB_RXCSRL1_OVER);
     9a2:	79a3      	ldrb	r3, [r4, #6]
    if (regs->RXCSRL & USB_RXCSRL1_STALLED) {
     9a4:	d003      	beq.n	9ae <process_edpt_n.constprop.0+0x86>
      regs->RXCSRL &= ~(USB_RXCSRL1_STALLED | USB_RXCSRL1_OVER);
     9a6:	f003 03bb 	and.w	r3, r3, #187	; 0xbb
  regs->RXCSRL = 0; /* Clear RXRDY bit */
     9aa:	71a3      	strb	r3, [r4, #6]
     9ac:	e7d3      	b.n	956 <process_edpt_n.constprop.0+0x2e>
  TU_ASSERT(regs->RXCSRL & USB_RXCSRL1_RXRDY);
     9ae:	07d9      	lsls	r1, r3, #31
     9b0:	d407      	bmi.n	9c2 <process_edpt_n.constprop.0+0x9a>
     9b2:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
     9b6:	f8d3 3df0 	ldr.w	r3, [r3, #3568]	; 0xdf0
     9ba:	07da      	lsls	r2, r3, #31
     9bc:	d5cb      	bpl.n	956 <process_edpt_n.constprop.0+0x2e>
     9be:	be00      	bkpt	0x0000
     9c0:	e7c9      	b.n	956 <process_edpt_n.constprop.0+0x2e>
  const unsigned rem = pipe->remaining;
     9c2:	4e23      	ldr	r6, [pc, #140]	; (a50 <process_edpt_n.constprop.0+0x128>)
  const unsigned mps = regs->RXMAXP;
     9c4:	f8b4 a004 	ldrh.w	sl, [r4, #4]
  const unsigned vld = regs->RXCOUNT;
     9c8:	8923      	ldrh	r3, [r4, #8]
  const unsigned rem = pipe->remaining;
     9ca:	3701      	adds	r7, #1
     9cc:	eb06 07c7 	add.w	r7, r6, r7, lsl #3
  const unsigned vld = regs->RXCOUNT;
     9d0:	b29b      	uxth	r3, r3
  const unsigned mps = regs->RXMAXP;
     9d2:	fa1f fa8a 	uxth.w	sl, sl
  const unsigned rem = pipe->remaining;
     9d6:	f8b7 b009 	ldrh.w	fp, [r7, #9]
     9da:	4553      	cmp	r3, sl
     9dc:	bf28      	it	cs
     9de:	4653      	movcs	r3, sl
  const unsigned len = TU_MIN(TU_MIN(rem, mps), vld);
     9e0:	455b      	cmp	r3, fp
     9e2:	9301      	str	r3, [sp, #4]
     9e4:	bf28      	it	cs
     9e6:	465b      	movcs	r3, fp
  void          *buf = pipe->buf;
     9e8:	f8d7 0003 	ldr.w	r0, [r7, #3]
  const unsigned len = TU_MIN(TU_MIN(rem, mps), vld);
     9ec:	4699      	mov	r9, r3
  if (len) {
     9ee:	b1a3      	cbz	r3, a1a <process_edpt_n.constprop.0+0xf2>
    if (_dcd.pipe_buf_is_fifo[TUSB_DIR_OUT] & TU_BIT(epnum_minus1)) {
     9f0:	f8b6 3084 	ldrh.w	r3, [r6, #132]	; 0x84
      pipe_read_write_packet_ff(buf, &USB0->FIFO1_WORD + epnum_minus1, len, TUSB_DIR_OUT);
     9f4:	4917      	ldr	r1, [pc, #92]	; (a54 <process_edpt_n.constprop.0+0x12c>)
    if (_dcd.pipe_buf_is_fifo[TUSB_DIR_OUT] & TU_BIT(epnum_minus1)) {
     9f6:	fa23 f308 	lsr.w	r3, r3, r8
     9fa:	07db      	lsls	r3, r3, #31
      pipe_read_write_packet_ff(buf, &USB0->FIFO1_WORD + epnum_minus1, len, TUSB_DIR_OUT);
     9fc:	eb01 0188 	add.w	r1, r1, r8, lsl #2
    if (_dcd.pipe_buf_is_fifo[TUSB_DIR_OUT] & TU_BIT(epnum_minus1)) {
     a00:	d51a      	bpl.n	a38 <process_edpt_n.constprop.0+0x110>
      pipe_read_write_packet_ff(buf, &USB0->FIFO1_WORD + epnum_minus1, len, TUSB_DIR_OUT);
     a02:	462b      	mov	r3, r5
     a04:	464a      	mov	r2, r9
     a06:	9003      	str	r0, [sp, #12]
     a08:	f7ff fdae 	bl	568 <pipe_read_write_packet_ff>
     a0c:	9803      	ldr	r0, [sp, #12]
    pipe->remaining = rem - len;
     a0e:	eb06 02c8 	add.w	r2, r6, r8, lsl #3
     a12:	ebab 0309 	sub.w	r3, fp, r9
     a16:	f8a2 3019 	strh.w	r3, [r2, #25]
  if ((len < mps) || (rem == len)) {
     a1a:	45ca      	cmp	sl, r9
     a1c:	d802      	bhi.n	a24 <process_edpt_n.constprop.0+0xfc>
     a1e:	9b01      	ldr	r3, [sp, #4]
     a20:	455b      	cmp	r3, fp
     a22:	d311      	bcc.n	a48 <process_edpt_n.constprop.0+0x120>
    pipe->buf = NULL;
     a24:	f108 0302 	add.w	r3, r8, #2
     a28:	eb06 06c3 	add.w	r6, r6, r3, lsl #3
     a2c:	2300      	movs	r3, #0
     a2e:	70f3      	strb	r3, [r6, #3]
     a30:	7133      	strb	r3, [r6, #4]
     a32:	7173      	strb	r3, [r6, #5]
     a34:	71b3      	strb	r3, [r6, #6]
     a36:	e793      	b.n	960 <process_edpt_n.constprop.0+0x38>
      pipe_read_packet(buf, &USB0->FIFO1_WORD + epnum_minus1, len);
     a38:	464a      	mov	r2, r9
     a3a:	f7ff fd76 	bl	52a <pipe_read_packet>
      pipe->buf       = buf + len;
     a3e:	eb00 0309 	add.w	r3, r0, r9
     a42:	f8c7 3003 	str.w	r3, [r7, #3]
     a46:	e7e2      	b.n	a0e <process_edpt_n.constprop.0+0xe6>
  regs->RXCSRL = 0; /* Clear RXRDY bit */
     a48:	2300      	movs	r3, #0
     a4a:	e7ae      	b.n	9aa <process_edpt_n.constprop.0+0x82>
     a4c:	40050110 	.word	0x40050110
     a50:	20002160 	.word	0x20002160
     a54:	40050024 	.word	0x40050024

00000a58 <usbd_edpt_xfer.constprop.0>:
bool usbd_edpt_xfer(uint8_t rhport, uint8_t ep_addr, uint8_t * buffer, uint16_t total_bytes)
     a58:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  return (uint8_t)(addr & (~TUSB_DIR_IN_MASK));
     a5c:	f000 037f 	and.w	r3, r0, #127	; 0x7f
  TU_ASSERT(_usbd_dev.ep_status[epnum][dir].busy == 0);
     a60:	4d7c      	ldr	r5, [pc, #496]	; (c54 <usbd_edpt_xfer.constprop.0+0x1fc>)
bool usbd_edpt_xfer(uint8_t rhport, uint8_t ep_addr, uint8_t * buffer, uint16_t total_bytes)
     a62:	b089      	sub	sp, #36	; 0x24
     a64:	4617      	mov	r7, r2
  TU_ASSERT(_usbd_dev.ep_status[epnum][dir].busy == 0);
     a66:	005a      	lsls	r2, r3, #1
     a68:	9201      	str	r2, [sp, #4]
     a6a:	eb05 0243 	add.w	r2, r5, r3, lsl #1
     a6e:	eb02 12d0 	add.w	r2, r2, r0, lsr #7
     a72:	3220      	adds	r2, #32
     a74:	f892 9003 	ldrb.w	r9, [r2, #3]
     a78:	f3c9 0600 	ubfx	r6, r9, #0, #1
     a7c:	f019 0901 	ands.w	r9, r9, #1
bool usbd_edpt_xfer(uint8_t rhport, uint8_t ep_addr, uint8_t * buffer, uint16_t total_bytes)
     a80:	4686      	mov	lr, r0
     a82:	468c      	mov	ip, r1
  return (addr & TUSB_DIR_IN_MASK) ? TUSB_DIR_IN : TUSB_DIR_OUT;
     a84:	ea4f 18d0 	mov.w	r8, r0, lsr #7
  TU_ASSERT(_usbd_dev.ep_status[epnum][dir].busy == 0);
     a88:	d00d      	beq.n	aa6 <usbd_edpt_xfer.constprop.0+0x4e>
     a8a:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
     a8e:	f8d3 3df0 	ldr.w	r3, [r3, #3568]	; 0xdf0
     a92:	07d8      	lsls	r0, r3, #31
     a94:	d405      	bmi.n	aa2 <usbd_edpt_xfer.constprop.0+0x4a>
     a96:	f04f 0900 	mov.w	r9, #0
}
     a9a:	4648      	mov	r0, r9
     a9c:	b009      	add	sp, #36	; 0x24
     a9e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  TU_ASSERT(_usbd_dev.ep_status[epnum][dir].busy == 0);
     aa2:	be00      	bkpt	0x0000
     aa4:	e7f7      	b.n	a96 <usbd_edpt_xfer.constprop.0+0x3e>
  rhport = _usbd_rhport;
     aa6:	496c      	ldr	r1, [pc, #432]	; (c58 <usbd_edpt_xfer.constprop.0+0x200>)
     aa8:	f891 a000 	ldrb.w	sl, [r1]
  _usbd_dev.ep_status[epnum][dir].busy = true;
     aac:	78d1      	ldrb	r1, [r2, #3]
     aae:	f041 0101 	orr.w	r1, r1, #1
     ab2:	70d1      	strb	r1, [r2, #3]
    return((uint32_t)(((NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
     ab4:	4a69      	ldr	r2, [pc, #420]	; (c5c <usbd_edpt_xfer.constprop.0+0x204>)
     ab6:	6851      	ldr	r1, [r2, #4]
     ab8:	f3c1 3b00 	ubfx	fp, r1, #12, #1
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
     abc:	f44f 5180 	mov.w	r1, #4096	; 0x1000
     ac0:	f8c2 1084 	str.w	r1, [r2, #132]	; 0x84
  __ASM volatile ("dsb 0xF":::"memory");
     ac4:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
     ac8:	f3bf 8f6f 	isb	sy
  if (epnum) {
     acc:	b35b      	cbz	r3, b26 <usbd_edpt_xfer.constprop.0+0xce>
    _dcd.pipe_buf_is_fifo[tu_edpt_dir(ep_addr)] &= ~TU_BIT(epnum - 1);
     ace:	4a64      	ldr	r2, [pc, #400]	; (c60 <usbd_edpt_xfer.constprop.0+0x208>)
     ad0:	f108 0140 	add.w	r1, r8, #64	; 0x40
     ad4:	eb02 0141 	add.w	r1, r2, r1, lsl #1
     ad8:	3b01      	subs	r3, #1
     ada:	2401      	movs	r4, #1
     adc:	fa04 f603 	lsl.w	r6, r4, r3
     ae0:	888c      	ldrh	r4, [r1, #4]
     ae2:	ea24 0406 	bic.w	r4, r4, r6
     ae6:	808c      	strh	r4, [r1, #4]
  pipe->buf          = buffer;
     ae8:	ebc8 01c8 	rsb	r1, r8, r8, lsl #3
     aec:	4419      	add	r1, r3
     aee:	3102      	adds	r1, #2
     af0:	eb02 02c1 	add.w	r2, r2, r1, lsl #3
     af4:	f8c2 c003 	str.w	ip, [r2, #3]
  pipe->length       = total_bytes;
     af8:	f8a2 7007 	strh.w	r7, [r2, #7]
  pipe->remaining    = total_bytes;
     afc:	f8a2 7009 	strh.w	r7, [r2, #9]
  if (dir_in) {
     b00:	f1b8 0f00 	cmp.w	r8, #0
     b04:	d006      	beq.n	b14 <usbd_edpt_xfer.constprop.0+0xbc>
    handle_xfer_in(ep_addr);
     b06:	f7ff fd65 	bl	5d4 <handle_xfer_in>
  if (ie) NVIC_EnableIRQ(USB0_IRQn);
     b0a:	f1bb 0f00 	cmp.w	fp, #0
     b0e:	d01d      	beq.n	b4c <usbd_edpt_xfer.constprop.0+0xf4>
     b10:	2301      	movs	r3, #1
     b12:	e015      	b.n	b40 <usbd_edpt_xfer.constprop.0+0xe8>
  return regs + epnum_minus1;
     b14:	4a53      	ldr	r2, [pc, #332]	; (c64 <usbd_edpt_xfer.constprop.0+0x20c>)
     b16:	eb02 1303 	add.w	r3, r2, r3, lsl #4
    if (regs->RXCSRL & USB_RXCSRL1_RXRDY) regs->RXCSRL = 0;
     b1a:	799a      	ldrb	r2, [r3, #6]
     b1c:	07d1      	lsls	r1, r2, #31
     b1e:	d5f4      	bpl.n	b0a <usbd_edpt_xfer.constprop.0+0xb2>
     b20:	f883 8006 	strb.w	r8, [r3, #6]
     b24:	e7f1      	b.n	b0a <usbd_edpt_xfer.constprop.0+0xb2>
  TU_ASSERT(total_bytes <= 64); /* Current implementation supports for only up to 64 bytes. */
     b26:	2f40      	cmp	r7, #64	; 0x40
     b28:	d913      	bls.n	b52 <usbd_edpt_xfer.constprop.0+0xfa>
    TU_ASSERT(total_bytes <= _dcd.remaining_ctrl);
     b2a:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
     b2e:	f8d3 3df0 	ldr.w	r3, [r3, #3568]	; 0xdf0
     b32:	07da      	lsls	r2, r3, #31
     b34:	d500      	bpl.n	b38 <usbd_edpt_xfer.constprop.0+0xe0>
     b36:	be00      	bkpt	0x0000
  if (ie) NVIC_EnableIRQ(USB0_IRQn);
     b38:	f1bb 0f00 	cmp.w	fp, #0
     b3c:	d071      	beq.n	c22 <usbd_edpt_xfer.constprop.0+0x1ca>
     b3e:	2300      	movs	r3, #0
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
     b40:	4a46      	ldr	r2, [pc, #280]	; (c5c <usbd_edpt_xfer.constprop.0+0x204>)
     b42:	f44f 5180 	mov.w	r1, #4096	; 0x1000
     b46:	6051      	str	r1, [r2, #4]
  if ( dcd_edpt_xfer(rhport, ep_addr, buffer, total_bytes) )
     b48:	2b00      	cmp	r3, #0
     b4a:	d06a      	beq.n	c22 <usbd_edpt_xfer.constprop.0+0x1ca>
    return true;
     b4c:	f04f 0901 	mov.w	r9, #1
     b50:	e7a3      	b.n	a9a <usbd_edpt_xfer.constprop.0+0x42>
  const unsigned req = _dcd.setup_packet.bmRequestType;
     b52:	4c43      	ldr	r4, [pc, #268]	; (c60 <usbd_edpt_xfer.constprop.0+0x208>)
     b54:	7823      	ldrb	r3, [r4, #0]
  TU_ASSERT(req != REQUEST_TYPE_INVALID || total_bytes == 0);
     b56:	2bff      	cmp	r3, #255	; 0xff
     b58:	d113      	bne.n	b82 <usbd_edpt_xfer.constprop.0+0x12a>
     b5a:	2f00      	cmp	r7, #0
     b5c:	d1e5      	bne.n	b2a <usbd_edpt_xfer.constprop.0+0xd2>
    _dcd.status_out = 0;
     b5e:	2100      	movs	r1, #0
    if (req == REQUEST_TYPE_INVALID) {
     b60:	2bff      	cmp	r3, #255	; 0xff
    _dcd.status_out = 0;
     b62:	72a1      	strb	r1, [r4, #10]
    if (req == REQUEST_TYPE_INVALID) {
     b64:	d1d1      	bne.n	b0a <usbd_edpt_xfer.constprop.0+0xb2>
  dcd_event_t event = { .rhport = rhport, .event_id = DCD_EVENT_XFER_COMPLETE };
     b66:	2307      	movs	r3, #7
  dcd_event_handler(&event, in_isr);
     b68:	a805      	add	r0, sp, #20
  dcd_event_t event = { .rhport = rhport, .event_id = DCD_EVENT_XFER_COMPLETE };
     b6a:	e9cd 1105 	strd	r1, r1, [sp, #20]
      dcd_event_xfer_complete(rhport, ep_addr, total_bytes, XFER_RESULT_SUCCESS, false);
     b6e:	9707      	str	r7, [sp, #28]
     b70:	f88d a014 	strb.w	sl, [sp, #20]
     b74:	f88d 3015 	strb.w	r3, [sp, #21]
  event.xfer_complete.ep_addr = ep_addr;
     b78:	f88d e018 	strb.w	lr, [sp, #24]
  dcd_event_handler(&event, in_isr);
     b7c:	f7ff fe5e 	bl	83c <dcd_event_handler>
}
     b80:	e7c3      	b.n	b0a <usbd_edpt_xfer.constprop.0+0xb2>
  if (req == REQUEST_TYPE_INVALID || _dcd.status_out) {
     b82:	f994 200a 	ldrsb.w	r2, [r4, #10]
     b86:	2a00      	cmp	r2, #0
     b88:	d1e9      	bne.n	b5e <usbd_edpt_xfer.constprop.0+0x106>
  if (tu_edpt_dir(req) == dir_in) { /* DATA stage */
     b8a:	ebb8 1fd3 	cmp.w	r8, r3, lsr #7
     b8e:	d139      	bne.n	c04 <usbd_edpt_xfer.constprop.0+0x1ac>
    TU_ASSERT(total_bytes <= _dcd.remaining_ctrl);
     b90:	8923      	ldrh	r3, [r4, #8]
     b92:	429f      	cmp	r7, r3
     b94:	d8c9      	bhi.n	b2a <usbd_edpt_xfer.constprop.0+0xd2>
    const unsigned len = TU_MIN(TU_MIN(rem, 64), total_bytes);
     b96:	42bb      	cmp	r3, r7
     b98:	461a      	mov	r2, r3
     b9a:	bf28      	it	cs
     b9c:	463a      	movcs	r2, r7
      _dcd.pipe0.length    = len;
     b9e:	fa1f fa82 	uxth.w	sl, r2
    if (dir_in) {
     ba2:	f1b8 0f00 	cmp.w	r8, #0
     ba6:	d022      	beq.n	bee <usbd_edpt_xfer.constprop.0+0x196>
      pipe_write_packet(buffer, &USB0->FIFO0_WORD, len);
     ba8:	4660      	mov	r0, ip
     baa:	492f      	ldr	r1, [pc, #188]	; (c68 <usbd_edpt_xfer.constprop.0+0x210>)
     bac:	e9cd 2302 	strd	r2, r3, [sp, #8]
     bb0:	f7ff fc9e 	bl	4f0 <pipe_write_packet>
      _dcd.pipe0.buf       = buffer + len;
     bb4:	9a02      	ldr	r2, [sp, #8]
      _dcd.remaining_ctrl  = rem - len;
     bb6:	9b03      	ldr	r3, [sp, #12]
      _dcd.pipe0.length    = len;
     bb8:	f8a4 a00f 	strh.w	sl, [r4, #15]
      _dcd.pipe0.buf       = buffer + len;
     bbc:	4410      	add	r0, r2
      _dcd.remaining_ctrl  = rem - len;
     bbe:	eba3 0a0a 	sub.w	sl, r3, sl
      if ((len < 64) || (rem == len)) {
     bc2:	2a40      	cmp	r2, #64	; 0x40
      _dcd.pipe0.buf       = buffer + len;
     bc4:	f8c4 000b 	str.w	r0, [r4, #11]
     bc8:	4a28      	ldr	r2, [pc, #160]	; (c6c <usbd_edpt_xfer.constprop.0+0x214>)
      _dcd.pipe0.remaining = 0;
     bca:	7466      	strb	r6, [r4, #17]
     bcc:	74a6      	strb	r6, [r4, #18]
      _dcd.remaining_ctrl  = rem - len;
     bce:	f8a4 a008 	strh.w	sl, [r4, #8]
      if ((len < 64) || (rem == len)) {
     bd2:	d101      	bne.n	bd8 <usbd_edpt_xfer.constprop.0+0x180>
     bd4:	42bb      	cmp	r3, r7
     bd6:	d808      	bhi.n	bea <usbd_edpt_xfer.constprop.0+0x192>
        _dcd.setup_packet.bmRequestType = REQUEST_TYPE_INVALID; /* Change to STATUS/SETUP stage */
     bd8:	4b21      	ldr	r3, [pc, #132]	; (c60 <usbd_edpt_xfer.constprop.0+0x208>)
     bda:	21ff      	movs	r1, #255	; 0xff
     bdc:	7019      	strb	r1, [r3, #0]
        _dcd.status_out = 1;
     bde:	2101      	movs	r1, #1
     be0:	7299      	strb	r1, [r3, #10]
        USB0->CSRL0 = USB_CSRL0_TXRDY | USB_CSRL0_DATAEND;
     be2:	230a      	movs	r3, #10
        USB0->CSRL0 = USB_CSRL0_TXRDY; /* Flush TX FIFO to return ACK. */
     be4:	f882 3102 	strb.w	r3, [r2, #258]	; 0x102
     be8:	e78f      	b.n	b0a <usbd_edpt_xfer.constprop.0+0xb2>
     bea:	2302      	movs	r3, #2
     bec:	e7fa      	b.n	be4 <usbd_edpt_xfer.constprop.0+0x18c>
      USB0->CSRL0 = USB_CSRL0_RXRDYC; /* Clear RX FIFO to return ACK. */
     bee:	4b1f      	ldr	r3, [pc, #124]	; (c6c <usbd_edpt_xfer.constprop.0+0x214>)
      _dcd.pipe0.buf       = buffer;
     bf0:	f8c4 c00b 	str.w	ip, [r4, #11]
      _dcd.pipe0.length    = len;
     bf4:	f8a4 a00f 	strh.w	sl, [r4, #15]
      _dcd.pipe0.remaining = len;
     bf8:	f8a4 a011 	strh.w	sl, [r4, #17]
      USB0->CSRL0 = USB_CSRL0_RXRDYC; /* Clear RX FIFO to return ACK. */
     bfc:	2240      	movs	r2, #64	; 0x40
    USB0->CSRL0 = USB_CSRL0_RXRDYC | USB_CSRL0_DATAEND;
     bfe:	f883 2102 	strb.w	r2, [r3, #258]	; 0x102
     c02:	e782      	b.n	b0a <usbd_edpt_xfer.constprop.0+0xb2>
  } else if (dir_in) {
     c04:	f1b8 0f00 	cmp.w	r8, #0
     c08:	f43f af7f 	beq.w	b0a <usbd_edpt_xfer.constprop.0+0xb2>
    USB0->CSRL0 = USB_CSRL0_RXRDYC | USB_CSRL0_DATAEND;
     c0c:	4b17      	ldr	r3, [pc, #92]	; (c6c <usbd_edpt_xfer.constprop.0+0x214>)
    _dcd.pipe0.buf = NULL;
     c0e:	72e6      	strb	r6, [r4, #11]
     c10:	7326      	strb	r6, [r4, #12]
     c12:	7366      	strb	r6, [r4, #13]
     c14:	73a6      	strb	r6, [r4, #14]
    _dcd.pipe0.length    = 0;
     c16:	73e6      	strb	r6, [r4, #15]
     c18:	7426      	strb	r6, [r4, #16]
    _dcd.pipe0.remaining = 0;
     c1a:	7466      	strb	r6, [r4, #17]
     c1c:	74a6      	strb	r6, [r4, #18]
    USB0->CSRL0 = USB_CSRL0_RXRDYC | USB_CSRL0_DATAEND;
     c1e:	2248      	movs	r2, #72	; 0x48
     c20:	e7ed      	b.n	bfe <usbd_edpt_xfer.constprop.0+0x1a6>
    _usbd_dev.ep_status[epnum][dir].busy = false;
     c22:	9b01      	ldr	r3, [sp, #4]
     c24:	441d      	add	r5, r3
     c26:	44a8      	add	r8, r5
     c28:	f898 3023 	ldrb.w	r3, [r8, #35]	; 0x23
     c2c:	f36f 0300 	bfc	r3, #0, #1
     c30:	f888 3023 	strb.w	r3, [r8, #35]	; 0x23
    _usbd_dev.ep_status[epnum][dir].claimed = 0;
     c34:	f898 3023 	ldrb.w	r3, [r8, #35]	; 0x23
     c38:	f36f 0382 	bfc	r3, #2, #1
     c3c:	f888 3023 	strb.w	r3, [r8, #35]	; 0x23
    TU_BREAKPOINT();
     c40:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
     c44:	f8d3 3df0 	ldr.w	r3, [r3, #3568]	; 0xdf0
     c48:	07db      	lsls	r3, r3, #31
     c4a:	f57f af24 	bpl.w	a96 <usbd_edpt_xfer.constprop.0+0x3e>
     c4e:	be00      	bkpt	0x0000
     c50:	e723      	b.n	a9a <usbd_edpt_xfer.constprop.0+0x42>
     c52:	bf00      	nop
     c54:	200024a8 	.word	0x200024a8
     c58:	20000014 	.word	0x20000014
     c5c:	e000e100 	.word	0xe000e100
     c60:	20002160 	.word	0x20002160
     c64:	40050110 	.word	0x40050110
     c68:	40050020 	.word	0x40050020
     c6c:	40050000 	.word	0x40050000

00000c70 <proc_write10_cmd.constprop.0.isra.0>:
  {
    TU_ASSERT( usbd_edpt_xfer(rhport, p_msc->ep_in, _mscd_buf, (uint16_t) nbytes), );
  }
}

static void proc_write10_cmd(uint8_t rhport, mscd_interface_t* p_msc)
     c70:	b508      	push	{r3, lr}
    fail_scsi_op(rhport, p_msc, MSC_CSW_STATUS_FAILED);
    return;
  }

  // remaining bytes capped at class buffer
  uint16_t nbytes = (uint16_t) tu_min32(sizeof(_mscd_buf), p_cbw->total_bytes-p_msc->xferred_len);
     c72:	4b0c      	ldr	r3, [pc, #48]	; (ca4 <proc_write10_cmd.constprop.0.isra.0+0x34>)
     c74:	6b99      	ldr	r1, [r3, #56]	; 0x38
     c76:	689a      	ldr	r2, [r3, #8]

  // Write10 callback will be called later when usb transfer complete
  TU_ASSERT( usbd_edpt_xfer(rhport, p_msc->ep_out, _mscd_buf, nbytes), );
     c78:	f893 002f 	ldrb.w	r0, [r3, #47]	; 0x2f
  uint16_t nbytes = (uint16_t) tu_min32(sizeof(_mscd_buf), p_cbw->total_bytes-p_msc->xferred_len);
     c7c:	1a52      	subs	r2, r2, r1
TU_ATTR_ALWAYS_INLINE static inline bool     tu_bit_test (uint32_t value, uint8_t pos) { return (value & TU_BIT(pos)) ? true : false; }

//------------- Min -------------//
TU_ATTR_ALWAYS_INLINE static inline uint8_t  tu_min8  (uint8_t  x, uint8_t y ) { return (x < y) ? x : y; }
TU_ATTR_ALWAYS_INLINE static inline uint16_t tu_min16 (uint16_t x, uint16_t y) { return (x < y) ? x : y; }
TU_ATTR_ALWAYS_INLINE static inline uint32_t tu_min32 (uint32_t x, uint32_t y) { return (x < y) ? x : y; }
     c7e:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
     c82:	bf28      	it	cs
     c84:	f44f 7200 	movcs.w	r2, #512	; 0x200
  TU_ASSERT( usbd_edpt_xfer(rhport, p_msc->ep_out, _mscd_buf, nbytes), );
     c88:	4907      	ldr	r1, [pc, #28]	; (ca8 <proc_write10_cmd.constprop.0.isra.0+0x38>)
     c8a:	b292      	uxth	r2, r2
     c8c:	f7ff fee4 	bl	a58 <usbd_edpt_xfer.constprop.0>
     c90:	b930      	cbnz	r0, ca0 <proc_write10_cmd.constprop.0.isra.0+0x30>
     c92:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
     c96:	f8d3 3df0 	ldr.w	r3, [r3, #3568]	; 0xdf0
     c9a:	07db      	lsls	r3, r3, #31
     c9c:	d500      	bpl.n	ca0 <proc_write10_cmd.constprop.0.isra.0+0x30>
     c9e:	be00      	bkpt	0x0000
}
     ca0:	bd08      	pop	{r3, pc}
     ca2:	bf00      	nop
     ca4:	20002428 	.word	0x20002428
     ca8:	20002228 	.word	0x20002228

00000cac <_prep_out_transaction.isra.0>:
//--------------------------------------------------------------------+
// INTERNAL OBJECT & FUNCTION DECLARATION
//--------------------------------------------------------------------+
CFG_TUSB_MEM_SECTION tu_static cdcd_interface_t _cdcd_itf[CFG_TUD_CDC];

static bool _prep_out_transaction (cdcd_interface_t* p_cdc)
     cac:	b538      	push	{r3, r4, r5, lr}
{
  uint8_t const rhport = 0;
  uint16_t available = tu_fifo_remaining(&p_cdc->rx_ff);
     cae:	f100 0510 	add.w	r5, r0, #16
static bool _prep_out_transaction (cdcd_interface_t* p_cdc)
     cb2:	4604      	mov	r4, r0
  uint16_t available = tu_fifo_remaining(&p_cdc->rx_ff);
     cb4:	4628      	mov	r0, r5
     cb6:	f7ff fb1e 	bl	2f6 <tu_fifo_remaining>

  // Prepare for incoming data but only allow what we can store in the ring buffer.
  // TODO Actually we can still carry out the transfer, keeping count of received bytes
  // and slowly move it to the FIFO when read().
  // This pre-check reduces endpoint claiming
  TU_VERIFY(available >= sizeof(p_cdc->epout_buf));
     cba:	283f      	cmp	r0, #63	; 0x3f
     cbc:	d914      	bls.n	ce8 <_prep_out_transaction.isra.0+0x3c>

  // claim endpoint
  TU_VERIFY(usbd_edpt_claim(rhport, p_cdc->ep_out));
     cbe:	78e0      	ldrb	r0, [r4, #3]
     cc0:	f7ff fd30 	bl	724 <usbd_edpt_claim.constprop.0>
     cc4:	b180      	cbz	r0, ce8 <_prep_out_transaction.isra.0+0x3c>

  // fifo can be changed before endpoint is claimed
  available = tu_fifo_remaining(&p_cdc->rx_ff);
     cc6:	4628      	mov	r0, r5
     cc8:	f7ff fb15 	bl	2f6 <tu_fifo_remaining>

  if ( available >= sizeof(p_cdc->epout_buf) )
     ccc:	283f      	cmp	r0, #63	; 0x3f
     cce:	78e0      	ldrb	r0, [r4, #3]
     cd0:	d906      	bls.n	ce0 <_prep_out_transaction.isra.0+0x34>
  {
    return usbd_edpt_xfer(rhport, p_cdc->ep_out, p_cdc->epout_buf, sizeof(p_cdc->epout_buf));
     cd2:	f104 01a8 	add.w	r1, r4, #168	; 0xa8
     cd6:	2240      	movs	r2, #64	; 0x40
    // Release endpoint since we don't make any transfer
    usbd_edpt_release(rhport, p_cdc->ep_out);

    return false;
  }
}
     cd8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    return usbd_edpt_xfer(rhport, p_cdc->ep_out, p_cdc->epout_buf, sizeof(p_cdc->epout_buf));
     cdc:	f7ff bebc 	b.w	a58 <usbd_edpt_xfer.constprop.0>
}
     ce0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    usbd_edpt_release(rhport, p_cdc->ep_out);
     ce4:	f7ff bd42 	b.w	76c <usbd_edpt_release.constprop.0.isra.0>
}
     ce8:	bd38      	pop	{r3, r4, r5, pc}

00000cea <_status_stage_xact.isra.0>:
  uint8_t const ep_addr = request->bmRequestType_bit.direction ? EDPT_CTRL_OUT : EDPT_CTRL_IN;
     cea:	f010 0f80 	tst.w	r0, #128	; 0x80
  return usbd_edpt_xfer(rhport, ep_addr, NULL, 0);
     cee:	f04f 0200 	mov.w	r2, #0
     cf2:	4611      	mov	r1, r2
     cf4:	bf0c      	ite	eq
     cf6:	2080      	moveq	r0, #128	; 0x80
     cf8:	4610      	movne	r0, r2
     cfa:	f7ff bead 	b.w	a58 <usbd_edpt_xfer.constprop.0>
	...

00000d00 <tud_control_status.isra.0>:
bool tud_control_status(uint8_t rhport, tusb_control_request_t const * request)
     d00:	b410      	push	{r4}
     d02:	4603      	mov	r3, r0
  _ctrl_xfer.request       = (*request);
     d04:	4c06      	ldr	r4, [pc, #24]	; (d20 <tud_control_status.isra.0+0x20>)
     d06:	6800      	ldr	r0, [r0, #0]
     d08:	6859      	ldr	r1, [r3, #4]
     d0a:	4622      	mov	r2, r4
     d0c:	c203      	stmia	r2!, {r0, r1}
  _ctrl_xfer.buffer        = NULL;
     d0e:	2200      	movs	r2, #0
  _ctrl_xfer.data_len      = 0;
     d10:	e9c4 2202 	strd	r2, r2, [r4, #8]
}
     d14:	f85d 4b04 	ldr.w	r4, [sp], #4
  return _status_stage_xact(rhport, request);
     d18:	7818      	ldrb	r0, [r3, #0]
     d1a:	f7ff bfe6 	b.w	cea <_status_stage_xact.isra.0>
     d1e:	bf00      	nop
     d20:	2000214c 	.word	0x2000214c

00000d24 <_data_stage_xact.isra.0>:
static bool _data_stage_xact(uint8_t rhport)
     d24:	b513      	push	{r0, r1, r4, lr}
  uint16_t const xact_len = tu_min16(_ctrl_xfer.data_len - _ctrl_xfer.total_xferred, CFG_TUD_ENDPOINT0_SIZE);
     d26:	4b12      	ldr	r3, [pc, #72]	; (d70 <_data_stage_xact.isra.0+0x4c>)
     d28:	8998      	ldrh	r0, [r3, #12]
     d2a:	89d9      	ldrh	r1, [r3, #14]
  if ( _ctrl_xfer.request.bmRequestType_bit.direction == TUSB_DIR_IN )
     d2c:	f993 4000 	ldrsb.w	r4, [r3]
  uint16_t const xact_len = tu_min16(_ctrl_xfer.data_len - _ctrl_xfer.total_xferred, CFG_TUD_ENDPOINT0_SIZE);
     d30:	1a42      	subs	r2, r0, r1
TU_ATTR_ALWAYS_INLINE static inline uint16_t tu_min16 (uint16_t x, uint16_t y) { return (x < y) ? x : y; }
     d32:	b292      	uxth	r2, r2
     d34:	2a40      	cmp	r2, #64	; 0x40
     d36:	bf28      	it	cs
     d38:	2240      	movcs	r2, #64	; 0x40
  if ( _ctrl_xfer.request.bmRequestType_bit.direction == TUSB_DIR_IN )
     d3a:	2c00      	cmp	r4, #0
     d3c:	da0e      	bge.n	d5c <_data_stage_xact.isra.0+0x38>
    if ( xact_len ) {
     d3e:	4288      	cmp	r0, r1
     d40:	d012      	beq.n	d68 <_data_stage_xact.isra.0+0x44>
  memcpy(dest, src, count);
     d42:	6899      	ldr	r1, [r3, #8]
     d44:	480b      	ldr	r0, [pc, #44]	; (d74 <_data_stage_xact.isra.0+0x50>)
     d46:	9201      	str	r2, [sp, #4]
     d48:	f001 fe74 	bl	2a34 <memcpy>
  return usbd_edpt_xfer(rhport, ep_addr, xact_len ? _usbd_ctrl_buf : NULL, xact_len);
     d4c:	4909      	ldr	r1, [pc, #36]	; (d74 <_data_stage_xact.isra.0+0x50>)
     d4e:	9a01      	ldr	r2, [sp, #4]
    ep_addr = EDPT_CTRL_IN;
     d50:	2080      	movs	r0, #128	; 0x80
}
     d52:	b002      	add	sp, #8
     d54:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  return usbd_edpt_xfer(rhport, ep_addr, xact_len ? _usbd_ctrl_buf : NULL, xact_len);
     d58:	f7ff be7e 	b.w	a58 <usbd_edpt_xfer.constprop.0>
     d5c:	4288      	cmp	r0, r1
  uint8_t ep_addr = EDPT_CTRL_OUT;
     d5e:	f04f 0000 	mov.w	r0, #0
  return usbd_edpt_xfer(rhport, ep_addr, xact_len ? _usbd_ctrl_buf : NULL, xact_len);
     d62:	d103      	bne.n	d6c <_data_stage_xact.isra.0+0x48>
     d64:	2100      	movs	r1, #0
     d66:	e7f4      	b.n	d52 <_data_stage_xact.isra.0+0x2e>
    ep_addr = EDPT_CTRL_IN;
     d68:	2080      	movs	r0, #128	; 0x80
     d6a:	e7fb      	b.n	d64 <_data_stage_xact.isra.0+0x40>
  return usbd_edpt_xfer(rhport, ep_addr, xact_len ? _usbd_ctrl_buf : NULL, xact_len);
     d6c:	4901      	ldr	r1, [pc, #4]	; (d74 <_data_stage_xact.isra.0+0x50>)
     d6e:	e7f0      	b.n	d52 <_data_stage_xact.isra.0+0x2e>
     d70:	2000214c 	.word	0x2000214c
     d74:	20002468 	.word	0x20002468

00000d78 <tud_control_xfer.isra.0>:
bool tud_control_xfer(uint8_t rhport, tusb_control_request_t const * request, void* buffer, uint16_t len)
     d78:	b570      	push	{r4, r5, r6, lr}
     d7a:	4604      	mov	r4, r0
  _ctrl_xfer.request       = (*request);
     d7c:	4d16      	ldr	r5, [pc, #88]	; (dd8 <tud_control_xfer.isra.0+0x60>)
     d7e:	6800      	ldr	r0, [r0, #0]
bool tud_control_xfer(uint8_t rhport, tusb_control_request_t const * request, void* buffer, uint16_t len)
     d80:	460b      	mov	r3, r1
  _ctrl_xfer.request       = (*request);
     d82:	6861      	ldr	r1, [r4, #4]
  _ctrl_xfer.buffer        = (uint8_t*) buffer;
     d84:	60ab      	str	r3, [r5, #8]
  _ctrl_xfer.request       = (*request);
     d86:	462e      	mov	r6, r5
     d88:	c603      	stmia	r6!, {r0, r1}
  _ctrl_xfer.total_xferred = 0U;
     d8a:	2100      	movs	r1, #0
     d8c:	81e9      	strh	r1, [r5, #14]
TU_ATTR_ALWAYS_INLINE static inline uint16_t tu_min16 (uint16_t x, uint16_t y) { return (x < y) ? x : y; }
     d8e:	88e1      	ldrh	r1, [r4, #6]
     d90:	428a      	cmp	r2, r1
     d92:	bf28      	it	cs
     d94:	460a      	movcs	r2, r1
  _ctrl_xfer.data_len      = tu_min16(len, request->wLength);
     d96:	81aa      	strh	r2, [r5, #12]
  if (request->wLength > 0U)
     d98:	88e1      	ldrh	r1, [r4, #6]
     d9a:	b181      	cbz	r1, dbe <tud_control_xfer.isra.0+0x46>
    if(_ctrl_xfer.data_len > 0U)
     d9c:	b152      	cbz	r2, db4 <tud_control_xfer.isra.0+0x3c>
      TU_ASSERT(buffer);
     d9e:	b94b      	cbnz	r3, db4 <tud_control_xfer.isra.0+0x3c>
     da0:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
     da4:	f8d2 2df0 	ldr.w	r2, [r2, #3568]	; 0xdf0
     da8:	07d2      	lsls	r2, r2, #31
     daa:	d401      	bmi.n	db0 <tud_control_xfer.isra.0+0x38>
     dac:	2000      	movs	r0, #0
}
     dae:	bd70      	pop	{r4, r5, r6, pc}
      TU_ASSERT(buffer);
     db0:	be00      	bkpt	0x0000
     db2:	e7fb      	b.n	dac <tud_control_xfer.isra.0+0x34>
    TU_ASSERT( _data_stage_xact(rhport) );
     db4:	f7ff ffb6 	bl	d24 <_data_stage_xact.isra.0>
     db8:	b128      	cbz	r0, dc6 <tud_control_xfer.isra.0+0x4e>
  return true;
     dba:	2001      	movs	r0, #1
     dbc:	e7f7      	b.n	dae <tud_control_xfer.isra.0+0x36>
    TU_ASSERT( _status_stage_xact(rhport, request) );
     dbe:	7820      	ldrb	r0, [r4, #0]
     dc0:	f7ff ff93 	bl	cea <_status_stage_xact.isra.0>
     dc4:	e7f8      	b.n	db8 <tud_control_xfer.isra.0+0x40>
     dc6:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
     dca:	f8d3 3df0 	ldr.w	r3, [r3, #3568]	; 0xdf0
     dce:	07db      	lsls	r3, r3, #31
     dd0:	d5ec      	bpl.n	dac <tud_control_xfer.isra.0+0x34>
     dd2:	be00      	bkpt	0x0000
     dd4:	e7eb      	b.n	dae <tud_control_xfer.isra.0+0x36>
     dd6:	bf00      	nop
     dd8:	2000214c 	.word	0x2000214c

00000ddc <cdcd_control_xfer_cb>:

// Invoked when a control transfer occurred on an interface of this class
// Driver response accordingly to the request and the transfer stage (setup/data/ack)
// return false to stall control endpoint (e.g unsupported request)
bool cdcd_control_xfer_cb(uint8_t rhport, uint8_t stage, tusb_control_request_t const * request)
{
     ddc:	b510      	push	{r4, lr}
  // Handle class request only
  TU_VERIFY(request->bmRequestType_bit.type == TUSB_REQ_TYPE_CLASS);
     dde:	7813      	ldrb	r3, [r2, #0]
     de0:	f003 0360 	and.w	r3, r3, #96	; 0x60
     de4:	2b20      	cmp	r3, #32
{
     de6:	4610      	mov	r0, r2
  TU_VERIFY(request->bmRequestType_bit.type == TUSB_REQ_TYPE_CLASS);
     de8:	d141      	bne.n	e6e <cdcd_control_xfer_cb+0x92>
  // Identify which interface to use
  for ( ; ; itf++, p_cdc++)
  {
    if (itf >= TU_ARRAY_SIZE(_cdcd_itf)) return false;

    if ( p_cdc->itf_num == request->wIndex ) break;
     dea:	4a22      	ldr	r2, [pc, #136]	; (e74 <cdcd_control_xfer_cb+0x98>)
     dec:	8883      	ldrh	r3, [r0, #4]
     dee:	7814      	ldrb	r4, [r2, #0]
     df0:	429c      	cmp	r4, r3
     df2:	d13c      	bne.n	e6e <cdcd_control_xfer_cb+0x92>
  }

  switch ( request->bRequest )
     df4:	7843      	ldrb	r3, [r0, #1]
     df6:	3b20      	subs	r3, #32
     df8:	2b03      	cmp	r3, #3
     dfa:	d838      	bhi.n	e6e <cdcd_control_xfer_cb+0x92>
     dfc:	e8df f003 	tbb	[pc, r3]
     e00:	2b171402 	.word	0x2b171402
  {
    case CDC_REQUEST_SET_LINE_CODING:
      if (stage == CONTROL_STAGE_SETUP)
     e04:	2901      	cmp	r1, #1
     e06:	d105      	bne.n	e14 <cdcd_control_xfer_cb+0x38>
      {
        TU_LOG2("  Set Line Coding\r\n");
        tud_control_xfer(rhport, request, &p_cdc->line_coding, sizeof(cdc_line_coding_t));
     e08:	491b      	ldr	r1, [pc, #108]	; (e78 <cdcd_control_xfer_cb+0x9c>)
     e0a:	2207      	movs	r2, #7
     e0c:	f7ff ffb4 	bl	d78 <tud_control_xfer.isra.0>
    break;

    default: return false; // stall unsupported request
  }

  return true;
     e10:	2001      	movs	r0, #1
     e12:	e02d      	b.n	e70 <cdcd_control_xfer_cb+0x94>
      else if ( stage == CONTROL_STAGE_ACK)
     e14:	2903      	cmp	r1, #3
     e16:	d1fb      	bne.n	e10 <cdcd_control_xfer_cb+0x34>
        if ( tud_cdc_line_coding_cb ) tud_cdc_line_coding_cb(itf, &p_cdc->line_coding);
     e18:	4b18      	ldr	r3, [pc, #96]	; (e7c <cdcd_control_xfer_cb+0xa0>)
     e1a:	2b00      	cmp	r3, #0
     e1c:	d0f8      	beq.n	e10 <cdcd_control_xfer_cb+0x34>
     e1e:	4916      	ldr	r1, [pc, #88]	; (e78 <cdcd_control_xfer_cb+0x9c>)
     e20:	2000      	movs	r0, #0
     e22:	f3af 8000 	nop.w
     e26:	e7f3      	b.n	e10 <cdcd_control_xfer_cb+0x34>
      if (stage == CONTROL_STAGE_SETUP)
     e28:	2901      	cmp	r1, #1
     e2a:	d1f1      	bne.n	e10 <cdcd_control_xfer_cb+0x34>
     e2c:	e7ec      	b.n	e08 <cdcd_control_xfer_cb+0x2c>
      if (stage == CONTROL_STAGE_SETUP)
     e2e:	2901      	cmp	r1, #1
     e30:	d102      	bne.n	e38 <cdcd_control_xfer_cb+0x5c>
        tud_control_status(rhport, request);
     e32:	f7ff ff65 	bl	d00 <tud_control_status.isra.0>
     e36:	e7eb      	b.n	e10 <cdcd_control_xfer_cb+0x34>
      else if (stage == CONTROL_STAGE_ACK)
     e38:	2903      	cmp	r1, #3
     e3a:	d1e9      	bne.n	e10 <cdcd_control_xfer_cb+0x34>
        bool const dtr = tu_bit_test(request->wValue, 0);
     e3c:	8843      	ldrh	r3, [r0, #2]
  f->overwritable = overwritable;
     e3e:	f892 1023 	ldrb.w	r1, [r2, #35]	; 0x23
        p_cdc->line_state = (uint8_t) request->wValue;
     e42:	7113      	strb	r3, [r2, #4]
TU_ATTR_ALWAYS_INLINE static inline bool     tu_bit_test (uint32_t value, uint8_t pos) { return (value & TU_BIT(pos)) ? true : false; }
     e44:	f003 0301 	and.w	r3, r3, #1
        tu_fifo_set_overwritable(&p_cdc->tx_ff, !dtr);
     e48:	f083 0301 	eor.w	r3, r3, #1
     e4c:	f363 11c7 	bfi	r1, r3, #7, #1
     e50:	f882 1023 	strb.w	r1, [r2, #35]	; 0x23
     e54:	e7dc      	b.n	e10 <cdcd_control_xfer_cb+0x34>
      if (stage == CONTROL_STAGE_SETUP)
     e56:	2901      	cmp	r1, #1
     e58:	d0eb      	beq.n	e32 <cdcd_control_xfer_cb+0x56>
      else if (stage == CONTROL_STAGE_ACK)
     e5a:	2903      	cmp	r1, #3
     e5c:	d1d8      	bne.n	e10 <cdcd_control_xfer_cb+0x34>
        if ( tud_cdc_send_break_cb ) tud_cdc_send_break_cb(itf, request->wValue);
     e5e:	4b08      	ldr	r3, [pc, #32]	; (e80 <cdcd_control_xfer_cb+0xa4>)
     e60:	2b00      	cmp	r3, #0
     e62:	d0d5      	beq.n	e10 <cdcd_control_xfer_cb+0x34>
     e64:	8841      	ldrh	r1, [r0, #2]
     e66:	2000      	movs	r0, #0
     e68:	f3af 8000 	nop.w
     e6c:	e7d0      	b.n	e10 <cdcd_control_xfer_cb+0x34>
  switch ( request->bRequest )
     e6e:	2000      	movs	r0, #0
}
     e70:	bd10      	pop	{r4, pc}
     e72:	bf00      	nop
     e74:	20002024 	.word	0x20002024
     e78:	2000202a 	.word	0x2000202a
	...

00000e84 <mscd_control_xfer_cb>:
  if (stage != CONTROL_STAGE_SETUP) return true;
     e84:	2901      	cmp	r1, #1
{
     e86:	b537      	push	{r0, r1, r2, r4, r5, lr}
     e88:	4615      	mov	r5, r2
  if (stage != CONTROL_STAGE_SETUP) return true;
     e8a:	d113      	bne.n	eb4 <mscd_control_xfer_cb+0x30>
  if ( TUSB_REQ_TYPE_STANDARD     == request->bmRequestType_bit.type      &&
     e8c:	7813      	ldrb	r3, [r2, #0]
     e8e:	f003 027f 	and.w	r2, r3, #127	; 0x7f
     e92:	2a02      	cmp	r2, #2
     e94:	d144      	bne.n	f20 <mscd_control_xfer_cb+0x9c>
       TUSB_REQ_RCPT_ENDPOINT     == request->bmRequestType_bit.recipient &&
     e96:	786c      	ldrb	r4, [r5, #1]
     e98:	2c01      	cmp	r4, #1
     e9a:	d141      	bne.n	f20 <mscd_control_xfer_cb+0x9c>
       TUSB_REQ_CLEAR_FEATURE     == request->bRequest                    &&
     e9c:	886a      	ldrh	r2, [r5, #2]
     e9e:	2a00      	cmp	r2, #0
     ea0:	d13e      	bne.n	f20 <mscd_control_xfer_cb+0x9c>
    if ( p_msc->stage == MSC_STAGE_NEED_RESET )
     ea2:	493a      	ldr	r1, [pc, #232]	; (f8c <mscd_control_xfer_cb+0x108>)
    uint8_t const ep_addr = tu_u16_low(request->wIndex);
     ea4:	88a8      	ldrh	r0, [r5, #4]
    if ( p_msc->stage == MSC_STAGE_NEED_RESET )
     ea6:	f891 3030 	ldrb.w	r3, [r1, #48]	; 0x30
     eaa:	2b04      	cmp	r3, #4
TU_ATTR_ALWAYS_INLINE static inline uint8_t tu_u16_low (uint16_t ui16) { return TU_U16_LOW(ui16); }
     eac:	b2c0      	uxtb	r0, r0
     eae:	d103      	bne.n	eb8 <mscd_control_xfer_cb+0x34>
      usbd_edpt_stall(rhport, ep_addr);
     eb0:	f7ff fc1e 	bl	6f0 <usbd_edpt_stall.constprop.0>
  return true;
     eb4:	2001      	movs	r0, #1
    break;
     eb6:	e019      	b.n	eec <mscd_control_xfer_cb+0x68>
      if ( ep_addr == p_msc->ep_in )
     eb8:	f891 202e 	ldrb.w	r2, [r1, #46]	; 0x2e
     ebc:	4290      	cmp	r0, r2
     ebe:	d117      	bne.n	ef0 <mscd_control_xfer_cb+0x6c>
        if ( p_msc->stage == MSC_STAGE_STATUS )
     ec0:	2b02      	cmp	r3, #2
     ec2:	d1f7      	bne.n	eb4 <mscd_control_xfer_cb+0x30>
  p_msc->csw.data_residue = p_msc->cbw.total_bytes - p_msc->xferred_len;
     ec4:	6b8a      	ldr	r2, [r1, #56]	; 0x38
     ec6:	688b      	ldr	r3, [r1, #8]
     ec8:	1a9b      	subs	r3, r3, r2
     eca:	628b      	str	r3, [r1, #40]	; 0x28
  p_msc->stage = MSC_STAGE_STATUS_SENT;
     ecc:	2303      	movs	r3, #3
     ece:	f881 3030 	strb.w	r3, [r1, #48]	; 0x30
  return usbd_edpt_xfer(rhport, p_msc->ep_in , (uint8_t*) &p_msc->csw, sizeof(msc_csw_t));
     ed2:	220d      	movs	r2, #13
     ed4:	3120      	adds	r1, #32
  return usbd_edpt_xfer(rhport, p_msc->ep_out, (uint8_t*) &p_msc->cbw, sizeof(msc_cbw_t));
     ed6:	f7ff fdbf 	bl	a58 <usbd_edpt_xfer.constprop.0>
            TU_ASSERT( prepare_cbw(rhport, p_msc) );
     eda:	2800      	cmp	r0, #0
     edc:	d1ea      	bne.n	eb4 <mscd_control_xfer_cb+0x30>
     ede:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
     ee2:	f8d3 3df0 	ldr.w	r3, [r3, #3568]	; 0xdf0
     ee6:	07db      	lsls	r3, r3, #31
     ee8:	d54e      	bpl.n	f88 <mscd_control_xfer_cb+0x104>
     eea:	be00      	bkpt	0x0000
}
     eec:	b003      	add	sp, #12
     eee:	bd30      	pop	{r4, r5, pc}
      else if ( ep_addr == p_msc->ep_out )
     ef0:	f891 402f 	ldrb.w	r4, [r1, #47]	; 0x2f
     ef4:	42a0      	cmp	r0, r4
     ef6:	d1dd      	bne.n	eb4 <mscd_control_xfer_cb+0x30>
        if ( p_msc->stage == MSC_STAGE_CMD )
     ef8:	2b00      	cmp	r3, #0
     efa:	d1db      	bne.n	eb4 <mscd_control_xfer_cb+0x30>
  return _usbd_dev.ep_status[epnum][dir].busy;
     efc:	4a24      	ldr	r2, [pc, #144]	; (f90 <mscd_control_xfer_cb+0x10c>)
     efe:	f004 037f 	and.w	r3, r4, #127	; 0x7f
     f02:	eb02 0343 	add.w	r3, r2, r3, lsl #1
     f06:	eb03 13d4 	add.w	r3, r3, r4, lsr #7
     f0a:	3320      	adds	r3, #32
     f0c:	78da      	ldrb	r2, [r3, #3]

// Check if endpoint is ready (not busy and not stalled)
TU_ATTR_ALWAYS_INLINE static inline
bool usbd_edpt_ready(uint8_t rhport, uint8_t ep_addr)
{
  return !usbd_edpt_busy(rhport, ep_addr) && !usbd_edpt_stalled(rhport, ep_addr);
     f0e:	07d1      	lsls	r1, r2, #31
     f10:	d4d0      	bmi.n	eb4 <mscd_control_xfer_cb+0x30>
  (void) rhport;

  uint8_t const epnum = tu_edpt_number(ep_addr);
  uint8_t const dir   = tu_edpt_dir(ep_addr);

  return _usbd_dev.ep_status[epnum][dir].stalled;
     f12:	78db      	ldrb	r3, [r3, #3]
          if ( usbd_edpt_ready(rhport, p_msc->ep_out) )
     f14:	079a      	lsls	r2, r3, #30
     f16:	d4cd      	bmi.n	eb4 <mscd_control_xfer_cb+0x30>
  return usbd_edpt_xfer(rhport, p_msc->ep_out, (uint8_t*) &p_msc->cbw, sizeof(msc_cbw_t));
     f18:	491c      	ldr	r1, [pc, #112]	; (f8c <mscd_control_xfer_cb+0x108>)
     f1a:	221f      	movs	r2, #31
     f1c:	4620      	mov	r0, r4
     f1e:	e7da      	b.n	ed6 <mscd_control_xfer_cb+0x52>
  TU_VERIFY(request->bmRequestType_bit.type == TUSB_REQ_TYPE_CLASS);
     f20:	f003 0360 	and.w	r3, r3, #96	; 0x60
     f24:	2b20      	cmp	r3, #32
     f26:	d12f      	bne.n	f88 <mscd_control_xfer_cb+0x104>
  switch ( request->bRequest )
     f28:	786b      	ldrb	r3, [r5, #1]
     f2a:	2bfe      	cmp	r3, #254	; 0xfe
     f2c:	d012      	beq.n	f54 <mscd_control_xfer_cb+0xd0>
     f2e:	2bff      	cmp	r3, #255	; 0xff
     f30:	d12a      	bne.n	f88 <mscd_control_xfer_cb+0x104>
      TU_VERIFY(request->wValue == 0 && request->wLength == 0);
     f32:	886b      	ldrh	r3, [r5, #2]
     f34:	bb43      	cbnz	r3, f88 <mscd_control_xfer_cb+0x104>
     f36:	88e9      	ldrh	r1, [r5, #6]
     f38:	b28a      	uxth	r2, r1
     f3a:	bb2a      	cbnz	r2, f88 <mscd_control_xfer_cb+0x104>
  p_msc->stage       = MSC_STAGE_CMD;
     f3c:	4b13      	ldr	r3, [pc, #76]	; (f8c <mscd_control_xfer_cb+0x108>)
      tud_control_status(rhport, request);
     f3e:	4628      	mov	r0, r5
  p_msc->sense_key           = 0;
     f40:	8799      	strh	r1, [r3, #60]	; 0x3c
  p_msc->xferred_len = 0;
     f42:	e9c3 220d 	strd	r2, r2, [r3, #52]	; 0x34
  p_msc->stage       = MSC_STAGE_CMD;
     f46:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
  p_msc->add_sense_qualifier = 0;
     f4a:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
      tud_control_status(rhport, request);
     f4e:	f7ff fed7 	bl	d00 <tud_control_status.isra.0>
     f52:	e7af      	b.n	eb4 <mscd_control_xfer_cb+0x30>
      TU_VERIFY(request->wValue == 0 && request->wLength == 1);
     f54:	886b      	ldrh	r3, [r5, #2]
     f56:	b9bb      	cbnz	r3, f88 <mscd_control_xfer_cb+0x104>
     f58:	88eb      	ldrh	r3, [r5, #6]
     f5a:	2b01      	cmp	r3, #1
     f5c:	d114      	bne.n	f88 <mscd_control_xfer_cb+0x104>
      uint8_t maxlun = 1;
     f5e:	f88d 3007 	strb.w	r3, [sp, #7]
      if (tud_msc_get_maxlun_cb) maxlun = tud_msc_get_maxlun_cb();
     f62:	4b0c      	ldr	r3, [pc, #48]	; (f94 <mscd_control_xfer_cb+0x110>)
     f64:	b11b      	cbz	r3, f6e <mscd_control_xfer_cb+0xea>
     f66:	f3af 8000 	nop.w
     f6a:	f88d 0007 	strb.w	r0, [sp, #7]
      TU_VERIFY(maxlun);
     f6e:	f89d 3007 	ldrb.w	r3, [sp, #7]
     f72:	b14b      	cbz	r3, f88 <mscd_control_xfer_cb+0x104>
      maxlun--;
     f74:	3b01      	subs	r3, #1
      tud_control_xfer(rhport, request, &maxlun, 1);
     f76:	2201      	movs	r2, #1
     f78:	f10d 0107 	add.w	r1, sp, #7
     f7c:	4628      	mov	r0, r5
      maxlun--;
     f7e:	f88d 3007 	strb.w	r3, [sp, #7]
      tud_control_xfer(rhport, request, &maxlun, 1);
     f82:	f7ff fef9 	bl	d78 <tud_control_xfer.isra.0>
     f86:	e795      	b.n	eb4 <mscd_control_xfer_cb+0x30>
  switch ( request->bRequest )
     f88:	2000      	movs	r0, #0
     f8a:	e7af      	b.n	eec <mscd_control_xfer_cb+0x68>
     f8c:	20002428 	.word	0x20002428
     f90:	200024a8 	.word	0x200024a8
     f94:	00000000 	.word	0x00000000

00000f98 <configuration_reset>:
{
     f98:	b570      	push	{r4, r5, r6, lr}
  for ( uint8_t i = 0; i < TOTAL_DRIVER_COUNT; i++ )
     f9a:	4e14      	ldr	r6, [pc, #80]	; (fec <configuration_reset+0x54>)
{
     f9c:	4605      	mov	r5, r0
  for ( uint8_t i = 0; i < TOTAL_DRIVER_COUNT; i++ )
     f9e:	2400      	movs	r4, #0
    usbd_class_driver_t const * driver = get_driver(i);
     fa0:	4620      	mov	r0, r4
     fa2:	f7ff fa35 	bl	410 <get_driver>
    TU_ASSERT(driver, );
     fa6:	b938      	cbnz	r0, fb8 <configuration_reset+0x20>
     fa8:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
     fac:	f8d3 3df0 	ldr.w	r3, [r3, #3568]	; 0xdf0
     fb0:	07db      	lsls	r3, r3, #31
     fb2:	d500      	bpl.n	fb6 <configuration_reset+0x1e>
     fb4:	be00      	bkpt	0x0000
}
     fb6:	bd70      	pop	{r4, r5, r6, pc}
    driver->reset(rhport);
     fb8:	6843      	ldr	r3, [r0, #4]
     fba:	4628      	mov	r0, r5
     fbc:	4798      	blx	r3
  for ( uint8_t i = 0; i < TOTAL_DRIVER_COUNT; i++ )
     fbe:	7833      	ldrb	r3, [r6, #0]
     fc0:	3401      	adds	r4, #1
     fc2:	b2e4      	uxtb	r4, r4
     fc4:	3301      	adds	r3, #1
     fc6:	42a3      	cmp	r3, r4
     fc8:	daea      	bge.n	fa0 <configuration_reset+0x8>
  tu_varclr(&_usbd_dev);
     fca:	2233      	movs	r2, #51	; 0x33
     fcc:	2100      	movs	r1, #0
     fce:	4808      	ldr	r0, [pc, #32]	; (ff0 <configuration_reset+0x58>)
     fd0:	f001 fd28 	bl	2a24 <memset>
  memset(_usbd_dev.itf2drv, DRVID_INVALID, sizeof(_usbd_dev.itf2drv)); // invalid mapping
     fd4:	2210      	movs	r2, #16
     fd6:	21ff      	movs	r1, #255	; 0xff
     fd8:	4806      	ldr	r0, [pc, #24]	; (ff4 <configuration_reset+0x5c>)
     fda:	f001 fd23 	bl	2a24 <memset>
}
     fde:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  memset(_usbd_dev.ep2drv , DRVID_INVALID, sizeof(_usbd_dev.ep2drv )); // invalid mapping
     fe2:	4805      	ldr	r0, [pc, #20]	; (ff8 <configuration_reset+0x60>)
     fe4:	2210      	movs	r2, #16
     fe6:	21ff      	movs	r1, #255	; 0xff
     fe8:	f001 bd1c 	b.w	2a24 <memset>
     fec:	20002020 	.word	0x20002020
     ff0:	200024a8 	.word	0x200024a8
     ff4:	200024ab 	.word	0x200024ab
     ff8:	200024bb 	.word	0x200024bb

00000ffc <cdcd_init>:
{
     ffc:	b508      	push	{r3, lr}
  tu_memclr(_cdcd_itf, sizeof(_cdcd_itf));
     ffe:	4b10      	ldr	r3, [pc, #64]	; (1040 <_Min_Stack_Size+0x40>)
    1000:	f44f 7294 	mov.w	r2, #296	; 0x128
    1004:	2100      	movs	r1, #0
    1006:	4618      	mov	r0, r3
    1008:	f001 fd0c 	bl	2a24 <memset>
    p_cdc->line_coding.bit_rate  = 115200;
    100c:	f44f 4142 	mov.w	r1, #49664	; 0xc200
    1010:	80c1      	strh	r1, [r0, #6]
    1012:	2101      	movs	r1, #1
    1014:	8101      	strh	r1, [r0, #8]
    p_cdc->line_coding.data_bits = 8;
    1016:	2108      	movs	r1, #8
    1018:	7301      	strb	r1, [r0, #12]
  f->buffer       = (uint8_t*) buffer;
    101a:	f100 0128 	add.w	r1, r0, #40	; 0x28
    101e:	6101      	str	r1, [r0, #16]
  f->depth        = depth;
    1020:	4908      	ldr	r1, [pc, #32]	; (1044 <_Min_Stack_Size+0x44>)
    1022:	6141      	str	r1, [r0, #20]
    p_cdc->wanted_char = (char) -1;
    1024:	22ff      	movs	r2, #255	; 0xff
  f->buffer       = (uint8_t*) buffer;
    1026:	f100 0168 	add.w	r1, r0, #104	; 0x68
    102a:	7142      	strb	r2, [r0, #5]
    102c:	61c1      	str	r1, [r0, #28]
    p_cdc->line_coding.bit_rate  = 115200;
    102e:	2200      	movs	r2, #0
  f->depth        = depth;
    1030:	4905      	ldr	r1, [pc, #20]	; (1048 <_Min_Stack_Size+0x48>)
  f->rd_idx       = 0;
    1032:	8342      	strh	r2, [r0, #26]
  f->depth        = depth;
    1034:	6201      	str	r1, [r0, #32]
  f->wr_idx       = 0;
    1036:	8302      	strh	r2, [r0, #24]
  f->rd_idx       = 0;
    1038:	84c2      	strh	r2, [r0, #38]	; 0x26
  f->wr_idx       = 0;
    103a:	8482      	strh	r2, [r0, #36]	; 0x24
}
    103c:	bd08      	pop	{r3, pc}
    103e:	bf00      	nop
    1040:	20002024 	.word	0x20002024
    1044:	00010040 	.word	0x00010040
    1048:	80010040 	.word	0x80010040

0000104c <cdcd_reset>:
    tu_memclr(p_cdc, ITF_MEM_RESET_SIZE);
    104c:	4b07      	ldr	r3, [pc, #28]	; (106c <cdcd_reset+0x20>)
    104e:	2200      	movs	r2, #0
  f->rd_idx = 0;
    1050:	835a      	strh	r2, [r3, #26]
    1052:	601a      	str	r2, [r3, #0]
  f->wr_idx = 0;
    1054:	831a      	strh	r2, [r3, #24]
    1056:	711a      	strb	r2, [r3, #4]
  f->rd_idx = 0;
    1058:	84da      	strh	r2, [r3, #38]	; 0x26
  f->wr_idx = 0;
    105a:	849a      	strh	r2, [r3, #36]	; 0x24
  f->overwritable = overwritable;
    105c:	f893 2023 	ldrb.w	r2, [r3, #35]	; 0x23
    1060:	f042 0280 	orr.w	r2, r2, #128	; 0x80
    1064:	f883 2023 	strb.w	r2, [r3, #35]	; 0x23
}
    1068:	4770      	bx	lr
    106a:	bf00      	nop
    106c:	20002024 	.word	0x20002024

00001070 <mscd_init>:
  tu_memclr(&_mscd_itf, sizeof(mscd_interface_t));
    1070:	4802      	ldr	r0, [pc, #8]	; (107c <mscd_init+0xc>)
    1072:	2240      	movs	r2, #64	; 0x40
    1074:	2100      	movs	r1, #0
    1076:	f001 bcd5 	b.w	2a24 <memset>
    107a:	bf00      	nop
    107c:	20002428 	.word	0x20002428

00001080 <mscd_reset>:
  tu_memclr(&_mscd_itf, sizeof(mscd_interface_t));
    1080:	4802      	ldr	r0, [pc, #8]	; (108c <mscd_reset+0xc>)
    1082:	2240      	movs	r2, #64	; 0x40
    1084:	2100      	movs	r1, #0
    1086:	f001 bccd 	b.w	2a24 <memset>
    108a:	bf00      	nop
    108c:	20002428 	.word	0x20002428

00001090 <USB0_Handler>:
{
    1090:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 *-------------------------------------------------------------------*/
void dcd_int_handler(uint8_t rhport)
{
  uint_fast8_t is, txis, rxis;

  is   = USB0->IS;   /* read and clear interrupt status */
    1094:	4ba0      	ldr	r3, [pc, #640]	; (1318 <USB0_Handler+0x288>)
    1096:	7a9c      	ldrb	r4, [r3, #10]
  txis = USB0->TXIS; /* read and clear interrupt status */
    1098:	885d      	ldrh	r5, [r3, #2]
  rxis = USB0->RXIS; /* read and clear interrupt status */
    109a:	889f      	ldrh	r7, [r3, #4]
  // TU_LOG1("D%2x T%2x R%2x\n", is, txis, rxis);

  is &= USB0->IE; /* Clear disabled interrupts */
    109c:	7adb      	ldrb	r3, [r3, #11]
    109e:	401c      	ands	r4, r3
  if (is & USB_IS_DISCON) {
  }
  if (is & USB_IS_SOF) {
    10a0:	0721      	lsls	r1, r4, #28
    10a2:	b085      	sub	sp, #20
  txis = USB0->TXIS; /* read and clear interrupt status */
    10a4:	b2ad      	uxth	r5, r5
  rxis = USB0->RXIS; /* read and clear interrupt status */
    10a6:	b2bf      	uxth	r7, r7
  if (is & USB_IS_SOF) {
    10a8:	d50a      	bpl.n	10c0 <USB0_Handler+0x30>
  dcd_event_t event = { .rhport = rhport, .event_id = eid };
    10aa:	2300      	movs	r3, #0
    10ac:	e9cd 3301 	strd	r3, r3, [sp, #4]
    10b0:	9303      	str	r3, [sp, #12]
  dcd_event_handler(&event, in_isr);
    10b2:	2101      	movs	r1, #1
  dcd_event_t event = { .rhport = rhport, .event_id = eid };
    10b4:	2303      	movs	r3, #3
  dcd_event_handler(&event, in_isr);
    10b6:	a801      	add	r0, sp, #4
  dcd_event_t event = { .rhport = rhport, .event_id = eid };
    10b8:	f88d 3005 	strb.w	r3, [sp, #5]
  dcd_event_handler(&event, in_isr);
    10bc:	f7ff fbbe 	bl	83c <dcd_event_handler>
    dcd_event_bus_signal(rhport, DCD_EVENT_SOF, true);
  }
  if (is & USB_IS_RESET) {
    10c0:	0762      	lsls	r2, r4, #29
    10c2:	d523      	bpl.n	110c <USB0_Handler+0x7c>
  _dcd.setup_packet.bmRequestType = REQUEST_TYPE_INVALID;
    10c4:	4a95      	ldr	r2, [pc, #596]	; (131c <USB0_Handler+0x28c>)
  USB0->TXIE = 1; /* Enable only EP0 */
    10c6:	4994      	ldr	r1, [pc, #592]	; (1318 <USB0_Handler+0x288>)
  _dcd.setup_packet.bmRequestType = REQUEST_TYPE_INVALID;
    10c8:	23ff      	movs	r3, #255	; 0xff
    10ca:	7013      	strb	r3, [r2, #0]
  _dcd.status_out = 0;
    10cc:	2300      	movs	r3, #0
    10ce:	7293      	strb	r3, [r2, #10]
  _dcd.pipe0.buf = NULL;
    10d0:	72d3      	strb	r3, [r2, #11]
    10d2:	7313      	strb	r3, [r2, #12]
    10d4:	7353      	strb	r3, [r2, #13]
    10d6:	7393      	strb	r3, [r2, #14]
  USB0->TXIE = 1; /* Enable only EP0 */
    10d8:	2201      	movs	r2, #1
    10da:	80ca      	strh	r2, [r1, #6]
    USB0->TXFIFOSZ  = 0;
    10dc:	4618      	mov	r0, r3
  USB0->RXIE = 0; 
    10de:	810b      	strh	r3, [r1, #8]
    10e0:	b2d6      	uxtb	r6, r2
  for (unsigned i = 1; i < TUP_DCD_ENDPOINT_MAX; ++i) {
    10e2:	3201      	adds	r2, #1
    10e4:	2a08      	cmp	r2, #8
    USB0->EPIDX     = i;
    10e6:	738e      	strb	r6, [r1, #14]
    USB0->TXFIFOSZ  = 0;
    10e8:	f881 0062 	strb.w	r0, [r1, #98]	; 0x62
    USB0->TXFIFOADD = 0;
    10ec:	f8a1 3064 	strh.w	r3, [r1, #100]	; 0x64
    USB0->RXFIFOSZ  = 0;
    10f0:	f881 0063 	strb.w	r0, [r1, #99]	; 0x63
    USB0->RXFIFOADD = 0;
    10f4:	f8a1 3066 	strh.w	r3, [r1, #102]	; 0x66
  for (unsigned i = 1; i < TUP_DCD_ENDPOINT_MAX; ++i) {
    10f8:	d1f2      	bne.n	10e0 <USB0_Handler+0x50>
  dcd_event_t event = { .rhport = rhport, .event_id = DCD_EVENT_BUS_RESET };
    10fa:	2101      	movs	r1, #1
  dcd_event_handler(&event, in_isr);
    10fc:	a801      	add	r0, sp, #4
  dcd_event_t event = { .rhport = rhport, .event_id = DCD_EVENT_BUS_RESET };
    10fe:	e9cd 3301 	strd	r3, r3, [sp, #4]
    1102:	9303      	str	r3, [sp, #12]
    1104:	f88d 1005 	strb.w	r1, [sp, #5]
  dcd_event_handler(&event, in_isr);
    1108:	f7ff fb98 	bl	83c <dcd_event_handler>
    process_bus_reset(rhport);
  }
  if (is & USB_IS_RESUME) {
    110c:	07a3      	lsls	r3, r4, #30
    110e:	d50a      	bpl.n	1126 <USB0_Handler+0x96>
  dcd_event_t event = { .rhport = rhport, .event_id = eid };
    1110:	2300      	movs	r3, #0
    1112:	e9cd 3301 	strd	r3, r3, [sp, #4]
    1116:	9303      	str	r3, [sp, #12]
  dcd_event_handler(&event, in_isr);
    1118:	2101      	movs	r1, #1
  dcd_event_t event = { .rhport = rhport, .event_id = eid };
    111a:	2305      	movs	r3, #5
  dcd_event_handler(&event, in_isr);
    111c:	a801      	add	r0, sp, #4
  dcd_event_t event = { .rhport = rhport, .event_id = eid };
    111e:	f88d 3005 	strb.w	r3, [sp, #5]
  dcd_event_handler(&event, in_isr);
    1122:	f7ff fb8b 	bl	83c <dcd_event_handler>
    dcd_event_bus_signal(rhport, DCD_EVENT_RESUME, true);
  }
  if (is & USB_IS_SUSPEND) {
    1126:	07e6      	lsls	r6, r4, #31
    1128:	d50b      	bpl.n	1142 <USB0_Handler+0xb2>
  dcd_event_t event = { .rhport = rhport, .event_id = eid };
    112a:	2300      	movs	r3, #0
    112c:	e9cd 3301 	strd	r3, r3, [sp, #4]
    1130:	9303      	str	r3, [sp, #12]
    1132:	2304      	movs	r3, #4
  dcd_event_handler(&event, in_isr);
    1134:	2101      	movs	r1, #1
    1136:	eb0d 0003 	add.w	r0, sp, r3
  dcd_event_t event = { .rhport = rhport, .event_id = eid };
    113a:	f88d 3005 	strb.w	r3, [sp, #5]
  dcd_event_handler(&event, in_isr);
    113e:	f7ff fb7d 	bl	83c <dcd_event_handler>
    dcd_event_bus_signal(rhport, DCD_EVENT_SUSPEND, true);
  }

  txis &= USB0->TXIE; /* Clear disabled interrupts */
    1142:	4a75      	ldr	r2, [pc, #468]	; (1318 <USB0_Handler+0x288>)
    1144:	88d3      	ldrh	r3, [r2, #6]
    1146:	401d      	ands	r5, r3
  if (txis & USB_TXIE_EP0) {
    1148:	07ec      	lsls	r4, r5, #31
    114a:	d50a      	bpl.n	1162 <USB0_Handler+0xd2>
  uint_fast8_t csrl = USB0->CSRL0;
    114c:	f892 3102 	ldrb.w	r3, [r2, #258]	; 0x102
    1150:	b2de      	uxtb	r6, r3
  if (csrl & USB_CSRL0_STALLED) {
    1152:	f013 0304 	ands.w	r3, r3, #4
    1156:	d012      	beq.n	117e <USB0_Handler+0xee>
    USB0->CSRL0 = 0; /* Clear STALL */
    1158:	2300      	movs	r3, #0
    115a:	f882 3102 	strb.w	r3, [r2, #258]	; 0x102
    process_ep0(rhport);
    txis &= ~TU_BIT(0);
    115e:	f025 0501 	bic.w	r5, r5, #1
  }
  while (txis) {
    unsigned const num = __builtin_ctz(txis);
    process_edpt_n(rhport, tu_edpt_addr(num, TUSB_DIR_IN));
    txis &= ~TU_BIT(num);
    1162:	2601      	movs	r6, #1
  while (txis) {
    1164:	2d00      	cmp	r5, #0
    1166:	f040 80bd 	bne.w	12e4 <USB0_Handler+0x254>
  }
  rxis &= USB0->RXIE; /* Clear disabled interrupts */
    116a:	4b6b      	ldr	r3, [pc, #428]	; (1318 <USB0_Handler+0x288>)
    116c:	891b      	ldrh	r3, [r3, #8]
  while (rxis) {
    unsigned const num = __builtin_ctz(rxis);
    process_edpt_n(rhport, tu_edpt_addr(num, TUSB_DIR_OUT));
    rxis &= ~TU_BIT(num);
    116e:	2501      	movs	r5, #1
  rxis &= USB0->RXIE; /* Clear disabled interrupts */
    1170:	401f      	ands	r7, r3
  while (rxis) {
    1172:	2f00      	cmp	r7, #0
    1174:	f040 80c3 	bne.w	12fe <USB0_Handler+0x26e>
}
    1178:	b005      	add	sp, #20
    117a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  unsigned req = _dcd.setup_packet.bmRequestType;
    117e:	4c67      	ldr	r4, [pc, #412]	; (131c <USB0_Handler+0x28c>)
    1180:	f006 0801 	and.w	r8, r6, #1
  if (csrl & USB_CSRL0_SETEND) {
    1184:	f016 0610 	ands.w	r6, r6, #16
  unsigned req = _dcd.setup_packet.bmRequestType;
    1188:	7821      	ldrb	r1, [r4, #0]
  if (csrl & USB_CSRL0_SETEND) {
    118a:	d04b      	beq.n	1224 <USB0_Handler+0x194>
    USB0->CSRL0 = USB_CSRL0_SETENDC;
    118c:	2080      	movs	r0, #128	; 0x80
    if (req != REQUEST_TYPE_INVALID && _dcd.pipe0.buf) {
    118e:	29ff      	cmp	r1, #255	; 0xff
    USB0->CSRL0 = USB_CSRL0_SETENDC;
    1190:	f882 0102 	strb.w	r0, [r2, #258]	; 0x102
    if (req != REQUEST_TYPE_INVALID && _dcd.pipe0.buf) {
    1194:	d01b      	beq.n	11ce <USB0_Handler+0x13e>
    1196:	f8d4 200b 	ldr.w	r2, [r4, #11]
    119a:	b1c2      	cbz	r2, 11ce <USB0_Handler+0x13e>
      _dcd.setup_packet.bmRequestType = REQUEST_TYPE_INVALID;
    119c:	22ff      	movs	r2, #255	; 0xff
                              _dcd.pipe0.length - _dcd.pipe0.remaining,
    119e:	f8b4 0011 	ldrh.w	r0, [r4, #17]
      _dcd.setup_packet.bmRequestType = REQUEST_TYPE_INVALID;
    11a2:	7022      	strb	r2, [r4, #0]
                              _dcd.pipe0.length - _dcd.pipe0.remaining,
    11a4:	f8b4 200f 	ldrh.w	r2, [r4, #15]
      _dcd.pipe0.buf = NULL;
    11a8:	72e3      	strb	r3, [r4, #11]
      dcd_event_xfer_complete(rhport,
    11aa:	f021 017f 	bic.w	r1, r1, #127	; 0x7f
  dcd_event_t event = { .rhport = rhport, .event_id = DCD_EVENT_XFER_COMPLETE };
    11ae:	e9cd 3301 	strd	r3, r3, [sp, #4]
                              _dcd.pipe0.length - _dcd.pipe0.remaining,
    11b2:	1a12      	subs	r2, r2, r0
      _dcd.pipe0.buf = NULL;
    11b4:	7323      	strb	r3, [r4, #12]
    11b6:	7363      	strb	r3, [r4, #13]
    11b8:	73a3      	strb	r3, [r4, #14]
  event.xfer_complete.ep_addr = ep_addr;
    11ba:	f88d 1008 	strb.w	r1, [sp, #8]
  dcd_event_t event = { .rhport = rhport, .event_id = DCD_EVENT_XFER_COMPLETE };
    11be:	2307      	movs	r3, #7
  dcd_event_handler(&event, in_isr);
    11c0:	2101      	movs	r1, #1
    11c2:	a801      	add	r0, sp, #4
  dcd_event_t event = { .rhport = rhport, .event_id = DCD_EVENT_XFER_COMPLETE };
    11c4:	f88d 3005 	strb.w	r3, [sp, #5]
  event.xfer_complete.len     = xferred_bytes;
    11c8:	9203      	str	r2, [sp, #12]
  dcd_event_handler(&event, in_isr);
    11ca:	f7ff fb37 	bl	83c <dcd_event_handler>
    if (!(csrl & USB_CSRL0_RXRDY)) return; /* Received SETUP packet */
    11ce:	f1b8 0f00 	cmp.w	r8, #0
    11d2:	d0c4      	beq.n	115e <USB0_Handler+0xce>
      TU_ASSERT(sizeof(tusb_control_request_t) == USB0->COUNT0,);
    11d4:	4e50      	ldr	r6, [pc, #320]	; (1318 <USB0_Handler+0x288>)
    11d6:	f896 3108 	ldrb.w	r3, [r6, #264]	; 0x108
    11da:	2b08      	cmp	r3, #8
    11dc:	d157      	bne.n	128e <USB0_Handler+0x1fe>
  p[0]        = USB0->FIFO0_WORD;
    11de:	6a33      	ldr	r3, [r6, #32]
    11e0:	6023      	str	r3, [r4, #0]
  p[1]        = USB0->FIFO0_WORD;
    11e2:	6a33      	ldr	r3, [r6, #32]
    11e4:	6063      	str	r3, [r4, #4]
  _dcd.pipe0.buf       = NULL;
    11e6:	2300      	movs	r3, #0
  memcpy(&event.setup_received, setup, sizeof(tusb_control_request_t));
    11e8:	6820      	ldr	r0, [r4, #0]
    11ea:	6861      	ldr	r1, [r4, #4]
    11ec:	72e3      	strb	r3, [r4, #11]
    11ee:	7323      	strb	r3, [r4, #12]
    11f0:	7363      	strb	r3, [r4, #13]
    11f2:	73a3      	strb	r3, [r4, #14]
  _dcd.pipe0.length    = 0;
    11f4:	73e3      	strb	r3, [r4, #15]
    11f6:	7423      	strb	r3, [r4, #16]
  _dcd.pipe0.remaining = 0;
    11f8:	7463      	strb	r3, [r4, #17]
    11fa:	74a3      	strb	r3, [r4, #18]
  dcd_event_t event = { .rhport = rhport, .event_id = DCD_EVENT_SETUP_RECEIVED };
    11fc:	f44f 63c0 	mov.w	r3, #1536	; 0x600
    1200:	9301      	str	r3, [sp, #4]
  memcpy(&event.setup_received, setup, sizeof(tusb_control_request_t));
    1202:	ab02      	add	r3, sp, #8
    1204:	c303      	stmia	r3!, {r0, r1}
  dcd_event_handler(&event, in_isr);
    1206:	2101      	movs	r1, #1
    1208:	a801      	add	r0, sp, #4
    120a:	f7ff fb17 	bl	83c <dcd_event_handler>
  const unsigned len    = _dcd.setup_packet.wLength;
    120e:	88e3      	ldrh	r3, [r4, #6]
  _dcd.remaining_ctrl   = len;
    1210:	8123      	strh	r3, [r4, #8]
  if (len && dir_in) USB0->CSRL0 = USB_CSRL0_RXRDYC;
    1212:	2b00      	cmp	r3, #0
    1214:	d0a3      	beq.n	115e <USB0_Handler+0xce>
    1216:	7823      	ldrb	r3, [r4, #0]
    1218:	09db      	lsrs	r3, r3, #7
    121a:	d0a0      	beq.n	115e <USB0_Handler+0xce>
    121c:	2340      	movs	r3, #64	; 0x40
    121e:	f886 3102 	strb.w	r3, [r6, #258]	; 0x102
    1222:	e79c      	b.n	115e <USB0_Handler+0xce>
  if (csrl & USB_CSRL0_RXRDY) {
    1224:	f1b8 0f00 	cmp.w	r8, #0
    1228:	d03a      	beq.n	12a0 <USB0_Handler+0x210>
    if (req == REQUEST_TYPE_INVALID) {
    122a:	29ff      	cmp	r1, #255	; 0xff
    122c:	d0d2      	beq.n	11d4 <USB0_Handler+0x144>
    if (_dcd.pipe0.buf) {
    122e:	f8d4 000b 	ldr.w	r0, [r4, #11]
    1232:	2800      	cmp	r0, #0
    1234:	d093      	beq.n	115e <USB0_Handler+0xce>
      const unsigned vld = USB0->COUNT0;
    1236:	f892 8108 	ldrb.w	r8, [r2, #264]	; 0x108
      const unsigned rem = _dcd.pipe0.remaining;
    123a:	f8b4 9011 	ldrh.w	r9, [r4, #17]
      pipe_read_packet(_dcd.pipe0.buf, &USB0->FIFO0_WORD, len);
    123e:	4938      	ldr	r1, [pc, #224]	; (1320 <USB0_Handler+0x290>)
      const unsigned len = TU_MIN(TU_MIN(rem, 64), vld);
    1240:	45c8      	cmp	r8, r9
    1242:	bf28      	it	cs
    1244:	46c8      	movcs	r8, r9
    1246:	f1b8 0f40 	cmp.w	r8, #64	; 0x40
    124a:	bf28      	it	cs
    124c:	f04f 0840 	movcs.w	r8, #64	; 0x40
      pipe_read_packet(_dcd.pipe0.buf, &USB0->FIFO0_WORD, len);
    1250:	4642      	mov	r2, r8
    1252:	f7ff f96a 	bl	52a <pipe_read_packet>
      _dcd.remaining_ctrl -= len;
    1256:	8922      	ldrh	r2, [r4, #8]
                              _dcd.pipe0.length - _dcd.pipe0.remaining,
    1258:	f8b4 300f 	ldrh.w	r3, [r4, #15]
      _dcd.pipe0.buf = NULL;
    125c:	72e6      	strb	r6, [r4, #11]
      _dcd.pipe0.remaining = rem - len;
    125e:	eba9 0908 	sub.w	r9, r9, r8
      _dcd.remaining_ctrl -= len;
    1262:	eba2 0208 	sub.w	r2, r2, r8
      _dcd.pipe0.remaining = rem - len;
    1266:	fa1f f189 	uxth.w	r1, r9
      _dcd.remaining_ctrl -= len;
    126a:	8122      	strh	r2, [r4, #8]
  dcd_event_t event = { .rhport = rhport, .event_id = DCD_EVENT_XFER_COMPLETE };
    126c:	2207      	movs	r2, #7
    126e:	e9cd 6601 	strd	r6, r6, [sp, #4]
      _dcd.pipe0.remaining = rem - len;
    1272:	f8a4 9011 	strh.w	r9, [r4, #17]
      _dcd.pipe0.buf = NULL;
    1276:	7326      	strb	r6, [r4, #12]
    1278:	7366      	strb	r6, [r4, #13]
    127a:	73a6      	strb	r6, [r4, #14]
                              _dcd.pipe0.length - _dcd.pipe0.remaining,
    127c:	1a5b      	subs	r3, r3, r1
    127e:	f88d 2005 	strb.w	r2, [sp, #5]
  dcd_event_handler(&event, in_isr);
    1282:	2101      	movs	r1, #1
    1284:	a801      	add	r0, sp, #4
  event.xfer_complete.len     = xferred_bytes;
    1286:	9303      	str	r3, [sp, #12]
  dcd_event_handler(&event, in_isr);
    1288:	f7ff fad8 	bl	83c <dcd_event_handler>
}
    128c:	e767      	b.n	115e <USB0_Handler+0xce>
      TU_ASSERT(sizeof(tusb_control_request_t) == USB0->COUNT0,);
    128e:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    1292:	f8d3 3df0 	ldr.w	r3, [r3, #3568]	; 0xdf0
    1296:	07d8      	lsls	r0, r3, #31
    1298:	f57f af61 	bpl.w	115e <USB0_Handler+0xce>
    129c:	be00      	bkpt	0x0000
    129e:	e75e      	b.n	115e <USB0_Handler+0xce>
  if (req != REQUEST_TYPE_INVALID && !tu_edpt_dir(req)) {
    12a0:	29ff      	cmp	r1, #255	; 0xff
    12a2:	d014      	beq.n	12ce <USB0_Handler+0x23e>
    12a4:	09cb      	lsrs	r3, r1, #7
    12a6:	d112      	bne.n	12ce <USB0_Handler+0x23e>
    if (*(const uint16_t*)(uintptr_t)&_dcd.setup_packet == 0x0500) {
    12a8:	8823      	ldrh	r3, [r4, #0]
    12aa:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
      USB0->FADDR = (uint8_t)_dcd.setup_packet.wValue;
    12ae:	bf04      	itt	eq
    12b0:	78a3      	ldrbeq	r3, [r4, #2]
    12b2:	7013      	strbeq	r3, [r2, #0]
    _dcd.setup_packet.bmRequestType = REQUEST_TYPE_INVALID;
    12b4:	23ff      	movs	r3, #255	; 0xff
    12b6:	7023      	strb	r3, [r4, #0]
                            _dcd.pipe0.length - _dcd.pipe0.remaining,
    12b8:	f8b4 2011 	ldrh.w	r2, [r4, #17]
    12bc:	f8b4 300f 	ldrh.w	r3, [r4, #15]
  dcd_event_t event = { .rhport = rhport, .event_id = DCD_EVENT_XFER_COMPLETE };
    12c0:	f44f 61e0 	mov.w	r1, #1792	; 0x700
    12c4:	1a9b      	subs	r3, r3, r2
    12c6:	2280      	movs	r2, #128	; 0x80
    12c8:	e9cd 1201 	strd	r1, r2, [sp, #4]
    12cc:	e7d9      	b.n	1282 <USB0_Handler+0x1f2>
  if (_dcd.pipe0.buf) {
    12ce:	f8d4 300b 	ldr.w	r3, [r4, #11]
    12d2:	2b00      	cmp	r3, #0
    12d4:	f43f af43 	beq.w	115e <USB0_Handler+0xce>
    _dcd.pipe0.buf = NULL;
    12d8:	2300      	movs	r3, #0
    12da:	72e3      	strb	r3, [r4, #11]
    12dc:	7323      	strb	r3, [r4, #12]
    12de:	7363      	strb	r3, [r4, #13]
    12e0:	73a3      	strb	r3, [r4, #14]
    12e2:	e7e9      	b.n	12b8 <USB0_Handler+0x228>
    unsigned const num = __builtin_ctz(txis);
    12e4:	fa95 f4a5 	rbit	r4, r5
    12e8:	fab4 f484 	clz	r4, r4
    process_edpt_n(rhport, tu_edpt_addr(num, TUSB_DIR_IN));
    12ec:	f044 0080 	orr.w	r0, r4, #128	; 0x80
    txis &= ~TU_BIT(num);
    12f0:	fa06 f404 	lsl.w	r4, r6, r4
    process_edpt_n(rhport, tu_edpt_addr(num, TUSB_DIR_IN));
    12f4:	f7ff fb18 	bl	928 <process_edpt_n.constprop.0>
    txis &= ~TU_BIT(num);
    12f8:	ea25 0504 	bic.w	r5, r5, r4
    12fc:	e732      	b.n	1164 <USB0_Handler+0xd4>
    unsigned const num = __builtin_ctz(rxis);
    12fe:	fa97 f4a7 	rbit	r4, r7
    1302:	fab4 f484 	clz	r4, r4
    process_edpt_n(rhport, tu_edpt_addr(num, TUSB_DIR_OUT));
    1306:	4620      	mov	r0, r4
    rxis &= ~TU_BIT(num);
    1308:	fa05 f404 	lsl.w	r4, r5, r4
    process_edpt_n(rhport, tu_edpt_addr(num, TUSB_DIR_OUT));
    130c:	f7ff fb0c 	bl	928 <process_edpt_n.constprop.0>
    rxis &= ~TU_BIT(num);
    1310:	ea27 0704 	bic.w	r7, r7, r4
    1314:	e72d      	b.n	1172 <USB0_Handler+0xe2>
    1316:	bf00      	nop
    1318:	40050000 	.word	0x40050000
    131c:	20002160 	.word	0x20002160
    1320:	40050020 	.word	0x40050020

00001324 <proc_read10_cmd.constprop.0>:
static void proc_read10_cmd(uint8_t rhport, mscd_interface_t* p_msc)
    1324:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}

#else

// MCU that could access unaligned memory natively
TU_ATTR_ALWAYS_INLINE static inline uint32_t tu_unaligned_read32  (const void* mem) { return *((uint32_t const *) mem); }
TU_ATTR_ALWAYS_INLINE static inline uint16_t tu_unaligned_read16  (const void* mem) { return *((uint16_t const *) mem); }
    1328:	4c29      	ldr	r4, [pc, #164]	; (13d0 <proc_read10_cmd.constprop.0+0xac>)
  return tu_ntohs(block_count);
    132a:	8ae1      	ldrh	r1, [r4, #22]
  return (uint16_t) (cbw->total_bytes / block_count);
    132c:	68a6      	ldr	r6, [r4, #8]
  return tu_ntohs(block_count);
    132e:	ba49      	rev16	r1, r1
    1330:	b289      	uxth	r1, r1
static void proc_read10_cmd(uint8_t rhport, mscd_interface_t* p_msc)
    1332:	4605      	mov	r5, r0
  if (block_count == 0) return 0;
    1334:	b111      	cbz	r1, 133c <proc_read10_cmd.constprop.0+0x18>
  return (uint16_t) (cbw->total_bytes / block_count);
    1336:	fbb6 f1f1 	udiv	r1, r6, r1
    133a:	b289      	uxth	r1, r1
  uint32_t const lba = rdwr10_get_lba(p_cbw->command) + (p_msc->xferred_len / block_sz);
    133c:	6ba7      	ldr	r7, [r4, #56]	; 0x38
TU_ATTR_ALWAYS_INLINE static inline uint32_t tu_unaligned_read32  (const void* mem) { return *((uint32_t const *) mem); }
    133e:	f8d4 0011 	ldr.w	r0, [r4, #17]
    1342:	fbb7 f3f1 	udiv	r3, r7, r1
  int32_t nbytes = (int32_t) tu_min32(sizeof(_mscd_buf), p_cbw->total_bytes-p_msc->xferred_len);
    1346:	eba6 0807 	sub.w	r8, r6, r7
  return tu_ntohl(lba);
    134a:	ba00      	rev	r0, r0
TU_ATTR_ALWAYS_INLINE static inline uint32_t tu_min32 (uint32_t x, uint32_t y) { return (x < y) ? x : y; }
    134c:	f5b8 7f00 	cmp.w	r8, #512	; 0x200
  uint32_t const lba = rdwr10_get_lba(p_cbw->command) + (p_msc->xferred_len / block_sz);
    1350:	4418      	add	r0, r3
    1352:	bf28      	it	cs
    1354:	f44f 7800 	movcs.w	r8, #512	; 0x200
int32_t tud_msc_read10_cb(uint8_t lun, uint32_t lba, uint32_t offset, void* buffer, uint32_t bufsize)
{
  (void) lun;

  // out of ramdisk
  if ( lba >= DISK_BLOCK_NUM ) return -1;
    1358:	280f      	cmp	r0, #15
  uint32_t const offset = p_msc->xferred_len % block_sz;
    135a:	fb01 7113 	mls	r1, r1, r3, r7
    135e:	d90b      	bls.n	1378 <proc_read10_cmd.constprop.0+0x54>
  _mscd_itf.sense_key           = sense_key;
    1360:	f643 2302 	movw	r3, #14850	; 0x3a02
    1364:	87a3      	strh	r3, [r4, #60]	; 0x3c
    fail_scsi_op(rhport, p_msc, MSC_CSW_STATUS_FAILED);
    1366:	2001      	movs	r0, #1
  _mscd_itf.add_sense_qualifier = add_sense_qualifier;
    1368:	2300      	movs	r3, #0
    136a:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
}
    136e:	b004      	add	sp, #16
    1370:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    fail_scsi_op(rhport, p_msc, MSC_CSW_STATUS_FAILED);
    1374:	f7ff ba10 	b.w	798 <fail_scsi_op.constprop.0.isra.0>

  uint8_t const* addr = msc_disk[lba] + offset;
  memcpy(buffer, addr, bufsize);
    1378:	4b16      	ldr	r3, [pc, #88]	; (13d4 <proc_read10_cmd.constprop.0+0xb0>)
  uint8_t const* addr = msc_disk[lba] + offset;
    137a:	eb01 2140 	add.w	r1, r1, r0, lsl #9
  memcpy(buffer, addr, bufsize);
    137e:	4642      	mov	r2, r8
    1380:	4815      	ldr	r0, [pc, #84]	; (13d8 <proc_read10_cmd.constprop.0+0xb4>)
    1382:	4419      	add	r1, r3
    1384:	f001 fb56 	bl	2a34 <memcpy>
  else if ( nbytes == 0 )
    1388:	42b7      	cmp	r7, r6
    dcd_event_xfer_complete(rhport, p_msc->ep_in, 0, XFER_RESULT_SUCCESS, false);
    138a:	f894 002e 	ldrb.w	r0, [r4, #46]	; 0x2e
  else if ( nbytes == 0 )
    138e:	d110      	bne.n	13b2 <proc_read10_cmd.constprop.0+0x8e>
    1390:	2100      	movs	r1, #0
    1392:	e9cd 1101 	strd	r1, r1, [sp, #4]
    1396:	2307      	movs	r3, #7
  event.xfer_complete.ep_addr = ep_addr;
    1398:	f88d 0008 	strb.w	r0, [sp, #8]
  dcd_event_handler(&event, in_isr);
    139c:	a801      	add	r0, sp, #4
  dcd_event_t event = { .rhport = rhport, .event_id = DCD_EVENT_XFER_COMPLETE };
    139e:	f88d 5004 	strb.w	r5, [sp, #4]
    13a2:	f88d 3005 	strb.w	r3, [sp, #5]
  event.xfer_complete.len     = xferred_bytes;
    13a6:	9103      	str	r1, [sp, #12]
  dcd_event_handler(&event, in_isr);
    13a8:	f7ff fa48 	bl	83c <dcd_event_handler>
}
    13ac:	b004      	add	sp, #16
    13ae:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    TU_ASSERT( usbd_edpt_xfer(rhport, p_msc->ep_in, _mscd_buf, (uint16_t) nbytes), );
    13b2:	4909      	ldr	r1, [pc, #36]	; (13d8 <proc_read10_cmd.constprop.0+0xb4>)
    13b4:	fa1f f288 	uxth.w	r2, r8
    13b8:	f7ff fb4e 	bl	a58 <usbd_edpt_xfer.constprop.0>
    13bc:	2800      	cmp	r0, #0
    13be:	d1f5      	bne.n	13ac <proc_read10_cmd.constprop.0+0x88>
    13c0:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    13c4:	f8d3 3df0 	ldr.w	r3, [r3, #3568]	; 0xdf0
    13c8:	07db      	lsls	r3, r3, #31
    13ca:	d5ef      	bpl.n	13ac <proc_read10_cmd.constprop.0+0x88>
    13cc:	be00      	bkpt	0x0000
    13ce:	e7ed      	b.n	13ac <proc_read10_cmd.constprop.0+0x88>
    13d0:	20002428 	.word	0x20002428
    13d4:	2000001c 	.word	0x2000001c
    13d8:	20002228 	.word	0x20002228

000013dc <mscd_xfer_cb>:
{
    13dc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  switch (p_msc->stage)
    13e0:	4caa      	ldr	r4, [pc, #680]	; (168c <mscd_xfer_cb+0x2b0>)
    13e2:	f894 6030 	ldrb.w	r6, [r4, #48]	; 0x30
    13e6:	2e01      	cmp	r6, #1
{
    13e8:	b090      	sub	sp, #64	; 0x40
    13ea:	460f      	mov	r7, r1
    13ec:	461d      	mov	r5, r3
  switch (p_msc->stage)
    13ee:	f000 8199 	beq.w	1724 <mscd_xfer_cb+0x348>
    13f2:	2e03      	cmp	r6, #3
    13f4:	f000 81ec 	beq.w	17d0 <mscd_xfer_cb+0x3f4>
    13f8:	2e00      	cmp	r6, #0
    13fa:	d136      	bne.n	146a <mscd_xfer_cb+0x8e>
      if(ep_addr != p_msc->ep_out) return true;
    13fc:	f894 302f 	ldrb.w	r3, [r4, #47]	; 0x2f
    1400:	428b      	cmp	r3, r1
    1402:	d001      	beq.n	1408 <mscd_xfer_cb+0x2c>
  return true;
    1404:	2001      	movs	r0, #1
        usbd_edpt_stall(rhport, p_msc->ep_in);
    1406:	e011      	b.n	142c <mscd_xfer_cb+0x50>
      if ( !(xferred_bytes == sizeof(msc_cbw_t) && p_cbw->signature == MSC_CBW_SIGNATURE) )
    1408:	2d1f      	cmp	r5, #31
    140a:	d103      	bne.n	1414 <mscd_xfer_cb+0x38>
    140c:	6822      	ldr	r2, [r4, #0]
    140e:	4ba0      	ldr	r3, [pc, #640]	; (1690 <mscd_xfer_cb+0x2b4>)
    1410:	429a      	cmp	r2, r3
    1412:	d00e      	beq.n	1432 <mscd_xfer_cb+0x56>
        usbd_edpt_stall(rhport, p_msc->ep_in);
    1414:	f894 002e 	ldrb.w	r0, [r4, #46]	; 0x2e
        p_msc->stage = MSC_STAGE_NEED_RESET;
    1418:	2304      	movs	r3, #4
    141a:	f884 3030 	strb.w	r3, [r4, #48]	; 0x30
        usbd_edpt_stall(rhport, p_msc->ep_in);
    141e:	f7ff f967 	bl	6f0 <usbd_edpt_stall.constprop.0>
        usbd_edpt_stall(rhport, p_msc->ep_out);
    1422:	f894 002f 	ldrb.w	r0, [r4, #47]	; 0x2f
    1426:	f7ff f963 	bl	6f0 <usbd_edpt_stall.constprop.0>
            TU_ASSERT( usbd_edpt_xfer(rhport, p_msc->ep_out, _mscd_buf, (uint16_t) p_msc->total_len) );
    142a:	2000      	movs	r0, #0
}
    142c:	b010      	add	sp, #64	; 0x40
    142e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      p_csw->signature    = MSC_CSW_SIGNATURE;
    1432:	4b98      	ldr	r3, [pc, #608]	; (1694 <mscd_xfer_cb+0x2b8>)
    1434:	6223      	str	r3, [r4, #32]
      p_csw->tag          = p_cbw->tag;
    1436:	6863      	ldr	r3, [r4, #4]
      p_msc->total_len = p_cbw->total_bytes;
    1438:	68a2      	ldr	r2, [r4, #8]
      p_csw->status       = MSC_CSW_STATUS_PASSED;
    143a:	f884 602c 	strb.w	r6, [r4, #44]	; 0x2c
      p_csw->data_residue = 0;
    143e:	e9c4 3609 	strd	r3, r6, [r4, #36]	; 0x24
      p_msc->stage = MSC_STAGE_DATA;
    1442:	2301      	movs	r3, #1
    1444:	f884 3030 	strb.w	r3, [r4, #48]	; 0x30
      if ( (SCSI_CMD_READ_10 == p_cbw->command[0]) || (SCSI_CMD_WRITE_10 == p_cbw->command[0]) )
    1448:	7be3      	ldrb	r3, [r4, #15]
    144a:	f003 01fd 	and.w	r1, r3, #253	; 0xfd
    144e:	2928      	cmp	r1, #40	; 0x28
      p_msc->xferred_len = 0;
    1450:	e9c4 260d 	strd	r2, r6, [r4, #52]	; 0x34
      if ( (SCSI_CMD_READ_10 == p_cbw->command[0]) || (SCSI_CMD_WRITE_10 == p_cbw->command[0]) )
    1454:	d13a      	bne.n	14cc <mscd_xfer_cb+0xf0>
  return tu_ntohs(block_count);
    1456:	8ae1      	ldrh	r1, [r4, #22]
    1458:	ba49      	rev16	r1, r1
    145a:	b289      	uxth	r1, r1
  if ( cbw->total_bytes == 0 )
    145c:	bb12      	cbnz	r2, 14a4 <mscd_xfer_cb+0xc8>
    if ( block_count )
    145e:	2900      	cmp	r1, #0
    1460:	f000 8092 	beq.w	1588 <mscd_xfer_cb+0x1ac>
      status = MSC_CSW_STATUS_PHASE_ERROR;
    1464:	2002      	movs	r0, #2
          fail_scsi_op(rhport, p_msc, status);
    1466:	f7ff f997 	bl	798 <fail_scsi_op.constprop.0.isra.0>
  if ( p_msc->stage == MSC_STAGE_STATUS )
    146a:	f894 3030 	ldrb.w	r3, [r4, #48]	; 0x30
    146e:	2b02      	cmp	r3, #2
    1470:	d1c8      	bne.n	1404 <mscd_xfer_cb+0x28>
    if ( !usbd_edpt_stalled(rhport,  p_msc->ep_in) )
    1472:	f894 002e 	ldrb.w	r0, [r4, #46]	; 0x2e
  return _usbd_dev.ep_status[epnum][dir].stalled;
    1476:	4b88      	ldr	r3, [pc, #544]	; (1698 <mscd_xfer_cb+0x2bc>)
    1478:	f000 027f 	and.w	r2, r0, #127	; 0x7f
    147c:	eb03 0342 	add.w	r3, r3, r2, lsl #1
    1480:	eb03 13d0 	add.w	r3, r3, r0, lsr #7
    1484:	3320      	adds	r3, #32
    1486:	78db      	ldrb	r3, [r3, #3]
    1488:	079b      	lsls	r3, r3, #30
    148a:	d4bb      	bmi.n	1404 <mscd_xfer_cb+0x28>
      if ( (p_cbw->total_bytes > p_msc->xferred_len) && is_data_in(p_cbw->dir) )
    148c:	68a3      	ldr	r3, [r4, #8]
    148e:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    1490:	4293      	cmp	r3, r2
    1492:	f240 81c6 	bls.w	1822 <mscd_xfer_cb+0x446>
  return tu_bit_test(dir, 7);
    1496:	7b21      	ldrb	r1, [r4, #12]
      if ( (p_cbw->total_bytes > p_msc->xferred_len) && is_data_in(p_cbw->dir) )
    1498:	09c9      	lsrs	r1, r1, #7
    149a:	f000 81c2 	beq.w	1822 <mscd_xfer_cb+0x446>
        usbd_edpt_stall(rhport, p_msc->ep_in);
    149e:	f7ff f927 	bl	6f0 <usbd_edpt_stall.constprop.0>
    14a2:	e7af      	b.n	1404 <mscd_xfer_cb+0x28>
    if ( SCSI_CMD_READ_10 == cbw->command[0] && !is_data_in(cbw->dir) )
    14a4:	2b28      	cmp	r3, #40	; 0x28
    14a6:	d10b      	bne.n	14c0 <mscd_xfer_cb+0xe4>
  return tu_bit_test(dir, 7);
    14a8:	7b25      	ldrb	r5, [r4, #12]
    if ( SCSI_CMD_READ_10 == cbw->command[0] && !is_data_in(cbw->dir) )
    14aa:	09ed      	lsrs	r5, r5, #7
    14ac:	d0da      	beq.n	1464 <mscd_xfer_cb+0x88>
    else if ( 0 == block_count )
    14ae:	b1a1      	cbz	r1, 14da <mscd_xfer_cb+0xfe>
    else if ( cbw->total_bytes / block_count == 0 )
    14b0:	428a      	cmp	r2, r1
    14b2:	d3d7      	bcc.n	1464 <mscd_xfer_cb+0x88>
          if (SCSI_CMD_READ_10 == p_cbw->command[0])
    14b4:	2b28      	cmp	r3, #40	; 0x28
    14b6:	f040 816d 	bne.w	1794 <mscd_xfer_cb+0x3b8>
            proc_read10_cmd(rhport, p_msc);
    14ba:	f7ff ff33 	bl	1324 <proc_read10_cmd.constprop.0>
    14be:	e7d4      	b.n	146a <mscd_xfer_cb+0x8e>
    else if ( SCSI_CMD_WRITE_10 == cbw->command[0] && is_data_in(cbw->dir) )
    14c0:	2b2a      	cmp	r3, #42	; 0x2a
    14c2:	d1f4      	bne.n	14ae <mscd_xfer_cb+0xd2>
  return tu_bit_test(dir, 7);
    14c4:	7b25      	ldrb	r5, [r4, #12]
    else if ( SCSI_CMD_WRITE_10 == cbw->command[0] && is_data_in(cbw->dir) )
    14c6:	09ed      	lsrs	r5, r5, #7
    14c8:	d0f1      	beq.n	14ae <mscd_xfer_cb+0xd2>
    14ca:	e7cb      	b.n	1464 <mscd_xfer_cb+0x88>
        if ( (p_cbw->total_bytes > 0 ) && !is_data_in(p_cbw->dir) )
    14cc:	b1b2      	cbz	r2, 14fc <mscd_xfer_cb+0x120>
  return tu_bit_test(dir, 7);
    14ce:	7b21      	ldrb	r1, [r4, #12]
        if ( (p_cbw->total_bytes > 0 ) && !is_data_in(p_cbw->dir) )
    14d0:	09c9      	lsrs	r1, r1, #7
    14d2:	d113      	bne.n	14fc <mscd_xfer_cb+0x120>
          if (p_cbw->total_bytes > sizeof(_mscd_buf))
    14d4:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
    14d8:	d901      	bls.n	14de <mscd_xfer_cb+0x102>
      status =  MSC_CSW_STATUS_FAILED;
    14da:	2001      	movs	r0, #1
    14dc:	e7c3      	b.n	1466 <mscd_xfer_cb+0x8a>
            TU_ASSERT( usbd_edpt_xfer(rhport, p_msc->ep_out, _mscd_buf, (uint16_t) p_msc->total_len) );
    14de:	496f      	ldr	r1, [pc, #444]	; (169c <mscd_xfer_cb+0x2c0>)
    14e0:	b292      	uxth	r2, r2
    14e2:	4638      	mov	r0, r7
    14e4:	f7ff fab8 	bl	a58 <usbd_edpt_xfer.constprop.0>
    14e8:	2800      	cmp	r0, #0
    14ea:	d1be      	bne.n	146a <mscd_xfer_cb+0x8e>
    14ec:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    14f0:	f8d3 3df0 	ldr.w	r3, [r3, #3568]	; 0xdf0
    14f4:	07de      	lsls	r6, r3, #31
    14f6:	d598      	bpl.n	142a <mscd_xfer_cb+0x4e>
        TU_ASSERT( send_csw(rhport, p_msc) );
    14f8:	be00      	bkpt	0x0000
    14fa:	e797      	b.n	142c <mscd_xfer_cb+0x50>
  switch ( scsi_cmd[0] )
    14fc:	2b25      	cmp	r3, #37	; 0x25
    14fe:	d807      	bhi.n	1510 <mscd_xfer_cb+0x134>
    1500:	2b19      	cmp	r3, #25
    1502:	d80f      	bhi.n	1524 <mscd_xfer_cb+0x148>
    1504:	2b03      	cmp	r3, #3
    1506:	f000 80d8 	beq.w	16ba <mscd_xfer_cb+0x2de>
    150a:	2b12      	cmp	r3, #18
    150c:	d06b      	beq.n	15e6 <mscd_xfer_cb+0x20a>
    150e:	b33b      	cbz	r3, 1560 <mscd_xfer_cb+0x184>
          if ( (resplen < 0) && (p_msc->sense_key == 0) )
    1510:	f894 303c 	ldrb.w	r3, [r4, #60]	; 0x3c
    1514:	2b00      	cmp	r3, #0
    1516:	d1e0      	bne.n	14da <mscd_xfer_cb+0xfe>
  _mscd_itf.sense_key           = sense_key;
    1518:	f242 0205 	movw	r2, #8197	; 0x2005
    151c:	87a2      	strh	r2, [r4, #60]	; 0x3c
  _mscd_itf.add_sense_qualifier = add_sense_qualifier;
    151e:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
    1522:	e7da      	b.n	14da <mscd_xfer_cb+0xfe>
  switch ( scsi_cmd[0] )
    1524:	3b1a      	subs	r3, #26
    1526:	2b0b      	cmp	r3, #11
    1528:	d8f2      	bhi.n	1510 <mscd_xfer_cb+0x134>
    152a:	a201      	add	r2, pc, #4	; (adr r2, 1530 <mscd_xfer_cb+0x154>)
    152c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    1530:	000016b1 	.word	0x000016b1
    1534:	00001573 	.word	0x00001573
    1538:	00001511 	.word	0x00001511
    153c:	00001511 	.word	0x00001511
    1540:	00001511 	.word	0x00001511
    1544:	00001511 	.word	0x00001511
    1548:	00001511 	.word	0x00001511
    154c:	00001511 	.word	0x00001511
    1550:	00001511 	.word	0x00001511
    1554:	000015b9 	.word	0x000015b9
    1558:	00001511 	.word	0x00001511
    155c:	00001591 	.word	0x00001591
  if (ejected) {
    1560:	4a4f      	ldr	r2, [pc, #316]	; (16a0 <mscd_xfer_cb+0x2c4>)
    1562:	7812      	ldrb	r2, [r2, #0]
    1564:	b16a      	cbz	r2, 1582 <mscd_xfer_cb+0x1a6>
  _mscd_itf.sense_key           = sense_key;
    1566:	f643 2202 	movw	r2, #14850	; 0x3a02
    156a:	87a2      	strh	r2, [r4, #60]	; 0x3c
  _mscd_itf.add_sense_qualifier = add_sense_qualifier;
    156c:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
    1570:	e7ce      	b.n	1510 <mscd_xfer_cb+0x134>
        if ( !tud_msc_start_stop_cb(lun, start_stop->power_condition, start_stop->start, start_stop->load_eject) )
    1572:	7ce3      	ldrb	r3, [r4, #19]
  if ( load_eject )
    1574:	079d      	lsls	r5, r3, #30
    1576:	d504      	bpl.n	1582 <mscd_xfer_cb+0x1a6>
    if (start)
    1578:	07d8      	lsls	r0, r3, #31
    157a:	d402      	bmi.n	1582 <mscd_xfer_cb+0x1a6>
      ejected = true;
    157c:	4b48      	ldr	r3, [pc, #288]	; (16a0 <mscd_xfer_cb+0x2c4>)
    157e:	2201      	movs	r2, #1
    1580:	701a      	strb	r2, [r3, #0]
            if (p_cbw->total_bytes)
    1582:	68a3      	ldr	r3, [r4, #8]
    1584:	2b00      	cmp	r3, #0
    1586:	d1a8      	bne.n	14da <mscd_xfer_cb+0xfe>
          p_msc->stage = MSC_STAGE_STATUS;
    1588:	2302      	movs	r3, #2
    158a:	f884 3030 	strb.w	r3, [r4, #48]	; 0x30
    158e:	e76c      	b.n	146a <mscd_xfer_cb+0x8e>
  memcpy(dest, src, count);
    1590:	4b42      	ldr	r3, [pc, #264]	; (169c <mscd_xfer_cb+0x2c0>)
    1592:	f04f 6170 	mov.w	r1, #251658240	; 0xf000000
    1596:	f44f 3200 	mov.w	r2, #131072	; 0x20000
    159a:	e9c3 1200 	strd	r1, r2, [r3]
    159e:	2008      	movs	r0, #8
            if ( p_cbw->total_bytes == 0 )
    15a0:	68a2      	ldr	r2, [r4, #8]
    15a2:	2a00      	cmp	r2, #0
    15a4:	d099      	beq.n	14da <mscd_xfer_cb+0xfe>
TU_ATTR_ALWAYS_INLINE static inline uint32_t tu_min32 (uint32_t x, uint32_t y) { return (x < y) ? x : y; }
    15a6:	4282      	cmp	r2, r0
    15a8:	bf28      	it	cs
    15aa:	4602      	movcs	r2, r0
              p_msc->total_len = tu_min32((uint32_t) resplen, p_cbw->total_bytes);
    15ac:	6362      	str	r2, [r4, #52]	; 0x34
              TU_ASSERT( usbd_edpt_xfer(rhport, p_msc->ep_in, _mscd_buf, (uint16_t) p_msc->total_len) );
    15ae:	493b      	ldr	r1, [pc, #236]	; (169c <mscd_xfer_cb+0x2c0>)
    15b0:	f894 002e 	ldrb.w	r0, [r4, #46]	; 0x2e
    15b4:	b292      	uxth	r2, r2
    15b6:	e795      	b.n	14e4 <mscd_xfer_cb+0x108>
      scsi_read_format_capacity_data_t read_fmt_capa =
    15b8:	2200      	movs	r2, #0
    15ba:	9207      	str	r2, [sp, #28]
    15bc:	f8ad 2024 	strh.w	r2, [sp, #36]	; 0x24
  memcpy(dest, src, count);
    15c0:	2208      	movs	r2, #8
    15c2:	f88d 201f 	strb.w	r2, [sp, #31]
    15c6:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    15ca:	9208      	str	r2, [sp, #32]
    15cc:	2202      	movs	r2, #2
    15ce:	ab07      	add	r3, sp, #28
    15d0:	f88d 2024 	strb.w	r2, [sp, #36]	; 0x24
    15d4:	f8ad 2026 	strh.w	r2, [sp, #38]	; 0x26
    15d8:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
    15dc:	4d2f      	ldr	r5, [pc, #188]	; (169c <mscd_xfer_cb+0x2c0>)
    15de:	e885 0007 	stmia.w	r5, {r0, r1, r2}
          else if (resplen == 0)
    15e2:	200c      	movs	r0, #12
    15e4:	e7dc      	b.n	15a0 <mscd_xfer_cb+0x1c4>
      scsi_inquiry_resp_t inquiry_rsp =
    15e6:	2300      	movs	r3, #0
    15e8:	e9cd 3307 	strd	r3, r3, [sp, #28]
    15ec:	2380      	movs	r3, #128	; 0x80
    15ee:	f88d 301d 	strb.w	r3, [sp, #29]
    15f2:	2302      	movs	r3, #2
    15f4:	f88d 301e 	strb.w	r3, [sp, #30]
    15f8:	f88d 301f 	strb.w	r3, [sp, #31]
      memset(inquiry_rsp.vendor_id  , ' ', sizeof(inquiry_rsp.vendor_id));
    15fc:	f04f 3520 	mov.w	r5, #538976288	; 0x20202020
      scsi_inquiry_resp_t inquiry_rsp =
    1600:	231f      	movs	r3, #31
      memset(inquiry_rsp.product_id , ' ', sizeof(inquiry_rsp.product_id));
    1602:	2210      	movs	r2, #16
    1604:	2120      	movs	r1, #32
    1606:	a80b      	add	r0, sp, #44	; 0x2c
      scsi_inquiry_resp_t inquiry_rsp =
    1608:	f88d 3020 	strb.w	r3, [sp, #32]
      memset(inquiry_rsp.vendor_id  , ' ', sizeof(inquiry_rsp.vendor_id));
    160c:	e9cd 5509 	strd	r5, r5, [sp, #36]	; 0x24
      memset(inquiry_rsp.product_id , ' ', sizeof(inquiry_rsp.product_id));
    1610:	f001 fa08 	bl	2a24 <memset>
  const char vid[] = "TinyUSB";
    1614:	4a23      	ldr	r2, [pc, #140]	; (16a4 <mscd_xfer_cb+0x2c8>)
      memset(inquiry_rsp.product_rev, ' ', sizeof(inquiry_rsp.product_rev));
    1616:	950f      	str	r5, [sp, #60]	; 0x3c
    1618:	6810      	ldr	r0, [r2, #0]
    161a:	6851      	ldr	r1, [r2, #4]
    161c:	ab01      	add	r3, sp, #4
    161e:	c303      	stmia	r3!, {r0, r1}
  const char pid[] = "Mass Storage";
    1620:	4b21      	ldr	r3, [pc, #132]	; (16a8 <mscd_xfer_cb+0x2cc>)
    1622:	aa03      	add	r2, sp, #12
    1624:	f103 0708 	add.w	r7, r3, #8
    1628:	4616      	mov	r6, r2
    162a:	6818      	ldr	r0, [r3, #0]
    162c:	6859      	ldr	r1, [r3, #4]
    162e:	4615      	mov	r5, r2
    1630:	c503      	stmia	r5!, {r0, r1}
    1632:	3308      	adds	r3, #8
    1634:	42bb      	cmp	r3, r7
    1636:	462a      	mov	r2, r5
    1638:	d1f7      	bne.n	162a <mscd_xfer_cb+0x24e>
    163a:	6818      	ldr	r0, [r3, #0]
    163c:	791b      	ldrb	r3, [r3, #4]
    163e:	6028      	str	r0, [r5, #0]
    1640:	712b      	strb	r3, [r5, #4]
  memcpy(vendor_id  , vid, strlen(vid));
    1642:	a801      	add	r0, sp, #4
  const char rev[] = "1.0";
    1644:	4b19      	ldr	r3, [pc, #100]	; (16ac <mscd_xfer_cb+0x2d0>)
    1646:	9300      	str	r3, [sp, #0]
  memcpy(vendor_id  , vid, strlen(vid));
    1648:	f7fe fe10 	bl	26c <strlen>
    164c:	a901      	add	r1, sp, #4
    164e:	4602      	mov	r2, r0
    1650:	a809      	add	r0, sp, #36	; 0x24
    1652:	f001 f9ef 	bl	2a34 <memcpy>
  memcpy(product_id , pid, strlen(pid));
    1656:	4630      	mov	r0, r6
    1658:	f7fe fe08 	bl	26c <strlen>
    165c:	4631      	mov	r1, r6
    165e:	4602      	mov	r2, r0
    1660:	a80b      	add	r0, sp, #44	; 0x2c
    1662:	f001 f9e7 	bl	2a34 <memcpy>
  memcpy(product_rev, rev, strlen(rev));
    1666:	4668      	mov	r0, sp
    1668:	f7fe fe00 	bl	26c <strlen>
    166c:	ad07      	add	r5, sp, #28
    166e:	4602      	mov	r2, r0
    1670:	4669      	mov	r1, sp
    1672:	a80f      	add	r0, sp, #60	; 0x3c
    1674:	f001 f9de 	bl	2a34 <memcpy>
    1678:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    167a:	4e08      	ldr	r6, [pc, #32]	; (169c <mscd_xfer_cb+0x2c0>)
    167c:	c60f      	stmia	r6!, {r0, r1, r2, r3}
    167e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    1680:	c60f      	stmia	r6!, {r0, r1, r2, r3}
    1682:	682b      	ldr	r3, [r5, #0]
    1684:	6033      	str	r3, [r6, #0]
      resplen = sizeof(inquiry_rsp);
    1686:	2024      	movs	r0, #36	; 0x24
    1688:	e78a      	b.n	15a0 <mscd_xfer_cb+0x1c4>
    168a:	bf00      	nop
    168c:	20002428 	.word	0x20002428
    1690:	43425355 	.word	0x43425355
    1694:	53425355 	.word	0x53425355
    1698:	200024a8 	.word	0x200024a8
    169c:	20002228 	.word	0x20002228
    16a0:	200025a0 	.word	0x200025a0
    16a4:	00002a8c 	.word	0x00002a8c
    16a8:	00002a94 	.word	0x00002a94
    16ac:	00302e31 	.word	0x00302e31
    16b0:	4b62      	ldr	r3, [pc, #392]	; (183c <mscd_xfer_cb+0x460>)
    16b2:	2203      	movs	r2, #3
    16b4:	601a      	str	r2, [r3, #0]
      resplen = sizeof(mode_resp);
    16b6:	2004      	movs	r0, #4
    16b8:	e772      	b.n	15a0 <mscd_xfer_cb+0x1c4>
      sense_rsp.sense_key           = (uint8_t) (p_msc->sense_key & 0x0F);
    16ba:	f894 503c 	ldrb.w	r5, [r4, #60]	; 0x3c
      sense_rsp.add_sense_qualifier = p_msc->add_sense_qualifier;
    16be:	f894 603e 	ldrb.w	r6, [r4, #62]	; 0x3e
      sense_rsp.add_sense_code      = p_msc->add_sense_code;
    16c2:	f894 803d 	ldrb.w	r8, [r4, #61]	; 0x3d
          int32_t resplen = proc_builtin_scsi(p_cbw->lun, p_cbw->command, _mscd_buf, sizeof(_mscd_buf));
    16c6:	7b67      	ldrb	r7, [r4, #13]
      scsi_sense_fixed_resp_t sense_rsp =
    16c8:	2212      	movs	r2, #18
    16ca:	2100      	movs	r1, #0
    16cc:	a807      	add	r0, sp, #28
    16ce:	f001 f9a9 	bl	2a24 <memset>
    16d2:	23f0      	movs	r3, #240	; 0xf0
    16d4:	f88d 301c 	strb.w	r3, [sp, #28]
      sense_rsp.sense_key           = (uint8_t) (p_msc->sense_key & 0x0F);
    16d8:	f005 050f 	and.w	r5, r5, #15
    16dc:	230a      	movs	r3, #10
    16de:	f88d 501e 	strb.w	r5, [sp, #30]
    16e2:	f88d 6029 	strb.w	r6, [sp, #41]	; 0x29
    16e6:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
    16ea:	f88d 8028 	strb.w	r8, [sp, #40]	; 0x28
    16ee:	ad07      	add	r5, sp, #28
    16f0:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    16f2:	4e52      	ldr	r6, [pc, #328]	; (183c <mscd_xfer_cb+0x460>)
    16f4:	c60f      	stmia	r6!, {r0, r1, r2, r3}
    16f6:	682b      	ldr	r3, [r5, #0]
    16f8:	8033      	strh	r3, [r6, #0]
      if (tud_msc_request_sense_cb)
    16fa:	4b51      	ldr	r3, [pc, #324]	; (1840 <mscd_xfer_cb+0x464>)
    16fc:	b183      	cbz	r3, 1720 <mscd_xfer_cb+0x344>
        resplen = tud_msc_request_sense_cb(lun, buffer, (uint16_t) bufsize);
    16fe:	f44f 7200 	mov.w	r2, #512	; 0x200
    1702:	f1a6 0110 	sub.w	r1, r6, #16
    1706:	4638      	mov	r0, r7
    1708:	f3af 8000 	nop.w
  _mscd_itf.sense_key           = sense_key;
    170c:	2300      	movs	r3, #0
          if ( (resplen < 0) && (p_msc->sense_key == 0) )
    170e:	4298      	cmp	r0, r3
  _mscd_itf.sense_key           = sense_key;
    1710:	87a3      	strh	r3, [r4, #60]	; 0x3c
  _mscd_itf.add_sense_qualifier = add_sense_qualifier;
    1712:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
          if ( (resplen < 0) && (p_msc->sense_key == 0) )
    1716:	f6ff aefb 	blt.w	1510 <mscd_xfer_cb+0x134>
          else if (resplen == 0)
    171a:	f43f af32 	beq.w	1582 <mscd_xfer_cb+0x1a6>
    171e:	e73f      	b.n	15a0 <mscd_xfer_cb+0x1c4>
      resplen = sizeof(sense_rsp);
    1720:	2012      	movs	r0, #18
    1722:	e7f3      	b.n	170c <mscd_xfer_cb+0x330>
      if (SCSI_CMD_READ_10 == p_cbw->command[0])
    1724:	7be7      	ldrb	r7, [r4, #15]
        p_msc->xferred_len += xferred_bytes;
    1726:	6ba2      	ldr	r2, [r4, #56]	; 0x38
      if (SCSI_CMD_READ_10 == p_cbw->command[0])
    1728:	2f28      	cmp	r7, #40	; 0x28
    172a:	d106      	bne.n	173a <mscd_xfer_cb+0x35e>
        if ( p_msc->xferred_len >= p_msc->total_len )
    172c:	6b63      	ldr	r3, [r4, #52]	; 0x34
        p_msc->xferred_len += xferred_bytes;
    172e:	4415      	add	r5, r2
        if ( p_msc->xferred_len >= p_msc->total_len )
    1730:	429d      	cmp	r5, r3
        p_msc->xferred_len += xferred_bytes;
    1732:	63a5      	str	r5, [r4, #56]	; 0x38
        if ( p_msc->xferred_len >= p_msc->total_len )
    1734:	f4bf af28 	bcs.w	1588 <mscd_xfer_cb+0x1ac>
    1738:	e6bf      	b.n	14ba <mscd_xfer_cb+0xde>
      else if (SCSI_CMD_WRITE_10 == p_cbw->command[0])
    173a:	2f2a      	cmp	r7, #42	; 0x2a
    173c:	d12d      	bne.n	179a <mscd_xfer_cb+0x3be>
  return tu_ntohs(block_count);
    173e:	8ae0      	ldrh	r0, [r4, #22]
    1740:	ba40      	rev16	r0, r0
    1742:	b280      	uxth	r0, r0
  if (block_count == 0) return 0;
    1744:	b118      	cbz	r0, 174e <mscd_xfer_cb+0x372>
  return (uint16_t) (cbw->total_bytes / block_count);
    1746:	68a3      	ldr	r3, [r4, #8]
    1748:	fbb3 f0f0 	udiv	r0, r3, r0
    174c:	b280      	uxth	r0, r0
TU_ATTR_ALWAYS_INLINE static inline uint32_t tu_unaligned_read32  (const void* mem) { return *((uint32_t const *) mem); }
    174e:	f8d4 6011 	ldr.w	r6, [r4, #17]

  // block size already verified not zero
  uint16_t const block_sz = rdwr10_get_blocksize(p_cbw);

  // Adjust lba with transferred bytes
  uint32_t const lba = rdwr10_get_lba(p_cbw->command) + (p_msc->xferred_len / block_sz);
    1752:	fbb2 f1f0 	udiv	r1, r2, r0
  return tu_ntohl(lba);
    1756:	ba36      	rev	r6, r6
  uint32_t const lba = rdwr10_get_lba(p_cbw->command) + (p_msc->xferred_len / block_sz);
    1758:	440e      	add	r6, r1
int32_t tud_msc_write10_cb(uint8_t lun, uint32_t lba, uint32_t offset, uint8_t* buffer, uint32_t bufsize)
{
  (void) lun;

  // out of ramdisk
  if ( lba >= DISK_BLOCK_NUM ) return -1;
    175a:	2e0f      	cmp	r6, #15

  // Invoke callback to consume new data
  uint32_t const offset = p_msc->xferred_len % block_sz;
    175c:	fb00 2011 	mls	r0, r0, r1, r2
    1760:	d907      	bls.n	1772 <mscd_xfer_cb+0x396>
  {
    // negative means error -> failed this scsi op
    TU_LOG(MSC_DEBUG, "  tud_msc_write10_cb() return -1\r\n");

    // update actual byte before failed
    p_msc->xferred_len += xferred_bytes;
    1762:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    1764:	442b      	add	r3, r5
    1766:	63a3      	str	r3, [r4, #56]	; 0x38
  _mscd_itf.sense_key           = sense_key;
    1768:	f643 2302 	movw	r3, #14850	; 0x3a02
    176c:	87a3      	strh	r3, [r4, #60]	; 0x3c
  _mscd_itf.add_sense_qualifier = add_sense_qualifier;
    176e:	2300      	movs	r3, #0
    1770:	e6d5      	b.n	151e <mscd_xfer_cb+0x142>

#ifndef CFG_EXAMPLE_MSC_READONLY
  uint8_t* addr = msc_disk[lba] + offset;
  memcpy(addr, buffer, bufsize);
    1772:	4b34      	ldr	r3, [pc, #208]	; (1844 <mscd_xfer_cb+0x468>)
    1774:	4931      	ldr	r1, [pc, #196]	; (183c <mscd_xfer_cb+0x460>)
  uint8_t* addr = msc_disk[lba] + offset;
    1776:	eb00 2046 	add.w	r0, r0, r6, lsl #9
  memcpy(addr, buffer, bufsize);
    177a:	462a      	mov	r2, r5
    177c:	4418      	add	r0, r3
    177e:	f001 f959 	bl	2a34 <memcpy>
  if ( nbytes < 0 )
    1782:	2d00      	cmp	r5, #0
    1784:	dbed      	blt.n	1762 <mscd_xfer_cb+0x386>
      dcd_event_xfer_complete(rhport, p_msc->ep_out, left_over, XFER_RESULT_SUCCESS, false);
    }
    else
    {
      // Application consume all bytes in our buffer
      p_msc->xferred_len += xferred_bytes;
    1786:	6ba2      	ldr	r2, [r4, #56]	; 0x38

      if ( p_msc->xferred_len >= p_msc->total_len )
    1788:	6b63      	ldr	r3, [r4, #52]	; 0x34
      p_msc->xferred_len += xferred_bytes;
    178a:	4415      	add	r5, r2
      if ( p_msc->xferred_len >= p_msc->total_len )
    178c:	429d      	cmp	r5, r3
      p_msc->xferred_len += xferred_bytes;
    178e:	63a5      	str	r5, [r4, #56]	; 0x38
      if ( p_msc->xferred_len >= p_msc->total_len )
    1790:	f4bf aefa 	bcs.w	1588 <mscd_xfer_cb+0x1ac>
            proc_write10_cmd(rhport, p_msc);
    1794:	f7ff fa6c 	bl	c70 <proc_write10_cmd.constprop.0.isra.0>
    1798:	e667      	b.n	146a <mscd_xfer_cb+0x8e>
  return tu_bit_test(dir, 7);
    179a:	7b23      	ldrb	r3, [r4, #12]
        p_msc->xferred_len += xferred_bytes;
    179c:	4415      	add	r5, r2
        if ( !is_data_in(p_cbw->dir) )
    179e:	09db      	lsrs	r3, r3, #7
        p_msc->xferred_len += xferred_bytes;
    17a0:	63a5      	str	r5, [r4, #56]	; 0x38
        if ( !is_data_in(p_cbw->dir) )
    17a2:	d107      	bne.n	17b4 <mscd_xfer_cb+0x3d8>
  _mscd_itf.sense_key           = sense_key;
    17a4:	f242 0205 	movw	r2, #8197	; 0x2005
            fail_scsi_op(rhport, p_msc, MSC_CSW_STATUS_FAILED);
    17a8:	4630      	mov	r0, r6
  _mscd_itf.sense_key           = sense_key;
    17aa:	87a2      	strh	r2, [r4, #60]	; 0x3c
  _mscd_itf.add_sense_qualifier = add_sense_qualifier;
    17ac:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
            fail_scsi_op(rhport, p_msc, MSC_CSW_STATUS_FAILED);
    17b0:	f7fe fff2 	bl	798 <fail_scsi_op.constprop.0.isra.0>
        if ( p_msc->xferred_len >= p_msc->total_len )
    17b4:	e9d4 320d 	ldrd	r3, r2, [r4, #52]	; 0x34
    17b8:	429a      	cmp	r2, r3
    17ba:	f4bf aee5 	bcs.w	1588 <mscd_xfer_cb+0x1ac>
          TU_BREAKPOINT();
    17be:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    17c2:	f8d3 3df0 	ldr.w	r3, [r3, #3568]	; 0xdf0
    17c6:	07da      	lsls	r2, r3, #31
    17c8:	f57f ae4f 	bpl.w	146a <mscd_xfer_cb+0x8e>
    17cc:	be00      	bkpt	0x0000
    17ce:	e64c      	b.n	146a <mscd_xfer_cb+0x8e>
      if( (ep_addr == p_msc->ep_in) && (xferred_bytes == sizeof(msc_csw_t)) )
    17d0:	f894 302e 	ldrb.w	r3, [r4, #46]	; 0x2e
    17d4:	428b      	cmp	r3, r1
    17d6:	f47f ae48 	bne.w	146a <mscd_xfer_cb+0x8e>
    17da:	2d0d      	cmp	r5, #13
    17dc:	f47f ae45 	bne.w	146a <mscd_xfer_cb+0x8e>
        switch(p_cbw->command[0])
    17e0:	7be3      	ldrb	r3, [r4, #15]
    17e2:	2b28      	cmp	r3, #40	; 0x28
    17e4:	d009      	beq.n	17fa <mscd_xfer_cb+0x41e>
    17e6:	2b2a      	cmp	r3, #42	; 0x2a
    17e8:	d014      	beq.n	1814 <mscd_xfer_cb+0x438>
            if ( tud_msc_scsi_complete_cb ) tud_msc_scsi_complete_cb(p_cbw->lun, p_cbw->command);
    17ea:	4b17      	ldr	r3, [pc, #92]	; (1848 <mscd_xfer_cb+0x46c>)
    17ec:	b153      	cbz	r3, 1804 <mscd_xfer_cb+0x428>
    17ee:	7b60      	ldrb	r0, [r4, #13]
    17f0:	f104 010f 	add.w	r1, r4, #15
    17f4:	f3af 8000 	nop.w
    17f8:	e004      	b.n	1804 <mscd_xfer_cb+0x428>
            if ( tud_msc_read10_complete_cb ) tud_msc_read10_complete_cb(p_cbw->lun);
    17fa:	4b14      	ldr	r3, [pc, #80]	; (184c <mscd_xfer_cb+0x470>)
    17fc:	b113      	cbz	r3, 1804 <mscd_xfer_cb+0x428>
    17fe:	7b60      	ldrb	r0, [r4, #13]
    1800:	f3af 8000 	nop.w
  p_msc->stage = MSC_STAGE_CMD;
    1804:	2300      	movs	r3, #0
  return usbd_edpt_xfer(rhport, p_msc->ep_out, (uint8_t*) &p_msc->cbw, sizeof(msc_cbw_t));
    1806:	4912      	ldr	r1, [pc, #72]	; (1850 <mscd_xfer_cb+0x474>)
    1808:	f894 002f 	ldrb.w	r0, [r4, #47]	; 0x2f
  p_msc->stage = MSC_STAGE_CMD;
    180c:	f884 3030 	strb.w	r3, [r4, #48]	; 0x30
  return usbd_edpt_xfer(rhport, p_msc->ep_out, (uint8_t*) &p_msc->cbw, sizeof(msc_cbw_t));
    1810:	221f      	movs	r2, #31
    1812:	e667      	b.n	14e4 <mscd_xfer_cb+0x108>
            if ( tud_msc_write10_complete_cb ) tud_msc_write10_complete_cb(p_cbw->lun);
    1814:	4b0f      	ldr	r3, [pc, #60]	; (1854 <mscd_xfer_cb+0x478>)
    1816:	2b00      	cmp	r3, #0
    1818:	d0f4      	beq.n	1804 <mscd_xfer_cb+0x428>
    181a:	7b60      	ldrb	r0, [r4, #13]
    181c:	f3af 8000 	nop.w
    1820:	e7f0      	b.n	1804 <mscd_xfer_cb+0x428>
  p_msc->csw.data_residue = p_msc->cbw.total_bytes - p_msc->xferred_len;
    1822:	1a9b      	subs	r3, r3, r2
    1824:	62a3      	str	r3, [r4, #40]	; 0x28
  return usbd_edpt_xfer(rhport, p_msc->ep_in , (uint8_t*) &p_msc->csw, sizeof(msc_csw_t));
    1826:	490c      	ldr	r1, [pc, #48]	; (1858 <mscd_xfer_cb+0x47c>)
  p_msc->stage = MSC_STAGE_STATUS_SENT;
    1828:	2303      	movs	r3, #3
  return usbd_edpt_xfer(rhport, p_msc->ep_in , (uint8_t*) &p_msc->csw, sizeof(msc_csw_t));
    182a:	220d      	movs	r2, #13
  p_msc->stage = MSC_STAGE_STATUS_SENT;
    182c:	f884 3030 	strb.w	r3, [r4, #48]	; 0x30
  return usbd_edpt_xfer(rhport, p_msc->ep_in , (uint8_t*) &p_msc->csw, sizeof(msc_csw_t));
    1830:	f7ff f912 	bl	a58 <usbd_edpt_xfer.constprop.0>
        TU_ASSERT( send_csw(rhport, p_msc) );
    1834:	2800      	cmp	r0, #0
    1836:	f47f ade5 	bne.w	1404 <mscd_xfer_cb+0x28>
    183a:	e657      	b.n	14ec <mscd_xfer_cb+0x110>
    183c:	20002228 	.word	0x20002228
    1840:	00000000 	.word	0x00000000
    1844:	2000001c 	.word	0x2000001c
	...
    1850:	20002428 	.word	0x20002428
    1854:	00000000 	.word	0x00000000
    1858:	20002448 	.word	0x20002448

0000185c <usbd_edpt_open.constprop.0>:
bool usbd_edpt_open(uint8_t rhport, tusb_desc_endpoint_t const * desc_ep)
    185c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  TU_ASSERT(tu_edpt_number(desc_ep->bEndpointAddress) < CFG_TUD_ENDPPOINT_MAX);
    1860:	7886      	ldrb	r6, [r0, #2]
    1862:	f016 0478 	ands.w	r4, r6, #120	; 0x78
bool usbd_edpt_open(uint8_t rhport, tusb_desc_endpoint_t const * desc_ep)
    1866:	b09c      	sub	sp, #112	; 0x70
  TU_ASSERT(tu_edpt_number(desc_ep->bEndpointAddress) < CFG_TUD_ENDPPOINT_MAX);
    1868:	d00a      	beq.n	1880 <usbd_edpt_open.constprop.0+0x24>
  TU_ASSERT(addr);
    186a:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    186e:	f8d3 3df0 	ldr.w	r3, [r3, #3568]	; 0xdf0
    1872:	07db      	lsls	r3, r3, #31
    1874:	d500      	bpl.n	1878 <usbd_edpt_open.constprop.0+0x1c>
    1876:	be00      	bkpt	0x0000
    1878:	2000      	movs	r0, #0
}
    187a:	b01c      	add	sp, #112	; 0x70
    187c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
bool tu_edpt_validate(tusb_desc_endpoint_t const * desc_ep, tusb_speed_t speed)
{
  uint16_t const max_packet_size = tu_edpt_packet_size(desc_ep);
  TU_LOG2("  Open EP %02X with Size = %u\r\n", desc_ep->bEndpointAddress, max_packet_size);

  switch (desc_ep->bmAttributes.xfer)
    1880:	78c5      	ldrb	r5, [r0, #3]
  TU_ASSERT(tu_edpt_validate(desc_ep, (tusb_speed_t) _usbd_dev.speed));
    1882:	4b71      	ldr	r3, [pc, #452]	; (1a48 <usbd_edpt_open.constprop.0+0x1ec>)
  return (uint8_t)(num | (dir ? TUSB_DIR_IN_MASK : 0));
}

TU_ATTR_ALWAYS_INLINE static inline uint16_t tu_edpt_packet_size(tusb_desc_endpoint_t const* desc_ep)
{
  return tu_le16toh(desc_ep->wMaxPacketSize) & TU_GENMASK(10, 0);
    1884:	8882      	ldrh	r2, [r0, #4]
    1886:	789b      	ldrb	r3, [r3, #2]
    1888:	f005 0503 	and.w	r5, r5, #3
    188c:	2d02      	cmp	r5, #2
    188e:	f3c2 020a 	ubfx	r2, r2, #0, #11
    1892:	d00c      	beq.n	18ae <usbd_edpt_open.constprop.0+0x52>
    1894:	2d03      	cmp	r5, #3
    1896:	f000 80ab 	beq.w	19f0 <usbd_edpt_open.constprop.0+0x194>
    189a:	2d01      	cmp	r5, #1
    189c:	d1e5      	bne.n	186a <usbd_edpt_open.constprop.0+0xe>
  {
    case TUSB_XFER_ISOCHRONOUS:
    {
      uint16_t const spec_size = (speed == TUSB_SPEED_HIGH ? 1024 : 1023);
    189e:	2b02      	cmp	r3, #2
    18a0:	f240 33ff 	movw	r3, #1023	; 0x3ff
    18a4:	bf08      	it	eq
    18a6:	f44f 6380 	moveq.w	r3, #1024	; 0x400
    break;

    case TUSB_XFER_INTERRUPT:
    {
      uint16_t const spec_size = (speed == TUSB_SPEED_HIGH ? 1024 : 64);
      TU_ASSERT(max_packet_size <= spec_size);
    18aa:	429a      	cmp	r2, r3
    18ac:	e00d      	b.n	18ca <usbd_edpt_open.constprop.0+0x6e>
      if (speed == TUSB_SPEED_HIGH)
    18ae:	2b02      	cmp	r3, #2
    18b0:	d10a      	bne.n	18c8 <usbd_edpt_open.constprop.0+0x6c>
        TU_ASSERT(max_packet_size == 512);
    18b2:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
    18b6:	d009      	beq.n	18cc <usbd_edpt_open.constprop.0+0x70>
      TU_ASSERT(max_packet_size <= spec_size);
    18b8:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    18bc:	f8d3 3df0 	ldr.w	r3, [r3, #3568]	; 0xdf0
    18c0:	07dd      	lsls	r5, r3, #31
    18c2:	d5d2      	bpl.n	186a <usbd_edpt_open.constprop.0+0xe>
    18c4:	be00      	bkpt	0x0000
    18c6:	e7d0      	b.n	186a <usbd_edpt_open.constprop.0+0xe>
        TU_ASSERT(max_packet_size <= 64);
    18c8:	2a40      	cmp	r2, #64	; 0x40
      TU_ASSERT(max_packet_size <= spec_size);
    18ca:	d8f5      	bhi.n	18b8 <usbd_edpt_open.constprop.0+0x5c>
  return (uint8_t)(addr & (~TUSB_DIR_IN_MASK));
    18cc:	f006 077f 	and.w	r7, r6, #127	; 0x7f
  return (addr & TUSB_DIR_IN_MASK) ? TUSB_DIR_IN : TUSB_DIR_OUT;
    18d0:	09f6      	lsrs	r6, r6, #7
  pipe_state_t *pipe = &_dcd.pipe[dir_in][epn - 1];
    18d2:	1e7b      	subs	r3, r7, #1
  pipe->buf       = NULL;
    18d4:	ebc6 01c6 	rsb	r1, r6, r6, lsl #3
    18d8:	4419      	add	r1, r3
    18da:	1c88      	adds	r0, r1, #2
    18dc:	495b      	ldr	r1, [pc, #364]	; (1a4c <usbd_edpt_open.constprop.0+0x1f0>)
    18de:	eb01 01c0 	add.w	r1, r1, r0, lsl #3
    18e2:	2000      	movs	r0, #0
    18e4:	70c8      	strb	r0, [r1, #3]
    18e6:	7108      	strb	r0, [r1, #4]
    18e8:	7148      	strb	r0, [r1, #5]
    18ea:	7188      	strb	r0, [r1, #6]
  pipe->length    = 0;
    18ec:	71c8      	strb	r0, [r1, #7]
    18ee:	7208      	strb	r0, [r1, #8]
  pipe->remaining = 0;
    18f0:	7248      	strb	r0, [r1, #9]
    18f2:	7288      	strb	r0, [r1, #10]
  return regs + epnum_minus1;
    18f4:	4956      	ldr	r1, [pc, #344]	; (1a50 <usbd_edpt_open.constprop.0+0x1f4>)
    18f6:	0118      	lsls	r0, r3, #4
    18f8:	eb01 1303 	add.w	r3, r1, r3, lsl #4
  if (dir_in) {
    18fc:	2e00      	cmp	r6, #0
    18fe:	d07d      	beq.n	19fc <usbd_edpt_open.constprop.0+0x1a0>
    regs->TXCSRH = (xfer == TUSB_XFER_ISOCHRONOUS) ? USB_TXCSRH1_ISO : 0;
    1900:	2d01      	cmp	r5, #1
    regs->TXMAXP = mps;
    1902:	5242      	strh	r2, [r0, r1]
    regs->TXCSRH = (xfer == TUSB_XFER_ISOCHRONOUS) ? USB_TXCSRH1_ISO : 0;
    1904:	bf08      	it	eq
    1906:	2440      	moveq	r4, #64	; 0x40
    1908:	70dc      	strb	r4, [r3, #3]
    if (regs->TXCSRL & USB_TXCSRL1_TXRDY)
    190a:	7899      	ldrb	r1, [r3, #2]
    190c:	07cc      	lsls	r4, r1, #31
      regs->TXCSRL = USB_TXCSRL1_CLRDT | USB_TXCSRL1_FLUSH;
    190e:	bf4c      	ite	mi
    1910:	2148      	movmi	r1, #72	; 0x48
      regs->TXCSRL = USB_TXCSRL1_CLRDT;
    1912:	2140      	movpl	r1, #64	; 0x40
    1914:	7099      	strb	r1, [r3, #2]
    USB0->TXIE |= TU_BIT(epn);
    1916:	494f      	ldr	r1, [pc, #316]	; (1a54 <usbd_edpt_open.constprop.0+0x1f8>)
    1918:	2301      	movs	r3, #1
    191a:	88c8      	ldrh	r0, [r1, #6]
    191c:	40bb      	lsls	r3, r7
    191e:	4303      	orrs	r3, r0
    1920:	b29b      	uxth	r3, r3
    1922:	80cb      	strh	r3, [r1, #6]
     optimisations using the logic "value was passed to __builtin_clz, so it
     is non-zero".
     ARM GCC 7.3 and possibly earlier will optimise this test away, leaving a
     single CLZ instruction.
   */
  if (value == 0U)
    1924:	2a00      	cmp	r2, #0
    1926:	d07d      	beq.n	1a24 <usbd_edpt_open.constprop.0+0x1c8>
  {
    return 32U;
  }
  return __builtin_clz(value);
    1928:	fab2 f482 	clz	r4, r2
  int size_in_log2_minus3 = 28 - TU_MIN(28, __CLZ((uint32_t)mps));
    192c:	2c1c      	cmp	r4, #28
    192e:	dc79      	bgt.n	1a24 <usbd_edpt_open.constprop.0+0x1c8>
    1930:	f1c4 041c 	rsb	r4, r4, #28
  if ((8u << size_in_log2_minus3) < mps) ++size_in_log2_minus3;
    1934:	2308      	movs	r3, #8
    1936:	fa03 f104 	lsl.w	r1, r3, r4
  unsigned num_blocks = 1;
    193a:	2501      	movs	r5, #1
  if ((8u << size_in_log2_minus3) < mps) ++size_in_log2_minus3;
    193c:	428a      	cmp	r2, r1
  free_blocks[0].beg = 64 / 8;
    193e:	9300      	str	r3, [sp, #0]
    USB0->EPIDX = i;
    1940:	f8df 8110 	ldr.w	r8, [pc, #272]	; 1a54 <usbd_edpt_open.constprop.0+0x1f8>
  free_blocks[0].end = (4 << 10) / 8; /* 4KiB / 8 bytes */
    1944:	f44f 7300 	mov.w	r3, #512	; 0x200
  if ((8u << size_in_log2_minus3) < mps) ++size_in_log2_minus3;
    1948:	bf88      	it	hi
    194a:	3401      	addhi	r4, #1
  free_blocks[0].end = (4 << 10) / 8; /* 4KiB / 8 bytes */
    194c:	9301      	str	r3, [sp, #4]
  for (int i = 1; i < TUP_DCD_ENDPOINT_MAX; ++i) {
    194e:	46a9      	mov	r9, r5
      num = update_free_block_list(free_blocks, num_blocks, addr, 1 << sft);
    1950:	46aa      	mov	sl, r5
    1952:	fa5f f389 	uxtb.w	r3, r9
    USB0->EPIDX = i;
    1956:	f888 300e 	strb.w	r3, [r8, #14]
    addr = USB0->TXFIFOADD;
    195a:	f8b8 2064 	ldrh.w	r2, [r8, #100]	; 0x64
    195e:	b292      	uxth	r2, r2
    if (addr) {
    1960:	b17a      	cbz	r2, 1982 <usbd_edpt_open.constprop.0+0x126>
      unsigned sz  = USB0->TXFIFOSZ;
    1962:	f898 3062 	ldrb.w	r3, [r8, #98]	; 0x62
      unsigned sft = (sz & USB_TXFIFOSZ_SIZE_M) + ((sz & USB_TXFIFOSZ_DPB) ? 1: 0);
    1966:	f3c3 1100 	ubfx	r1, r3, #4, #1
    196a:	f003 030f 	and.w	r3, r3, #15
    196e:	440b      	add	r3, r1
      num = update_free_block_list(free_blocks, num_blocks, addr, 1 << sft);
    1970:	fa0a f303 	lsl.w	r3, sl, r3
    1974:	4629      	mov	r1, r5
    1976:	4668      	mov	r0, sp
    1978:	f7fe fd82 	bl	480 <update_free_block_list>
      TU_ASSERT(-2 < num, 0);
    197c:	1c41      	adds	r1, r0, #1
    197e:	db9b      	blt.n	18b8 <usbd_edpt_open.constprop.0+0x5c>
      num_blocks += num;
    1980:	4405      	add	r5, r0
    addr = USB0->RXFIFOADD;
    1982:	f8b8 2066 	ldrh.w	r2, [r8, #102]	; 0x66
    1986:	b292      	uxth	r2, r2
    if (addr) {
    1988:	b17a      	cbz	r2, 19aa <usbd_edpt_open.constprop.0+0x14e>
      unsigned sz  = USB0->RXFIFOSZ;
    198a:	f898 3063 	ldrb.w	r3, [r8, #99]	; 0x63
      unsigned sft = (sz & USB_RXFIFOSZ_SIZE_M) + ((sz & USB_RXFIFOSZ_DPB) ? 1: 0);
    198e:	f3c3 1100 	ubfx	r1, r3, #4, #1
    1992:	f003 030f 	and.w	r3, r3, #15
    1996:	440b      	add	r3, r1
      num = update_free_block_list(free_blocks, num_blocks, addr, 1 << sft);
    1998:	fa0a f303 	lsl.w	r3, sl, r3
    199c:	4629      	mov	r1, r5
    199e:	4668      	mov	r0, sp
    19a0:	f7fe fd6e 	bl	480 <update_free_block_list>
      TU_ASSERT(-2 < num, 0);
    19a4:	1c42      	adds	r2, r0, #1
    19a6:	db87      	blt.n	18b8 <usbd_edpt_open.constprop.0+0x5c>
      num_blocks += num;
    19a8:	4405      	add	r5, r0
  for (int i = 1; i < TUP_DCD_ENDPOINT_MAX; ++i) {
    19aa:	f109 0901 	add.w	r9, r9, #1
    19ae:	f1b9 0f08 	cmp.w	r9, #8
    19b2:	d1ce      	bne.n	1952 <usbd_edpt_open.constprop.0+0xf6>
  uint_fast16_t size_in_8byte_unit = 1 << size_in_log2_minus3;
    19b4:	f04f 0c01 	mov.w	ip, #1
    19b8:	fa0c fc04 	lsl.w	ip, ip, r4
  free_block_t const *end = &free_blocks[num_blocks];
    19bc:	eb0d 05c5 	add.w	r5, sp, r5, lsl #3
  for (free_block_t const *cur = &free_blocks[0]; cur < end; ++cur) {
    19c0:	466b      	mov	r3, sp
  free_block_t const *min = NULL;
    19c2:	2100      	movs	r1, #0
    if (sz < min_sz) min = cur;
    19c4:	f64f 7efe 	movw	lr, #65534	; 0xfffe
  for (free_block_t const *cur = &free_blocks[0]; cur < end; ++cur) {
    19c8:	429d      	cmp	r5, r3
    19ca:	d82d      	bhi.n	1a28 <usbd_edpt_open.constprop.0+0x1cc>
  TU_ASSERT(min, 0);
    19cc:	2900      	cmp	r1, #0
    19ce:	f43f af73 	beq.w	18b8 <usbd_edpt_open.constprop.0+0x5c>
  return min->beg;
    19d2:	680a      	ldr	r2, [r1, #0]
  TU_ASSERT(addr);
    19d4:	2a00      	cmp	r2, #0
    19d6:	f43f af48 	beq.w	186a <usbd_edpt_open.constprop.0+0xe>
  USB0->EPIDX = epn;
    19da:	4b1e      	ldr	r3, [pc, #120]	; (1a54 <usbd_edpt_open.constprop.0+0x1f8>)
    USB0->TXFIFOADD = addr;
    19dc:	b292      	uxth	r2, r2
  USB0->EPIDX = epn;
    19de:	739f      	strb	r7, [r3, #14]
    USB0->TXFIFOSZ  = size_in_log2_minus3;
    19e0:	b2e4      	uxtb	r4, r4
  if (dir_in) {
    19e2:	b366      	cbz	r6, 1a3e <usbd_edpt_open.constprop.0+0x1e2>
    USB0->TXFIFOADD = addr;
    19e4:	f8a3 2064 	strh.w	r2, [r3, #100]	; 0x64
    USB0->TXFIFOSZ  = size_in_log2_minus3;
    19e8:	f883 4062 	strb.w	r4, [r3, #98]	; 0x62
  return true;
    19ec:	2001      	movs	r0, #1
    19ee:	e744      	b.n	187a <usbd_edpt_open.constprop.0+0x1e>
      uint16_t const spec_size = (speed == TUSB_SPEED_HIGH ? 1024 : 64);
    19f0:	2b02      	cmp	r3, #2
    19f2:	bf0c      	ite	eq
    19f4:	f44f 6380 	moveq.w	r3, #1024	; 0x400
    19f8:	2340      	movne	r3, #64	; 0x40
    19fa:	e756      	b.n	18aa <usbd_edpt_open.constprop.0+0x4e>
    regs->RXCSRH = (xfer == TUSB_XFER_ISOCHRONOUS) ? USB_RXCSRH1_ISO : 0;
    19fc:	2d01      	cmp	r5, #1
    19fe:	bf0c      	ite	eq
    1a00:	2140      	moveq	r1, #64	; 0x40
    1a02:	2100      	movne	r1, #0
    regs->RXMAXP = mps;
    1a04:	809a      	strh	r2, [r3, #4]
    regs->RXCSRH = (xfer == TUSB_XFER_ISOCHRONOUS) ? USB_RXCSRH1_ISO : 0;
    1a06:	71d9      	strb	r1, [r3, #7]
    if (regs->RXCSRL & USB_RXCSRL1_RXRDY)
    1a08:	7999      	ldrb	r1, [r3, #6]
    1a0a:	07c8      	lsls	r0, r1, #31
      regs->RXCSRL = USB_RXCSRL1_CLRDT | USB_RXCSRL1_FLUSH;
    1a0c:	bf4c      	ite	mi
    1a0e:	2190      	movmi	r1, #144	; 0x90
      regs->RXCSRL = USB_RXCSRL1_CLRDT;
    1a10:	2180      	movpl	r1, #128	; 0x80
    1a12:	7199      	strb	r1, [r3, #6]
    USB0->RXIE |= TU_BIT(epn);
    1a14:	490f      	ldr	r1, [pc, #60]	; (1a54 <usbd_edpt_open.constprop.0+0x1f8>)
    1a16:	2301      	movs	r3, #1
    1a18:	8908      	ldrh	r0, [r1, #8]
    1a1a:	40bb      	lsls	r3, r7
    1a1c:	4303      	orrs	r3, r0
    1a1e:	b29b      	uxth	r3, r3
    1a20:	810b      	strh	r3, [r1, #8]
    1a22:	e77f      	b.n	1924 <usbd_edpt_open.constprop.0+0xc8>
  int size_in_log2_minus3 = 28 - TU_MIN(28, __CLZ((uint32_t)mps));
    1a24:	2400      	movs	r4, #0
    1a26:	e785      	b.n	1934 <usbd_edpt_open.constprop.0+0xd8>
  return blk->end - blk->beg;
    1a28:	e9d3 2000 	ldrd	r2, r0, [r3]
    1a2c:	1a80      	subs	r0, r0, r2
    if (sz < size_in_8byte_unit) continue;
    1a2e:	4584      	cmp	ip, r0
    1a30:	d803      	bhi.n	1a3a <usbd_edpt_open.constprop.0+0x1de>
    if (size_in_8byte_unit == sz) return cur->beg;
    1a32:	d0cf      	beq.n	19d4 <usbd_edpt_open.constprop.0+0x178>
    if (sz < min_sz) min = cur;
    1a34:	4570      	cmp	r0, lr
    1a36:	bf98      	it	ls
    1a38:	4619      	movls	r1, r3
  for (free_block_t const *cur = &free_blocks[0]; cur < end; ++cur) {
    1a3a:	3308      	adds	r3, #8
    1a3c:	e7c4      	b.n	19c8 <usbd_edpt_open.constprop.0+0x16c>
    USB0->RXFIFOADD = addr;
    1a3e:	f8a3 2066 	strh.w	r2, [r3, #102]	; 0x66
    USB0->RXFIFOSZ  = size_in_log2_minus3;
    1a42:	f883 4063 	strb.w	r4, [r3, #99]	; 0x63
    1a46:	e7d1      	b.n	19ec <usbd_edpt_open.constprop.0+0x190>
    1a48:	200024a8 	.word	0x200024a8
    1a4c:	20002160 	.word	0x20002160
    1a50:	40050110 	.word	0x40050110
    1a54:	40050000 	.word	0x40050000

00001a58 <usbd_open_edpt_pair.constprop.0.isra.0>:
bool usbd_open_edpt_pair(uint8_t rhport, uint8_t const* p_desc, uint8_t ep_count, uint8_t xfer_type, uint8_t* ep_out, uint8_t* ep_in)
    1a58:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    1a5a:	4604      	mov	r4, r0
    1a5c:	460d      	mov	r5, r1
    1a5e:	4616      	mov	r6, r2
    1a60:	2702      	movs	r7, #2
    TU_ASSERT(TUSB_DESC_ENDPOINT == desc_ep->bDescriptorType && xfer_type == desc_ep->bmAttributes.xfer);
    1a62:	7863      	ldrb	r3, [r4, #1]
    1a64:	2b05      	cmp	r3, #5
    1a66:	d104      	bne.n	1a72 <usbd_open_edpt_pair.constprop.0.isra.0+0x1a>
    1a68:	78e3      	ldrb	r3, [r4, #3]
    1a6a:	f003 0303 	and.w	r3, r3, #3
    1a6e:	2b02      	cmp	r3, #2
    1a70:	d008      	beq.n	1a84 <usbd_open_edpt_pair.constprop.0.isra.0+0x2c>
    1a72:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    1a76:	f8d3 3df0 	ldr.w	r3, [r3, #3568]	; 0xdf0
    1a7a:	07da      	lsls	r2, r3, #31
    1a7c:	d500      	bpl.n	1a80 <usbd_open_edpt_pair.constprop.0.isra.0+0x28>
    1a7e:	be00      	bkpt	0x0000
    1a80:	2000      	movs	r0, #0
    1a82:	e00a      	b.n	1a9a <usbd_open_edpt_pair.constprop.0.isra.0+0x42>
    TU_ASSERT(usbd_edpt_open(rhport, desc_ep));
    1a84:	4620      	mov	r0, r4
    1a86:	f7ff fee9 	bl	185c <usbd_edpt_open.constprop.0>
    1a8a:	b938      	cbnz	r0, 1a9c <usbd_open_edpt_pair.constprop.0.isra.0+0x44>
    1a8c:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    1a90:	f8d3 3df0 	ldr.w	r3, [r3, #3568]	; 0xdf0
    1a94:	07db      	lsls	r3, r3, #31
    1a96:	d5f3      	bpl.n	1a80 <usbd_open_edpt_pair.constprop.0.isra.0+0x28>
    1a98:	be00      	bkpt	0x0000
}
    1a9a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if ( tu_edpt_dir(desc_ep->bEndpointAddress) == TUSB_DIR_IN )
    1a9c:	78a3      	ldrb	r3, [r4, #2]
    1a9e:	09da      	lsrs	r2, r3, #7
      (*ep_in) = desc_ep->bEndpointAddress;
    1aa0:	bf14      	ite	ne
    1aa2:	7033      	strbne	r3, [r6, #0]
      (*ep_out) = desc_ep->bEndpointAddress;
    1aa4:	702b      	strbeq	r3, [r5, #0]

// return next descriptor
TU_ATTR_ALWAYS_INLINE static inline uint8_t const * tu_desc_next(void const* desc)
{
  uint8_t const* desc8 = (uint8_t const*) desc;
  return desc8 + desc8[DESC_OFFSET_LEN];
    1aa6:	7823      	ldrb	r3, [r4, #0]
  for(int i=0; i<ep_count; i++)
    1aa8:	2f01      	cmp	r7, #1
    1aaa:	441c      	add	r4, r3
    1aac:	d0f5      	beq.n	1a9a <usbd_open_edpt_pair.constprop.0.isra.0+0x42>
    1aae:	2701      	movs	r7, #1
    1ab0:	e7d7      	b.n	1a62 <usbd_open_edpt_pair.constprop.0.isra.0+0xa>
	...

00001ab4 <cdcd_open>:
{
    1ab4:	b570      	push	{r4, r5, r6, lr}
  TU_VERIFY( TUSB_CLASS_CDC                           == itf_desc->bInterfaceClass &&
    1ab6:	794b      	ldrb	r3, [r1, #5]
    1ab8:	2b02      	cmp	r3, #2
    1aba:	d002      	beq.n	1ac2 <cdcd_open+0xe>
  TU_ASSERT(p_cdc, 0);
    1abc:	2500      	movs	r5, #0
}
    1abe:	4628      	mov	r0, r5
    1ac0:	bd70      	pop	{r4, r5, r6, pc}
  TU_VERIFY( TUSB_CLASS_CDC                           == itf_desc->bInterfaceClass &&
    1ac2:	798b      	ldrb	r3, [r1, #6]
    1ac4:	2b02      	cmp	r3, #2
    1ac6:	d1f9      	bne.n	1abc <cdcd_open+0x8>
    if ( _cdcd_itf[cdc_id].ep_in == 0 )
    1ac8:	4e1d      	ldr	r6, [pc, #116]	; (1b40 <cdcd_open+0x8c>)
    1aca:	78b3      	ldrb	r3, [r6, #2]
    1acc:	bb4b      	cbnz	r3, 1b22 <cdcd_open+0x6e>
  p_cdc->itf_num = itf_desc->bInterfaceNumber;
    1ace:	788b      	ldrb	r3, [r1, #2]
    1ad0:	7033      	strb	r3, [r6, #0]
    1ad2:	780c      	ldrb	r4, [r1, #0]
  uint16_t drv_len = sizeof(tusb_desc_interface_t);
    1ad4:	2509      	movs	r5, #9
    1ad6:	440c      	add	r4, r1
  while ( TUSB_DESC_CS_INTERFACE == tu_desc_type(p_desc) && drv_len <= max_len )
    1ad8:	e003      	b.n	1ae2 <cdcd_open+0x2e>
}

// get descriptor length
TU_ATTR_ALWAYS_INLINE static inline uint8_t tu_desc_len(void const* desc)
{
  return ((uint8_t const*) desc)[DESC_OFFSET_LEN];
    1ada:	7823      	ldrb	r3, [r4, #0]
    drv_len += tu_desc_len(p_desc);
    1adc:	441d      	add	r5, r3
    1ade:	b2ad      	uxth	r5, r5
  return desc8 + desc8[DESC_OFFSET_LEN];
    1ae0:	441c      	add	r4, r3
  return ((uint8_t const*) desc)[DESC_OFFSET_TYPE];
    1ae2:	7863      	ldrb	r3, [r4, #1]
  while ( TUSB_DESC_CS_INTERFACE == tu_desc_type(p_desc) && drv_len <= max_len )
    1ae4:	2b24      	cmp	r3, #36	; 0x24
    1ae6:	d116      	bne.n	1b16 <cdcd_open+0x62>
    1ae8:	42aa      	cmp	r2, r5
    1aea:	d2f6      	bcs.n	1ada <cdcd_open+0x26>
  if ( (TUSB_DESC_INTERFACE == tu_desc_type(p_desc)) &&
    1aec:	7863      	ldrb	r3, [r4, #1]
    1aee:	2b04      	cmp	r3, #4
    1af0:	d10d      	bne.n	1b0e <cdcd_open+0x5a>
    1af2:	7963      	ldrb	r3, [r4, #5]
    1af4:	2b0a      	cmp	r3, #10
    1af6:	d10a      	bne.n	1b0e <cdcd_open+0x5a>
  return ((uint8_t const*) desc)[DESC_OFFSET_LEN];
    1af8:	7826      	ldrb	r6, [r4, #0]
    TU_ASSERT( usbd_open_edpt_pair(rhport, p_desc, 2, TUSB_XFER_BULK, &p_cdc->ep_out, &p_cdc->ep_in), 0 );
    1afa:	4a12      	ldr	r2, [pc, #72]	; (1b44 <cdcd_open+0x90>)
    1afc:	19a0      	adds	r0, r4, r6
    1afe:	1c51      	adds	r1, r2, #1
    1b00:	f7ff ffaa 	bl	1a58 <usbd_open_edpt_pair.constprop.0.isra.0>
    1b04:	b168      	cbz	r0, 1b22 <cdcd_open+0x6e>
    1b06:	350e      	adds	r5, #14
    drv_len += 2*sizeof(tusb_desc_endpoint_t);
    1b08:	fa16 f585 	uxtah	r5, r6, r5
    1b0c:	b2ad      	uxth	r5, r5
  _prep_out_transaction(p_cdc);
    1b0e:	480c      	ldr	r0, [pc, #48]	; (1b40 <cdcd_open+0x8c>)
    1b10:	f7ff f8cc 	bl	cac <_prep_out_transaction.isra.0>
  return drv_len;
    1b14:	e7d3      	b.n	1abe <cdcd_open+0xa>
  if ( TUSB_DESC_ENDPOINT == tu_desc_type(p_desc) )
    1b16:	2b05      	cmp	r3, #5
    1b18:	d1e8      	bne.n	1aec <cdcd_open+0x38>
    TU_ASSERT( usbd_edpt_open(rhport, desc_ep), 0 );
    1b1a:	4620      	mov	r0, r4
    1b1c:	f7ff fe9e 	bl	185c <usbd_edpt_open.constprop.0>
    1b20:	b938      	cbnz	r0, 1b32 <cdcd_open+0x7e>
  TU_ASSERT(p_cdc, 0);
    1b22:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    1b26:	f8d3 3df0 	ldr.w	r3, [r3, #3568]	; 0xdf0
    1b2a:	07db      	lsls	r3, r3, #31
    1b2c:	d5c6      	bpl.n	1abc <cdcd_open+0x8>
    1b2e:	be00      	bkpt	0x0000
    1b30:	e7c4      	b.n	1abc <cdcd_open+0x8>
    p_cdc->ep_notif = desc_ep->bEndpointAddress;
    1b32:	78a3      	ldrb	r3, [r4, #2]
    1b34:	7073      	strb	r3, [r6, #1]
    1b36:	7823      	ldrb	r3, [r4, #0]
    drv_len += tu_desc_len(p_desc);
    1b38:	441d      	add	r5, r3
    1b3a:	b2ad      	uxth	r5, r5
  return desc8 + desc8[DESC_OFFSET_LEN];
    1b3c:	441c      	add	r4, r3
    1b3e:	e7d5      	b.n	1aec <cdcd_open+0x38>
    1b40:	20002024 	.word	0x20002024
    1b44:	20002026 	.word	0x20002026

00001b48 <mscd_open>:
{
    1b48:	b510      	push	{r4, lr}
  TU_VERIFY(TUSB_CLASS_MSC    == itf_desc->bInterfaceClass &&
    1b4a:	794b      	ldrb	r3, [r1, #5]
    1b4c:	2b08      	cmp	r3, #8
{
    1b4e:	4608      	mov	r0, r1
  TU_VERIFY(TUSB_CLASS_MSC    == itf_desc->bInterfaceClass &&
    1b50:	d001      	beq.n	1b56 <mscd_open+0xe>
  TU_ASSERT(max_len >= drv_len, 0);
    1b52:	2000      	movs	r0, #0
}
    1b54:	bd10      	pop	{r4, pc}
  TU_VERIFY(TUSB_CLASS_MSC    == itf_desc->bInterfaceClass &&
    1b56:	798b      	ldrb	r3, [r1, #6]
    1b58:	2b06      	cmp	r3, #6
    1b5a:	d1fa      	bne.n	1b52 <mscd_open+0xa>
    1b5c:	79cb      	ldrb	r3, [r1, #7]
    1b5e:	2b50      	cmp	r3, #80	; 0x50
    1b60:	d1f7      	bne.n	1b52 <mscd_open+0xa>
  TU_ASSERT(max_len >= drv_len, 0);
    1b62:	2a16      	cmp	r2, #22
    1b64:	d807      	bhi.n	1b76 <mscd_open+0x2e>
    1b66:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    1b6a:	f8d3 3df0 	ldr.w	r3, [r3, #3568]	; 0xdf0
    1b6e:	07d9      	lsls	r1, r3, #31
    1b70:	d5ef      	bpl.n	1b52 <mscd_open+0xa>
    1b72:	be00      	bkpt	0x0000
    1b74:	e7ed      	b.n	1b52 <mscd_open+0xa>
  p_msc->itf_num = itf_desc->bInterfaceNumber;
    1b76:	4c14      	ldr	r4, [pc, #80]	; (1bc8 <mscd_open+0x80>)
    1b78:	788b      	ldrb	r3, [r1, #2]
    1b7a:	f884 302d 	strb.w	r3, [r4, #45]	; 0x2d
    1b7e:	780b      	ldrb	r3, [r1, #0]
  TU_ASSERT( usbd_open_edpt_pair(rhport, tu_desc_next(itf_desc), 2, TUSB_XFER_BULK, &p_msc->ep_out, &p_msc->ep_in), 0 );
    1b80:	f104 022e 	add.w	r2, r4, #46	; 0x2e
    1b84:	f104 012f 	add.w	r1, r4, #47	; 0x2f
    1b88:	4418      	add	r0, r3
    1b8a:	f7ff ff65 	bl	1a58 <usbd_open_edpt_pair.constprop.0.isra.0>
    1b8e:	b938      	cbnz	r0, 1ba0 <mscd_open+0x58>
    1b90:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    1b94:	f8d3 3df0 	ldr.w	r3, [r3, #3568]	; 0xdf0
    1b98:	07da      	lsls	r2, r3, #31
    1b9a:	d5da      	bpl.n	1b52 <mscd_open+0xa>
    1b9c:	be00      	bkpt	0x0000
    1b9e:	e7d9      	b.n	1b54 <mscd_open+0xc>
  p_msc->stage = MSC_STAGE_CMD;
    1ba0:	2300      	movs	r3, #0
  return usbd_edpt_xfer(rhport, p_msc->ep_out, (uint8_t*) &p_msc->cbw, sizeof(msc_cbw_t));
    1ba2:	f894 002f 	ldrb.w	r0, [r4, #47]	; 0x2f
  p_msc->stage = MSC_STAGE_CMD;
    1ba6:	f884 3030 	strb.w	r3, [r4, #48]	; 0x30
  return usbd_edpt_xfer(rhport, p_msc->ep_out, (uint8_t*) &p_msc->cbw, sizeof(msc_cbw_t));
    1baa:	221f      	movs	r2, #31
    1bac:	4621      	mov	r1, r4
    1bae:	f7fe ff53 	bl	a58 <usbd_edpt_xfer.constprop.0>
  TU_ASSERT( prepare_cbw(rhport, p_msc), drv_len);
    1bb2:	b930      	cbnz	r0, 1bc2 <mscd_open+0x7a>
    1bb4:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    1bb8:	f8d3 3df0 	ldr.w	r3, [r3, #3568]	; 0xdf0
    1bbc:	07db      	lsls	r3, r3, #31
    1bbe:	d500      	bpl.n	1bc2 <mscd_open+0x7a>
    1bc0:	be00      	bkpt	0x0000
  return drv_len;
    1bc2:	2017      	movs	r0, #23
    1bc4:	e7c6      	b.n	1b54 <mscd_open+0xc>
    1bc6:	bf00      	nop
    1bc8:	20002428 	.word	0x20002428

00001bcc <_tu_fifo_read_n.constprop.0>:
static uint16_t _tu_fifo_read_n(tu_fifo_t* f, void * buffer, uint16_t n, tu_fifo_copy_mode_t copy_mode)
    1bcc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  n = _tu_fifo_peek_n(f, buffer, n, f->wr_idx, f->rd_idx, copy_mode);
    1bd0:	8903      	ldrh	r3, [r0, #8]
    1bd2:	8944      	ldrh	r4, [r0, #10]
  uint16_t cnt = _ff_count(f->depth, wr_idx, rd_idx);
    1bd4:	8887      	ldrh	r7, [r0, #4]
  n = _tu_fifo_peek_n(f, buffer, n, f->wr_idx, f->rd_idx, copy_mode);
    1bd6:	b29b      	uxth	r3, r3
    1bd8:	b2a4      	uxth	r4, r4
  if (wr_idx >= rd_idx)
    1bda:	42a3      	cmp	r3, r4
    return (uint16_t) (2*depth - (rd_idx - wr_idx));
    1bdc:	bf36      	itet	cc
    1bde:	ebc4 0547 	rsbcc	r5, r4, r7, lsl #1
    return (uint16_t) (wr_idx - rd_idx);
    1be2:	1b1d      	subcs	r5, r3, r4
    return (uint16_t) (2*depth - (rd_idx - wr_idx));
    1be4:	18ed      	addcc	r5, r5, r3
    1be6:	b2ad      	uxth	r5, r5
static uint16_t _tu_fifo_read_n(tu_fifo_t* f, void * buffer, uint16_t n, tu_fifo_copy_mode_t copy_mode)
    1be8:	4606      	mov	r6, r0
    1bea:	4688      	mov	r8, r1
  if ( cnt == 0 ) return 0;
    1bec:	b1f5      	cbz	r5, 1c2c <_tu_fifo_read_n.constprop.0+0x60>
  if ( cnt > f->depth )
    1bee:	42af      	cmp	r7, r5
    1bf0:	d206      	bcs.n	1c00 <_tu_fifo_read_n.constprop.0+0x34>
  if ( wr_idx >= f->depth )
    1bf2:	42bb      	cmp	r3, r7
    rd_idx = wr_idx - f->depth;
    1bf4:	bf2c      	ite	cs
    1bf6:	1bdb      	subcs	r3, r3, r7
    rd_idx = wr_idx + f->depth;
    1bf8:	19db      	addcc	r3, r3, r7
    1bfa:	b29c      	uxth	r4, r3
  f->rd_idx = rd_idx;
    1bfc:	8144      	strh	r4, [r0, #10]
    1bfe:	463d      	mov	r5, r7
    1c00:	4295      	cmp	r5, r2
    1c02:	bf28      	it	cs
    1c04:	4615      	movcs	r5, r2
  while ( idx >= depth ) idx -= depth;
    1c06:	42a7      	cmp	r7, r4
    1c08:	d91a      	bls.n	1c40 <_tu_fifo_read_n.constprop.0+0x74>
  uint16_t lin_bytes = lin_count * f->item_size;
    1c0a:	88f2      	ldrh	r2, [r6, #6]
  uint8_t* ff_buf = f->buffer + (rd_ptr * f->item_size);
    1c0c:	6831      	ldr	r1, [r6, #0]
  uint16_t const lin_count = f->depth - rd_ptr;
    1c0e:	eba7 0904 	sub.w	r9, r7, r4
    1c12:	fa1f f989 	uxth.w	r9, r9
  uint16_t lin_bytes = lin_count * f->item_size;
    1c16:	f3c2 0a0e 	ubfx	sl, r2, #0, #15
      if ( n <= lin_count )
    1c1a:	454d      	cmp	r5, r9
  uint16_t lin_bytes = lin_count * f->item_size;
    1c1c:	4652      	mov	r2, sl
  uint8_t* ff_buf = f->buffer + (rd_ptr * f->item_size);
    1c1e:	fb0a 1104 	mla	r1, sl, r4, r1
      if ( n <= lin_count )
    1c22:	d810      	bhi.n	1c46 <_tu_fifo_read_n.constprop.0+0x7a>
        memcpy(app_buf, ff_buf, n*f->item_size);
    1c24:	436a      	muls	r2, r5
    1c26:	4640      	mov	r0, r8
        memcpy((uint8_t*) app_buf + lin_bytes, f->buffer, wrap_bytes);
    1c28:	f000 ff04 	bl	2a34 <memcpy>
  f->rd_idx = advance_index(f->depth, f->rd_idx, n);
    1c2c:	8971      	ldrh	r1, [r6, #10]
    1c2e:	88b0      	ldrh	r0, [r6, #4]
    1c30:	462a      	mov	r2, r5
    1c32:	b289      	uxth	r1, r1
    1c34:	f7fe fb43 	bl	2be <advance_index>
    1c38:	8170      	strh	r0, [r6, #10]
}
    1c3a:	4628      	mov	r0, r5
    1c3c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  while ( idx >= depth ) idx -= depth;
    1c40:	1be4      	subs	r4, r4, r7
    1c42:	b2a4      	uxth	r4, r4
    1c44:	e7df      	b.n	1c06 <_tu_fifo_read_n.constprop.0+0x3a>
  uint16_t lin_bytes = lin_count * f->item_size;
    1c46:	fb19 f90a 	smulbb	r9, r9, sl
        memcpy(app_buf, ff_buf, lin_bytes);
    1c4a:	fa1f f989 	uxth.w	r9, r9
    1c4e:	464a      	mov	r2, r9
    1c50:	4640      	mov	r0, r8
    1c52:	f000 feef 	bl	2a34 <memcpy>
  uint16_t const wrap_count = n - lin_count; // only used if wrapped
    1c56:	1bea      	subs	r2, r5, r7
    1c58:	4422      	add	r2, r4
  uint16_t wrap_bytes = wrap_count * f->item_size;
    1c5a:	fb12 f20a 	smulbb	r2, r2, sl
        memcpy((uint8_t*) app_buf + lin_bytes, f->buffer, wrap_bytes);
    1c5e:	6831      	ldr	r1, [r6, #0]
    1c60:	b292      	uxth	r2, r2
    1c62:	eb08 0009 	add.w	r0, r8, r9
    1c66:	e7df      	b.n	1c28 <_tu_fifo_read_n.constprop.0+0x5c>

00001c68 <tud_cdc_n_write_flush.constprop.0>:
uint32_t tud_cdc_n_write_flush (uint8_t itf)
    1c68:	b538      	push	{r3, r4, r5, lr}
  return _usbd_dev.cfg_num ? true : false;
    1c6a:	4b18      	ldr	r3, [pc, #96]	; (1ccc <tud_cdc_n_write_flush.constprop.0+0x64>)
    1c6c:	785a      	ldrb	r2, [r3, #1]

// Check if device is ready to transfer
TU_ATTR_ALWAYS_INLINE static inline
bool tud_ready(void)
{
  return tud_mounted() && !tud_suspended();
    1c6e:	b90a      	cbnz	r2, 1c74 <tud_cdc_n_write_flush.constprop.0+0xc>
  TU_VERIFY( tud_ready(), 0 );
    1c70:	2000      	movs	r0, #0
}
    1c72:	bd38      	pop	{r3, r4, r5, pc}
  return _usbd_dev.suspended;
    1c74:	781b      	ldrb	r3, [r3, #0]
  TU_VERIFY( tud_ready(), 0 );
    1c76:	075a      	lsls	r2, r3, #29
    1c78:	d4fa      	bmi.n	1c70 <tud_cdc_n_write_flush.constprop.0+0x8>
  if ( !tu_fifo_count(&p_cdc->tx_ff) ) return 0;
    1c7a:	4d15      	ldr	r5, [pc, #84]	; (1cd0 <tud_cdc_n_write_flush.constprop.0+0x68>)
    1c7c:	f105 001c 	add.w	r0, r5, #28
    1c80:	f7fe fb29 	bl	2d6 <tu_fifo_count>
    1c84:	2800      	cmp	r0, #0
    1c86:	d0f3      	beq.n	1c70 <tud_cdc_n_write_flush.constprop.0+0x8>
  TU_VERIFY( usbd_edpt_claim(rhport, p_cdc->ep_in), 0 );
    1c88:	78a8      	ldrb	r0, [r5, #2]
    1c8a:	f7fe fd4b 	bl	724 <usbd_edpt_claim.constprop.0>
    1c8e:	2800      	cmp	r0, #0
    1c90:	d0ee      	beq.n	1c70 <tud_cdc_n_write_flush.constprop.0+0x8>
  return _tu_fifo_read_n(f, buffer, n, TU_FIFO_COPY_INC);
    1c92:	2240      	movs	r2, #64	; 0x40
    1c94:	f105 01e8 	add.w	r1, r5, #232	; 0xe8
    1c98:	f105 001c 	add.w	r0, r5, #28
    1c9c:	f7ff ff96 	bl	1bcc <_tu_fifo_read_n.constprop.0>
  if ( count )
    1ca0:	4604      	mov	r4, r0
    1ca2:	78a8      	ldrb	r0, [r5, #2]
    1ca4:	b16c      	cbz	r4, 1cc2 <tud_cdc_n_write_flush.constprop.0+0x5a>
    TU_ASSERT( usbd_edpt_xfer(rhport, p_cdc->ep_in, p_cdc->epin_buf, count), 0 );
    1ca6:	4622      	mov	r2, r4
    1ca8:	f105 01e8 	add.w	r1, r5, #232	; 0xe8
    1cac:	f7fe fed4 	bl	a58 <usbd_edpt_xfer.constprop.0>
    1cb0:	b948      	cbnz	r0, 1cc6 <tud_cdc_n_write_flush.constprop.0+0x5e>
    1cb2:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    1cb6:	f8d3 3df0 	ldr.w	r3, [r3, #3568]	; 0xdf0
    1cba:	07db      	lsls	r3, r3, #31
    1cbc:	d5d8      	bpl.n	1c70 <tud_cdc_n_write_flush.constprop.0+0x8>
    1cbe:	be00      	bkpt	0x0000
    1cc0:	e7d7      	b.n	1c72 <tud_cdc_n_write_flush.constprop.0+0xa>
    usbd_edpt_release(rhport, p_cdc->ep_in);
    1cc2:	f7fe fd53 	bl	76c <usbd_edpt_release.constprop.0.isra.0>
    return 0;
    1cc6:	4620      	mov	r0, r4
    1cc8:	e7d3      	b.n	1c72 <tud_cdc_n_write_flush.constprop.0+0xa>
    1cca:	bf00      	nop
    1ccc:	200024a8 	.word	0x200024a8
    1cd0:	20002024 	.word	0x20002024

00001cd4 <_tu_fifo_write_n.part.0.constprop.0.isra.0>:
static uint16_t _tu_fifo_write_n(tu_fifo_t* f, const void * data, uint16_t n, tu_fifo_copy_mode_t copy_mode)
    1cd4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  if ( !f->overwritable )
    1cd8:	79c3      	ldrb	r3, [r0, #7]
  uint16_t wr_idx = f->wr_idx;
    1cda:	8906      	ldrh	r6, [r0, #8]
    uint16_t const remain = _ff_remaining(f->depth, wr_idx, rd_idx);
    1cdc:	f8b0 9004 	ldrh.w	r9, [r0, #4]
static uint16_t _tu_fifo_write_n(tu_fifo_t* f, const void * data, uint16_t n, tu_fifo_copy_mode_t copy_mode)
    1ce0:	4688      	mov	r8, r1
  uint16_t rd_idx = f->rd_idx;
    1ce2:	8941      	ldrh	r1, [r0, #10]
  if ( !f->overwritable )
    1ce4:	09db      	lsrs	r3, r3, #7
static uint16_t _tu_fifo_write_n(tu_fifo_t* f, const void * data, uint16_t n, tu_fifo_copy_mode_t copy_mode)
    1ce6:	4607      	mov	r7, r0
    1ce8:	4615      	mov	r5, r2
  uint16_t wr_idx = f->wr_idx;
    1cea:	b2b6      	uxth	r6, r6
  uint16_t rd_idx = f->rd_idx;
    1cec:	b289      	uxth	r1, r1
  if ( !f->overwritable )
    1cee:	d115      	bne.n	1d1c <_tu_fifo_write_n.part.0.constprop.0.isra.0+0x48>
  if (wr_idx >= rd_idx)
    1cf0:	428e      	cmp	r6, r1
    return (uint16_t) (2*depth - (rd_idx - wr_idx));
    1cf2:	bf39      	ittee	cc
    1cf4:	ebc1 0449 	rsbcc	r4, r1, r9, lsl #1
    1cf8:	19a4      	addcc	r4, r4, r6
    return (uint16_t) (wr_idx - rd_idx);
    1cfa:	1a71      	subcs	r1, r6, r1
    1cfc:	b28c      	uxthcs	r4, r1
    return (uint16_t) (2*depth - (rd_idx - wr_idx));
    1cfe:	bf38      	it	cc
    1d00:	b2a4      	uxthcc	r4, r4
  return (depth > count) ? (depth - count) : 0;
    1d02:	454c      	cmp	r4, r9
    1d04:	bf36      	itet	cc
    1d06:	eba9 0404 	subcc.w	r4, r9, r4
    1d0a:	2400      	movcs	r4, #0
    1d0c:	b2a4      	uxthcc	r4, r4
TU_ATTR_ALWAYS_INLINE static inline uint16_t tu_min16 (uint16_t x, uint16_t y) { return (x < y) ? x : y; }
    1d0e:	42a2      	cmp	r2, r4
    1d10:	bf28      	it	cs
    1d12:	4625      	movcs	r5, r4
  if (n)
    1d14:	2d00      	cmp	r5, #0
    1d16:	d13d      	bne.n	1d94 <_tu_fifo_write_n.part.0.constprop.0.isra.0+0xc0>
}
    1d18:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if ( n >= f->depth )
    1d1c:	454a      	cmp	r2, r9
    1d1e:	d309      	bcc.n	1d34 <_tu_fifo_write_n.part.0.constprop.0.isra.0+0x60>
        buf8 += (n - f->depth) * f->item_size;
    1d20:	88c3      	ldrh	r3, [r0, #6]
    1d22:	eba2 0509 	sub.w	r5, r2, r9
    1d26:	f3c3 030e 	ubfx	r3, r3, #0, #15
    1d2a:	fb03 8805 	mla	r8, r3, r5, r8
  uint16_t rd_idx = f->rd_idx;
    1d2e:	460e      	mov	r6, r1
    1d30:	464d      	mov	r5, r9
    1d32:	e7ef      	b.n	1d14 <_tu_fifo_write_n.part.0.constprop.0.isra.0+0x40>
  if (wr_idx >= rd_idx)
    1d34:	428e      	cmp	r6, r1
    1d36:	ea4f 0249 	mov.w	r2, r9, lsl #1
    return (uint16_t) (2*depth - (rd_idx - wr_idx));
    1d3a:	bf36      	itet	cc
    1d3c:	1a53      	subcc	r3, r2, r1
    return (uint16_t) (wr_idx - rd_idx);
    1d3e:	1a73      	subcs	r3, r6, r1
    return (uint16_t) (2*depth - (rd_idx - wr_idx));
    1d40:	199b      	addcc	r3, r3, r6
    1d42:	b29b      	uxth	r3, r3
      if (overflowable_count + n >= 2*f->depth)
    1d44:	442b      	add	r3, r5
    1d46:	4293      	cmp	r3, r2
    1d48:	dbe4      	blt.n	1d14 <_tu_fifo_write_n.part.0.constprop.0.isra.0+0x40>
        wr_idx = advance_index(f->depth, rd_idx, f->depth - n);
    1d4a:	eba9 0205 	sub.w	r2, r9, r5
    1d4e:	b292      	uxth	r2, r2
    1d50:	4648      	mov	r0, r9
    1d52:	f7fe fab4 	bl	2be <advance_index>
    1d56:	4606      	mov	r6, r0
    1d58:	e7dc      	b.n	1d14 <_tu_fifo_write_n.part.0.constprop.0.isra.0+0x40>
  while ( idx >= depth ) idx -= depth;
    1d5a:	eba4 0409 	sub.w	r4, r4, r9
    1d5e:	b2a4      	uxth	r4, r4
    1d60:	454c      	cmp	r4, r9
    1d62:	d2fa      	bcs.n	1d5a <_tu_fifo_write_n.part.0.constprop.0.isra.0+0x86>
  uint16_t lin_bytes = lin_count * f->item_size;
    1d64:	88fa      	ldrh	r2, [r7, #6]
  uint8_t* ff_buf = f->buffer + (wr_ptr * f->item_size);
    1d66:	6838      	ldr	r0, [r7, #0]
  uint16_t const lin_count = f->depth - wr_ptr;
    1d68:	eba9 0a04 	sub.w	sl, r9, r4
    1d6c:	fa1f fa8a 	uxth.w	sl, sl
  uint16_t lin_bytes = lin_count * f->item_size;
    1d70:	f3c2 0b0e 	ubfx	fp, r2, #0, #15
      if(n <= lin_count)
    1d74:	4555      	cmp	r5, sl
  uint16_t lin_bytes = lin_count * f->item_size;
    1d76:	465a      	mov	r2, fp
  uint8_t* ff_buf = f->buffer + (wr_ptr * f->item_size);
    1d78:	fb0b 0004 	mla	r0, fp, r4, r0
      if(n <= lin_count)
    1d7c:	d80c      	bhi.n	1d98 <_tu_fifo_write_n.part.0.constprop.0.isra.0+0xc4>
        memcpy(ff_buf, app_buf, n*f->item_size);
    1d7e:	436a      	muls	r2, r5
    1d80:	4641      	mov	r1, r8
        memcpy(f->buffer, ((uint8_t const*) app_buf) + lin_bytes, wrap_bytes);
    1d82:	f000 fe57 	bl	2a34 <memcpy>
    f->wr_idx = advance_index(f->depth, wr_idx, n);
    1d86:	88b8      	ldrh	r0, [r7, #4]
    1d88:	462a      	mov	r2, r5
    1d8a:	4631      	mov	r1, r6
    1d8c:	f7fe fa97 	bl	2be <advance_index>
    1d90:	8138      	strh	r0, [r7, #8]
    1d92:	e7c1      	b.n	1d18 <_tu_fifo_write_n.part.0.constprop.0.isra.0+0x44>
    1d94:	4634      	mov	r4, r6
    1d96:	e7e3      	b.n	1d60 <_tu_fifo_write_n.part.0.constprop.0.isra.0+0x8c>
  uint16_t lin_bytes = lin_count * f->item_size;
    1d98:	fb1a fa0b 	smulbb	sl, sl, fp
        memcpy(ff_buf, app_buf, lin_bytes);
    1d9c:	fa1f fa8a 	uxth.w	sl, sl
    1da0:	4652      	mov	r2, sl
    1da2:	4641      	mov	r1, r8
    1da4:	f000 fe46 	bl	2a34 <memcpy>
  uint16_t const wrap_count = n - lin_count;
    1da8:	eba5 0309 	sub.w	r3, r5, r9
    1dac:	18e2      	adds	r2, r4, r3
  uint16_t wrap_bytes = wrap_count * f->item_size;
    1dae:	fb12 f20b 	smulbb	r2, r2, fp
        memcpy(f->buffer, ((uint8_t const*) app_buf) + lin_bytes, wrap_bytes);
    1db2:	6838      	ldr	r0, [r7, #0]
    1db4:	b292      	uxth	r2, r2
    1db6:	eb08 010a 	add.w	r1, r8, sl
    1dba:	e7e2      	b.n	1d82 <_tu_fifo_write_n.part.0.constprop.0.isra.0+0xae>

00001dbc <cdcd_xfer_cb>:

bool cdcd_xfer_cb(uint8_t rhport, uint8_t ep_addr, xfer_result_t result, uint32_t xferred_bytes)
{
    1dbc:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}

  // Identify which interface to use
  for (itf = 0; itf < CFG_TUD_CDC; itf++)
  {
    p_cdc = &_cdcd_itf[itf];
    if ( ( ep_addr == p_cdc->ep_out ) || ( ep_addr == p_cdc->ep_in ) ) break;
    1dc0:	4c31      	ldr	r4, [pc, #196]	; (1e88 <cdcd_xfer_cb+0xcc>)
{
    1dc2:	461d      	mov	r5, r3
    if ( ( ep_addr == p_cdc->ep_out ) || ( ep_addr == p_cdc->ep_in ) ) break;
    1dc4:	78e3      	ldrb	r3, [r4, #3]
    1dc6:	428b      	cmp	r3, r1
{
    1dc8:	460e      	mov	r6, r1
    if ( ( ep_addr == p_cdc->ep_out ) || ( ep_addr == p_cdc->ep_in ) ) break;
    1dca:	d007      	beq.n	1ddc <cdcd_xfer_cb+0x20>
    1dcc:	78a3      	ldrb	r3, [r4, #2]
    1dce:	428b      	cmp	r3, r1
    1dd0:	d14c      	bne.n	1e6c <cdcd_xfer_cb+0xb0>
  }
  
  // Data sent to host, we continue to fetch from tx fifo to send.
  // Note: This will cause incorrect baudrate set in line coding.
  //       Though maybe the baudrate is not really important !!!
  if ( ep_addr == p_cdc->ep_in )
    1dd2:	78a3      	ldrb	r3, [r4, #2]
    1dd4:	42b3      	cmp	r3, r6
    1dd6:	d029      	beq.n	1e2c <cdcd_xfer_cb+0x70>
    }
  }

  // nothing to do with notif endpoint for now

  return true;
    1dd8:	2501      	movs	r5, #1
    1dda:	e050      	b.n	1e7e <cdcd_xfer_cb+0xc2>
    tu_fifo_write_n(&p_cdc->rx_ff, p_cdc->epout_buf, (uint16_t) xferred_bytes);
    1ddc:	b2aa      	uxth	r2, r5
  if ( n == 0 ) return 0;
    1dde:	b12a      	cbz	r2, 1dec <cdcd_xfer_cb+0x30>
    1de0:	f104 01a8 	add.w	r1, r4, #168	; 0xa8
    1de4:	f104 0010 	add.w	r0, r4, #16
    1de8:	f7ff ff74 	bl	1cd4 <_tu_fifo_write_n.part.0.constprop.0.isra.0>
    if ( tud_cdc_rx_wanted_cb && (((signed char) p_cdc->wanted_char) != -1) )
    1dec:	4b27      	ldr	r3, [pc, #156]	; (1e8c <cdcd_xfer_cb+0xd0>)
    1dee:	b92b      	cbnz	r3, 1dfc <cdcd_xfer_cb+0x40>
    _prep_out_transaction(p_cdc);
    1df0:	4825      	ldr	r0, [pc, #148]	; (1e88 <cdcd_xfer_cb+0xcc>)
  return f->wr_idx == f->rd_idx;
    1df2:	8b23      	ldrh	r3, [r4, #24]
    1df4:	8b63      	ldrh	r3, [r4, #26]
    1df6:	f7fe ff59 	bl	cac <_prep_out_transaction.isra.0>
    1dfa:	e7ea      	b.n	1dd2 <cdcd_xfer_cb+0x16>
    if ( tud_cdc_rx_wanted_cb && (((signed char) p_cdc->wanted_char) != -1) )
    1dfc:	7963      	ldrb	r3, [r4, #5]
    1dfe:	2bff      	cmp	r3, #255	; 0xff
    1e00:	d0f6      	beq.n	1df0 <cdcd_xfer_cb+0x34>
    1e02:	f8df 8094 	ldr.w	r8, [pc, #148]	; 1e98 <cdcd_xfer_cb+0xdc>
      for ( uint32_t i = 0; i < xferred_bytes; i++ )
    1e06:	2700      	movs	r7, #0
    1e08:	42af      	cmp	r7, r5
    1e0a:	d0f1      	beq.n	1df0 <cdcd_xfer_cb+0x34>
        if ( (p_cdc->wanted_char == p_cdc->epout_buf[i]) && !tu_fifo_empty(&p_cdc->rx_ff) )
    1e0c:	7961      	ldrb	r1, [r4, #5]
    1e0e:	f818 3b01 	ldrb.w	r3, [r8], #1
    1e12:	4299      	cmp	r1, r3
    1e14:	d108      	bne.n	1e28 <cdcd_xfer_cb+0x6c>
    1e16:	8b22      	ldrh	r2, [r4, #24]
    1e18:	8b63      	ldrh	r3, [r4, #26]
    1e1a:	b292      	uxth	r2, r2
    1e1c:	b29b      	uxth	r3, r3
    1e1e:	429a      	cmp	r2, r3
    1e20:	d002      	beq.n	1e28 <cdcd_xfer_cb+0x6c>
          tud_cdc_rx_wanted_cb(itf, p_cdc->wanted_char);
    1e22:	2000      	movs	r0, #0
    1e24:	f3af 8000 	nop.w
      for ( uint32_t i = 0; i < xferred_bytes; i++ )
    1e28:	3701      	adds	r7, #1
    1e2a:	e7ed      	b.n	1e08 <cdcd_xfer_cb+0x4c>
    if ( tud_cdc_tx_complete_cb ) tud_cdc_tx_complete_cb(itf);
    1e2c:	4b18      	ldr	r3, [pc, #96]	; (1e90 <cdcd_xfer_cb+0xd4>)
    1e2e:	b113      	cbz	r3, 1e36 <cdcd_xfer_cb+0x7a>
    1e30:	2000      	movs	r0, #0
    1e32:	f3af 8000 	nop.w
    if ( 0 == tud_cdc_n_write_flush(itf) )
    1e36:	f7ff ff17 	bl	1c68 <tud_cdc_n_write_flush.constprop.0>
    1e3a:	2800      	cmp	r0, #0
    1e3c:	d1cc      	bne.n	1dd8 <cdcd_xfer_cb+0x1c>
      if ( !tu_fifo_count(&p_cdc->tx_ff) && xferred_bytes && (0 == (xferred_bytes & (BULK_PACKET_SIZE-1))) )
    1e3e:	4815      	ldr	r0, [pc, #84]	; (1e94 <cdcd_xfer_cb+0xd8>)
    1e40:	f7fe fa49 	bl	2d6 <tu_fifo_count>
    1e44:	2800      	cmp	r0, #0
    1e46:	d1c7      	bne.n	1dd8 <cdcd_xfer_cb+0x1c>
    1e48:	2d00      	cmp	r5, #0
    1e4a:	d0c5      	beq.n	1dd8 <cdcd_xfer_cb+0x1c>
    1e4c:	f015 023f 	ands.w	r2, r5, #63	; 0x3f
    1e50:	d1c2      	bne.n	1dd8 <cdcd_xfer_cb+0x1c>
        if ( usbd_edpt_claim(rhport, p_cdc->ep_in) )
    1e52:	78a0      	ldrb	r0, [r4, #2]
    1e54:	9201      	str	r2, [sp, #4]
    1e56:	f7fe fc65 	bl	724 <usbd_edpt_claim.constprop.0>
    1e5a:	9a01      	ldr	r2, [sp, #4]
    1e5c:	4605      	mov	r5, r0
    1e5e:	2800      	cmp	r0, #0
    1e60:	d0ba      	beq.n	1dd8 <cdcd_xfer_cb+0x1c>
          usbd_edpt_xfer(rhport, p_cdc->ep_in, NULL, 0);
    1e62:	78a0      	ldrb	r0, [r4, #2]
    1e64:	4611      	mov	r1, r2
    1e66:	f7fe fdf7 	bl	a58 <usbd_edpt_xfer.constprop.0>
    1e6a:	e008      	b.n	1e7e <cdcd_xfer_cb+0xc2>
  TU_ASSERT(itf < CFG_TUD_CDC);
    1e6c:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    1e70:	f8d3 5df0 	ldr.w	r5, [r3, #3568]	; 0xdf0
    1e74:	f015 0501 	ands.w	r5, r5, #1
    1e78:	d001      	beq.n	1e7e <cdcd_xfer_cb+0xc2>
    1e7a:	be00      	bkpt	0x0000
    1e7c:	2500      	movs	r5, #0
}
    1e7e:	4628      	mov	r0, r5
    1e80:	b002      	add	sp, #8
    1e82:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    1e86:	bf00      	nop
    1e88:	20002024 	.word	0x20002024
	...
    1e94:	20002040 	.word	0x20002040
    1e98:	200020cc 	.word	0x200020cc

00001e9c <main>:
void led_blinking_task(void);
void cdc_task(void);

/*------------- MAIN -------------*/
int main(void)
{
    1e9c:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
void SystemCoreClockUpdate (void)            /* Get Core Clock Frequency      */
{
    uint32_t rcc, rcc2;

    /* Determine clock frequency according to clock register values */
    rcc  = SYSCTL->RCC;
    1ea0:	4bb6      	ldr	r3, [pc, #728]	; (217c <main+0x2e0>)
    1ea2:	4cb7      	ldr	r4, [pc, #732]	; (2180 <main+0x2e4>)
    1ea4:	6e1a      	ldr	r2, [r3, #96]	; 0x60
    rcc2 = SYSCTL->RCC2;
    1ea6:	6f1d      	ldr	r5, [r3, #112]	; 0x70

  //if (rcc2 & SYSCTL_RCC2_USERCC2)
    if (rcc2 & (1UL<<31)) {                             /* is rcc2 is used ? */
    1ea8:	2d00      	cmp	r5, #0
    1eaa:	b095      	sub	sp, #84	; 0x54
    1eac:	f402 0680 	and.w	r6, r2, #4194304	; 0x400000
    1eb0:	f280 812c 	bge.w	210c <main+0x270>
  //  if (rcc2 & SYSCTL_RCC2_BYPASS2)
      if (rcc2 & (1UL<<11)) {                           /* check BYPASS */
    1eb4:	f415 6700 	ands.w	r7, r5, #2048	; 0x800
    1eb8:	f000 811c 	beq.w	20f4 <main+0x258>
        SystemCoreClock = getOscClk (((rcc>>6) & 0x0F),((rcc2>>4) & 0x07));
    1ebc:	f3c5 1102 	ubfx	r1, r5, #4, #3
    1ec0:	f3c2 1083 	ubfx	r0, r2, #6, #4
    1ec4:	f7fe f9e2 	bl	28c <getOscClk>
      } else {
        SystemCoreClock = PLL_CLK;
      }
      if (rcc & (1UL<<22)) {                            /* check USESYSDIV */
    1ec8:	2e00      	cmp	r6, #0
    1eca:	f040 8115 	bne.w	20f8 <main+0x25c>
  //    if (rcc2 & SYSCTL_RCC_BYPASS)
        if (rcc & (1UL<<11)) {                          /* check BYPASS */ /* Simulation does not work at this point */
  //      if (RCC_Val & (1UL<<11)) {                          /* check BYPASS */
          SystemCoreClock = SystemCoreClock / (((rcc>>23) & (0x0F)) + 1);
        } else {
          SystemCoreClock = SystemCoreClock / (((rcc>>23) & (0x0F)) + 1) / 2;
    1ece:	6020      	str	r0, [r4, #0]
  SysTick_Config(SystemCoreClock / 1000);
    1ed0:	6823      	ldr	r3, [r4, #0]
    1ed2:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    1ed6:	fbb3 f3f2 	udiv	r3, r3, r2
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
    1eda:	3b01      	subs	r3, #1
    1edc:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
    1ee0:	d20a      	bcs.n	1ef8 <main+0x5c>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
    1ee2:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    1ee6:	21e0      	movs	r1, #224	; 0xe0
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
    1ee8:	6153      	str	r3, [r2, #20]
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    1eea:	4ba6      	ldr	r3, [pc, #664]	; (2184 <main+0x2e8>)
    1eec:	f883 1023 	strb.w	r1, [r3, #35]	; 0x23
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
    1ef0:	2300      	movs	r3, #0
    1ef2:	6193      	str	r3, [r2, #24]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
    1ef4:	2307      	movs	r3, #7
    1ef6:	6113      	str	r3, [r2, #16]
  SYSCTL->SRCR2 |= (1u << 16);
    1ef8:	4aa0      	ldr	r2, [pc, #640]	; (217c <main+0x2e0>)
    1efa:	6c93      	ldr	r3, [r2, #72]	; 0x48
    1efc:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
    1f00:	6493      	str	r3, [r2, #72]	; 0x48
  for ( volatile uint8_t i = 0; i < 20; i++ ) {}
    1f02:	2300      	movs	r3, #0
    1f04:	f88d 300d 	strb.w	r3, [sp, #13]
    1f08:	f89d 300d 	ldrb.w	r3, [sp, #13]
    1f0c:	2b13      	cmp	r3, #19
    1f0e:	f240 8113 	bls.w	2138 <main+0x29c>
  SYSCTL->SRCR2 &= ~(1u << 16);
    1f12:	4b9a      	ldr	r3, [pc, #616]	; (217c <main+0x2e0>)
    1f14:	6c9a      	ldr	r2, [r3, #72]	; 0x48
    1f16:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
    1f1a:	649a      	str	r2, [r3, #72]	; 0x48
  SYSCTL->RCGCUSB |= (1 << 0);
    1f1c:	f8d3 2628 	ldr.w	r2, [r3, #1576]	; 0x628
    1f20:	f042 0201 	orr.w	r2, r2, #1
    1f24:	f8c3 2628 	str.w	r2, [r3, #1576]	; 0x628
  SYSCTL->RCC2 &= ~(1u << 14);
    1f28:	6f1a      	ldr	r2, [r3, #112]	; 0x70
    1f2a:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
    1f2e:	671a      	str	r2, [r3, #112]	; 0x70
  SYSCTL->RCGCGPIO |= (1u << 3);
    1f30:	f8d3 2608 	ldr.w	r2, [r3, #1544]	; 0x608
    1f34:	f042 0208 	orr.w	r2, r2, #8
    1f38:	f8c3 2608 	str.w	r2, [r3, #1544]	; 0x608
  while ( !(SYSCTL->PRGPIO & (1u << 3)) ) {}
    1f3c:	f8d3 2a08 	ldr.w	r2, [r3, #2568]	; 0xa08
    1f40:	0712      	lsls	r2, r2, #28
    1f42:	d5fb      	bpl.n	1f3c <main+0xa0>
  GPIOD->AFSEL &= ~((1u << 4) | (1u << 5));
    1f44:	4a90      	ldr	r2, [pc, #576]	; (2188 <main+0x2ec>)
    1f46:	f8d2 1420 	ldr.w	r1, [r2, #1056]	; 0x420
    1f4a:	f021 0130 	bic.w	r1, r1, #48	; 0x30
    1f4e:	f8c2 1420 	str.w	r1, [r2, #1056]	; 0x420
  GPIOD->DEN &= ~((1u << 4) | (1u << 5));
    1f52:	f8d2 151c 	ldr.w	r1, [r2, #1308]	; 0x51c
    1f56:	f021 0130 	bic.w	r1, r1, #48	; 0x30
    1f5a:	f8c2 151c 	str.w	r1, [r2, #1308]	; 0x51c
  GPIOD->AMSEL |= ((1u << 4) | (1u << 5));
    1f5e:	f8d2 1528 	ldr.w	r1, [r2, #1320]	; 0x528
    1f62:	f041 0130 	orr.w	r1, r1, #48	; 0x30
    1f66:	f8c2 1528 	str.w	r1, [r2, #1320]	; 0x528
  SYSCTL->RCGCGPIO |= (1 << 5);
    1f6a:	f8d3 2608 	ldr.w	r2, [r3, #1544]	; 0x608
    1f6e:	f042 0220 	orr.w	r2, r2, #32
    1f72:	f8c3 2608 	str.w	r2, [r3, #1544]	; 0x608
  while ( !((SYSCTL->PRGPIO) & (1 << 5)) ) {}
    1f76:	4a81      	ldr	r2, [pc, #516]	; (217c <main+0x2e0>)
    1f78:	f8d2 3a08 	ldr.w	r3, [r2, #2568]	; 0xa08
    1f7c:	069b      	lsls	r3, r3, #26
    1f7e:	d5fb      	bpl.n	1f78 <main+0xdc>
  port->DEN |= PinMsk;
    1f80:	4b82      	ldr	r3, [pc, #520]	; (218c <main+0x2f0>)
    1f82:	f8d3 151c 	ldr.w	r1, [r3, #1308]	; 0x51c
    1f86:	f041 010e 	orr.w	r1, r1, #14
    1f8a:	f8c3 151c 	str.w	r1, [r3, #1308]	; 0x51c
  port->DIR = dirmsk;
    1f8e:	210e      	movs	r1, #14
    1f90:	f8c3 1400 	str.w	r1, [r3, #1024]	; 0x400
  GPIOF->DIR &= ~(1 << BOARD_BTN);
    1f94:	f8d3 1400 	ldr.w	r1, [r3, #1024]	; 0x400
    1f98:	f021 0110 	bic.w	r1, r1, #16
    1f9c:	f8c3 1400 	str.w	r1, [r3, #1024]	; 0x400
  GPIOF->PUR |= (1 << BOARD_BTN);
    1fa0:	f8d3 1510 	ldr.w	r1, [r3, #1296]	; 0x510
    1fa4:	f041 0110 	orr.w	r1, r1, #16
    1fa8:	f8c3 1510 	str.w	r1, [r3, #1296]	; 0x510
  GPIOF->DEN |= (1 << BOARD_BTN);
    1fac:	f8d3 151c 	ldr.w	r1, [r3, #1308]	; 0x51c
    1fb0:	f041 0110 	orr.w	r1, r1, #16
    1fb4:	f8c3 151c 	str.w	r1, [r3, #1308]	; 0x51c
  SYSCTL->RCGCUART |= (1 << 0);                // Enable the clock to UART0
    1fb8:	f8d2 3618 	ldr.w	r3, [r2, #1560]	; 0x618
    1fbc:	f043 0301 	orr.w	r3, r3, #1
    1fc0:	f8c2 3618 	str.w	r3, [r2, #1560]	; 0x618
  SYSCTL->RCGCGPIO |= (1 << 0);                // Enable the clock to GPIOA
    1fc4:	f8d2 3608 	ldr.w	r3, [r2, #1544]	; 0x608
    1fc8:	f043 0301 	orr.w	r3, r3, #1
    1fcc:	f8c2 3608 	str.w	r3, [r2, #1544]	; 0x608
  GPIOA->AFSEL |= (1 << 1) | (1 << 0);         // Enable the alternate function on pin PA0 & PA1
    1fd0:	f04f 2340 	mov.w	r3, #1073758208	; 0x40004000
  UART0->CC = 0x0;                             // Configure the UART clock source as system clock
    1fd4:	2400      	movs	r4, #0
  GPIOA->AFSEL |= (1 << 1) | (1 << 0);         // Enable the alternate function on pin PA0 & PA1
    1fd6:	f8d3 2420 	ldr.w	r2, [r3, #1056]	; 0x420
    1fda:	f042 0203 	orr.w	r2, r2, #3
    1fde:	f8c3 2420 	str.w	r2, [r3, #1056]	; 0x420
  GPIOA->PCTL |= (1 << 0) | (1 << 4);          // Configure the GPIOPCTL register to select UART0 in PA0 and PA1
    1fe2:	f8d3 252c 	ldr.w	r2, [r3, #1324]	; 0x52c
    1fe6:	f042 0211 	orr.w	r2, r2, #17
    1fea:	f8c3 252c 	str.w	r2, [r3, #1324]	; 0x52c
  GPIOA->DEN |= (1 << 0) | (1 << 1);           // Enable the digital functionality in PA0 and PA1
    1fee:	f8d3 251c 	ldr.w	r2, [r3, #1308]	; 0x51c
    1ff2:	f042 0203 	orr.w	r2, r2, #3
    1ff6:	f8c3 251c 	str.w	r2, [r3, #1308]	; 0x51c
  UART0->CTL &= ~(1 << 0);                     // Disable UART0 by clearing UARTEN bit in the UARTCTL register
    1ffa:	f503 4300 	add.w	r3, r3, #32768	; 0x8000
    1ffe:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    2000:	f022 0201 	bic.w	r2, r2, #1
    2004:	631a      	str	r2, [r3, #48]	; 0x30
  UART0->IBRD = 27;                            // Write the integer portion of the BRD to the UARTIRD register
    2006:	221b      	movs	r2, #27
    2008:	625a      	str	r2, [r3, #36]	; 0x24
  UART0->FBRD = 8;                             // Write the fractional portion of the BRD to the UARTFBRD registerer
    200a:	2208      	movs	r2, #8
    200c:	629a      	str	r2, [r3, #40]	; 0x28
  UART0->LCRH = (0x3 << 5);                    // 8-bit, no parity, 1 stop bit
    200e:	2260      	movs	r2, #96	; 0x60
    2010:	62da      	str	r2, [r3, #44]	; 0x2c
  UART0->CTL = (1 << 0) | (1 << 8) | (1 << 9); // UART0 Enable, Transmit Enable, Receive Enable
    2012:	f240 3201 	movw	r2, #769	; 0x301
  UART0->CC = 0x0;                             // Configure the UART clock source as system clock
    2016:	f8c3 4fc8 	str.w	r4, [r3, #4040]	; 0xfc8
  UART0->CTL = (1 << 0) | (1 << 8) | (1 << 9); // UART0 Enable, Transmit Enable, Receive Enable
    201a:	631a      	str	r2, [r3, #48]	; 0x30
  if ( tud_inited() ) return true;
    201c:	4b5c      	ldr	r3, [pc, #368]	; (2190 <main+0x2f4>)
    201e:	781b      	ldrb	r3, [r3, #0]
    2020:	2bff      	cmp	r3, #255	; 0xff
    2022:	d11e      	bne.n	2062 <main+0x1c6>
  tu_varclr(&_usbd_dev);
    2024:	2233      	movs	r2, #51	; 0x33
    2026:	485b      	ldr	r0, [pc, #364]	; (2194 <main+0x2f8>)
    2028:	4621      	mov	r1, r4
    202a:	f000 fcfb 	bl	2a24 <memset>
  f->rd_idx = 0;
    202e:	4b5a      	ldr	r3, [pc, #360]	; (2198 <main+0x2fc>)
  _usbd_q = osal_queue_create(&_usbd_qdef);
    2030:	4a5a      	ldr	r2, [pc, #360]	; (219c <main+0x300>)
    2032:	81dc      	strh	r4, [r3, #14]
    2034:	6013      	str	r3, [r2, #0]
  f->wr_idx = 0;
    2036:	819c      	strh	r4, [r3, #12]
  if ( usbd_app_driver_get_cb )
    2038:	4b59      	ldr	r3, [pc, #356]	; (21a0 <main+0x304>)
    203a:	b123      	cbz	r3, 2046 <main+0x1aa>
    _app_driver = usbd_app_driver_get_cb(&_app_driver_count);
    203c:	4859      	ldr	r0, [pc, #356]	; (21a4 <main+0x308>)
    203e:	f3af 8000 	nop.w
    2042:	4b59      	ldr	r3, [pc, #356]	; (21a8 <main+0x30c>)
    2044:	6018      	str	r0, [r3, #0]
  for (uint8_t i = 0; i < TOTAL_DRIVER_COUNT; i++)
    2046:	4d57      	ldr	r5, [pc, #348]	; (21a4 <main+0x308>)
        SystemCoreClock = PLL_CLK;
    2048:	2400      	movs	r4, #0
    usbd_class_driver_t const * driver = get_driver(i);
    204a:	4620      	mov	r0, r4
    204c:	f7fe f9e0 	bl	410 <get_driver>
    TU_ASSERT(driver);
    2050:	2800      	cmp	r0, #0
    2052:	d176      	bne.n	2142 <main+0x2a6>
    2054:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    2058:	f8d3 3df0 	ldr.w	r3, [r3, #3568]	; 0xdf0
    205c:	07df      	lsls	r7, r3, #31
    205e:	d500      	bpl.n	2062 <main+0x1c6>
    2060:	be00      	bkpt	0x0000
  if ( !tusb_inited() ) return;
    2062:	4b4b      	ldr	r3, [pc, #300]	; (2190 <main+0x2f4>)
    2064:	781b      	ldrb	r3, [r3, #0]
    2066:	2bff      	cmp	r3, #255	; 0xff
    2068:	f000 840f 	beq.w	288a <main+0x9ee>
    if ( !osal_queue_receive(_usbd_q, &event, timeout_ms) ) return;
    206c:	4b4b      	ldr	r3, [pc, #300]	; (219c <main+0x300>)
    206e:	681d      	ldr	r5, [r3, #0]
  qhdl->interrupt_set(false);
    2070:	2000      	movs	r0, #0
    2072:	682b      	ldr	r3, [r5, #0]
    2074:	4798      	blx	r3
  bool ret = _tu_fifo_peek(f, buffer, f->wr_idx, f->rd_idx);
    2076:	89a9      	ldrh	r1, [r5, #12]
    2078:	89eb      	ldrh	r3, [r5, #14]
  uint16_t cnt = _ff_count(f->depth, wr_idx, rd_idx);
    207a:	8928      	ldrh	r0, [r5, #8]
  bool ret = _tu_fifo_peek(f, buffer, f->wr_idx, f->rd_idx);
    207c:	b289      	uxth	r1, r1
    207e:	b29b      	uxth	r3, r3
  if (wr_idx >= rd_idx)
    2080:	4299      	cmp	r1, r3
    return (uint16_t) (2*depth - (rd_idx - wr_idx));
    2082:	bf36      	itet	cc
    2084:	ebc3 0240 	rsbcc	r2, r3, r0, lsl #1
    return (uint16_t) (wr_idx - rd_idx);
    2088:	1aca      	subcs	r2, r1, r3
    return (uint16_t) (2*depth - (rd_idx - wr_idx));
    208a:	1852      	addcc	r2, r2, r1
    208c:	b294      	uxth	r4, r2
  if ( cnt == 0 ) return false;
    208e:	b1a4      	cbz	r4, 20ba <main+0x21e>
  if ( cnt > f->depth )
    2090:	42a0      	cmp	r0, r4
    2092:	d205      	bcs.n	20a0 <main+0x204>
  if ( wr_idx >= f->depth )
    2094:	4281      	cmp	r1, r0
    rd_idx = wr_idx - f->depth;
    2096:	bf2c      	ite	cs
    2098:	1a09      	subcs	r1, r1, r0
    rd_idx = wr_idx + f->depth;
    209a:	1809      	addcc	r1, r1, r0
    209c:	b28b      	uxth	r3, r1
  f->rd_idx = rd_idx;
    209e:	81eb      	strh	r3, [r5, #14]
  while ( idx >= depth ) idx -= depth;
    20a0:	4298      	cmp	r0, r3
    20a2:	f240 8089 	bls.w	21b8 <main+0x31c>
  memcpy(app_buf, f->buffer + (rel * f->item_size), f->item_size);
    20a6:	896a      	ldrh	r2, [r5, #10]
    20a8:	6869      	ldr	r1, [r5, #4]
    20aa:	f3c2 020e 	ubfx	r2, r2, #0, #15
    20ae:	fb02 1103 	mla	r1, r2, r3, r1
    20b2:	a804      	add	r0, sp, #16
    20b4:	f000 fcbe 	bl	2a34 <memcpy>
  return true;
    20b8:	2401      	movs	r4, #1
  f->rd_idx = advance_index(f->depth, f->rd_idx, ret);
    20ba:	89e9      	ldrh	r1, [r5, #14]
    20bc:	8928      	ldrh	r0, [r5, #8]
    20be:	4622      	mov	r2, r4
    20c0:	b289      	uxth	r1, r1
    20c2:	f7fe f8fc 	bl	2be <advance_index>
  qhdl->interrupt_set(true);
    20c6:	682b      	ldr	r3, [r5, #0]
    20c8:	81e8      	strh	r0, [r5, #14]
    20ca:	2001      	movs	r0, #1
    20cc:	4798      	blx	r3
    20ce:	2c00      	cmp	r4, #0
    20d0:	f000 83db 	beq.w	288a <main+0x9ee>
    switch ( event.event_id )
    20d4:	f89d 3011 	ldrb.w	r3, [sp, #17]
    20d8:	3b01      	subs	r3, #1
    20da:	2b07      	cmp	r3, #7
    20dc:	f200 836b 	bhi.w	27b6 <main+0x91a>
    20e0:	e8df f013 	tbh	[pc, r3, lsl #1]
    20e4:	007b006d 	.word	0x007b006d
    20e8:	04150369 	.word	0x04150369
    20ec:	0088041e 	.word	0x0088041e
    20f0:	04270348 	.word	0x04270348
        SystemCoreClock = PLL_CLK;
    20f4:	482d      	ldr	r0, [pc, #180]	; (21ac <main+0x310>)
    20f6:	e6e7      	b.n	1ec8 <main+0x2c>
          SystemCoreClock = SystemCoreClock / (((rcc2>>23) & (0x3F)) + 1);
    20f8:	f3c5 55c5 	ubfx	r5, r5, #23, #6
    20fc:	3501      	adds	r5, #1
    20fe:	fbb0 f0f5 	udiv	r0, r0, r5
        if (rcc2 & (1UL<<11)) {
    2102:	2f00      	cmp	r7, #0
    2104:	f47f aee3 	bne.w	1ece <main+0x32>
          SystemCoreClock = SystemCoreClock / (((rcc>>23) & (0x0F)) + 1) / 2;
    2108:	0840      	lsrs	r0, r0, #1
    210a:	e6e0      	b.n	1ece <main+0x32>
      if (rcc & (1UL<<11)) {                            /* check BYPASS */ /* Simulation does not work at this point */
    210c:	f412 6500 	ands.w	r5, r2, #2048	; 0x800
    2110:	d010      	beq.n	2134 <main+0x298>
        SystemCoreClock = getOscClk (((rcc>>6) & 0x1F),((rcc>>4) & 0x03));
    2112:	f3c2 1101 	ubfx	r1, r2, #4, #2
    2116:	f3c2 1084 	ubfx	r0, r2, #6, #5
    211a:	f7fe f8b7 	bl	28c <getOscClk>
      if (rcc & (1UL<<22)) {                            /* check USESYSDIV */
    211e:	2e00      	cmp	r6, #0
    2120:	f43f aed5 	beq.w	1ece <main+0x32>
          SystemCoreClock = SystemCoreClock / (((rcc>>23) & (0x0F)) + 1);
    2124:	f3c2 52c3 	ubfx	r2, r2, #23, #4
    2128:	3201      	adds	r2, #1
    212a:	fbb0 f0f2 	udiv	r0, r0, r2
        if (rcc & (1UL<<11)) {                          /* check BYPASS */ /* Simulation does not work at this point */
    212e:	2d00      	cmp	r5, #0
    2130:	d0ea      	beq.n	2108 <main+0x26c>
    2132:	e6cc      	b.n	1ece <main+0x32>
        SystemCoreClock = PLL_CLK;
    2134:	481d      	ldr	r0, [pc, #116]	; (21ac <main+0x310>)
    2136:	e7f2      	b.n	211e <main+0x282>
  for ( volatile uint8_t i = 0; i < 20; i++ ) {}
    2138:	f89d 300d 	ldrb.w	r3, [sp, #13]
    213c:	3301      	adds	r3, #1
    213e:	b2db      	uxtb	r3, r3
    2140:	e6e0      	b.n	1f04 <main+0x68>
    driver->init();
    2142:	6803      	ldr	r3, [r0, #0]
    2144:	4798      	blx	r3
  for (uint8_t i = 0; i < TOTAL_DRIVER_COUNT; i++)
    2146:	782b      	ldrb	r3, [r5, #0]
    2148:	3401      	adds	r4, #1
    214a:	b2e4      	uxtb	r4, r4
    214c:	3301      	adds	r3, #1
    214e:	42a3      	cmp	r3, r4
    2150:	f6bf af7b 	bge.w	204a <main+0x1ae>
  _usbd_rhport = rhport;
    2154:	4a0e      	ldr	r2, [pc, #56]	; (2190 <main+0x2f4>)
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    2156:	4916      	ldr	r1, [pc, #88]	; (21b0 <main+0x314>)
    2158:	2300      	movs	r3, #0
    215a:	7013      	strb	r3, [r2, #0]
  USB0->IE |= USB_IE_SUSPND;
    215c:	4b15      	ldr	r3, [pc, #84]	; (21b4 <main+0x318>)
    215e:	7ada      	ldrb	r2, [r3, #11]
    2160:	f44f 5080 	mov.w	r0, #4096	; 0x1000
    2164:	f042 0201 	orr.w	r2, r2, #1
    2168:	72da      	strb	r2, [r3, #11]
    216a:	f8c1 0184 	str.w	r0, [r1, #388]	; 0x184
  USB0->POWER |= USB_POWER_SOFTCONN;
    216e:	785a      	ldrb	r2, [r3, #1]
    2170:	f042 0240 	orr.w	r2, r2, #64	; 0x40
    2174:	705a      	strb	r2, [r3, #1]
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    2176:	6048      	str	r0, [r1, #4]
    __COMPILER_BARRIER();
    2178:	e773      	b.n	2062 <main+0x1c6>
    217a:	bf00      	nop
    217c:	400fe000 	.word	0x400fe000
    2180:	20000000 	.word	0x20000000
    2184:	e000ed00 	.word	0xe000ed00
    2188:	40007000 	.word	0x40007000
    218c:	40025000 	.word	0x40025000
    2190:	20000014 	.word	0x20000014
    2194:	200024a8 	.word	0x200024a8
    2198:	20000004 	.word	0x20000004
    219c:	200024dc 	.word	0x200024dc
    21a0:	00000000 	.word	0x00000000
    21a4:	20002020 	.word	0x20002020
    21a8:	2000201c 	.word	0x2000201c
    21ac:	17d78400 	.word	0x17d78400
    21b0:	e000e100 	.word	0xe000e100
    21b4:	40050000 	.word	0x40050000
  while ( idx >= depth ) idx -= depth;
    21b8:	1a1b      	subs	r3, r3, r0
    21ba:	b29b      	uxth	r3, r3
    21bc:	e770      	b.n	20a0 <main+0x204>
  configuration_reset(rhport);
    21be:	f89d 0010 	ldrb.w	r0, [sp, #16]
    21c2:	f7fe fee9 	bl	f98 <configuration_reset>
  tu_varclr(&_ctrl_xfer);
    21c6:	2214      	movs	r2, #20
    21c8:	48b6      	ldr	r0, [pc, #728]	; (24a4 <main+0x608>)
    21ca:	2100      	movs	r1, #0
    21cc:	f000 fc2a 	bl	2a24 <memset>
        _usbd_dev.speed = event.bus_reset.speed;
    21d0:	4bb5      	ldr	r3, [pc, #724]	; (24a8 <main+0x60c>)
    21d2:	f89d 2014 	ldrb.w	r2, [sp, #20]
    21d6:	709a      	strb	r2, [r3, #2]
      break;
    21d8:	e748      	b.n	206c <main+0x1d0>
  configuration_reset(rhport);
    21da:	f89d 0010 	ldrb.w	r0, [sp, #16]
    21de:	f7fe fedb 	bl	f98 <configuration_reset>
    21e2:	2214      	movs	r2, #20
    21e4:	48af      	ldr	r0, [pc, #700]	; (24a4 <main+0x608>)
    21e6:	2100      	movs	r1, #0
    21e8:	f000 fc1c 	bl	2a24 <memset>
}

// Invoked when device is unmounted
void tud_umount_cb(void)
{
  blink_interval_ms = BLINK_NOT_MOUNTED;
    21ec:	4baf      	ldr	r3, [pc, #700]	; (24ac <main+0x610>)
    21ee:	22fa      	movs	r2, #250	; 0xfa
// remote_wakeup_en : if host allow us  to perform remote wakeup
// Within 7ms, device must draw an average of current less than 2.5 mA from bus
void tud_suspend_cb(bool remote_wakeup_en)
{
  (void) remote_wakeup_en;
  blink_interval_ms = BLINK_SUSPENDED;
    21f0:	601a      	str	r2, [r3, #0]
}
    21f2:	e73b      	b.n	206c <main+0x1d0>
        _usbd_dev.connected = 1;
    21f4:	4cac      	ldr	r4, [pc, #688]	; (24a8 <main+0x60c>)
  TU_ASSERT(p_request->bmRequestType_bit.type < TUSB_REQ_TYPE_INVALID);
    21f6:	f89d 7014 	ldrb.w	r7, [sp, #20]
        _usbd_dev.connected = 1;
    21fa:	7823      	ldrb	r3, [r4, #0]
  _ctrl_xfer.complete_cb = fp;
    21fc:	f8df 82a4 	ldr.w	r8, [pc, #676]	; 24a4 <main+0x608>
        if ( !process_control_request(event.rhport, &event.setup_received) )
    2200:	f89d 9010 	ldrb.w	r9, [sp, #16]
        _usbd_dev.connected = 1;
    2204:	f043 0301 	orr.w	r3, r3, #1
    2208:	7023      	strb	r3, [r4, #0]
        _usbd_dev.ep_status[0][TUSB_DIR_OUT].busy = false;
    220a:	f894 3023 	ldrb.w	r3, [r4, #35]	; 0x23
    220e:	f36f 0300 	bfc	r3, #0, #1
    2212:	f884 3023 	strb.w	r3, [r4, #35]	; 0x23
        _usbd_dev.ep_status[0][TUSB_DIR_OUT].claimed = 0;
    2216:	f894 3023 	ldrb.w	r3, [r4, #35]	; 0x23
    221a:	f36f 0382 	bfc	r3, #2, #1
    221e:	f884 3023 	strb.w	r3, [r4, #35]	; 0x23
        _usbd_dev.ep_status[0][TUSB_DIR_IN ].busy = false;
    2222:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
    2226:	f36f 0300 	bfc	r3, #0, #1
    222a:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
        _usbd_dev.ep_status[0][TUSB_DIR_IN ].claimed = 0;
    222e:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
  TU_ASSERT(p_request->bmRequestType_bit.type < TUSB_REQ_TYPE_INVALID);
    2232:	f007 0b60 	and.w	fp, r7, #96	; 0x60
        _usbd_dev.ep_status[0][TUSB_DIR_IN ].claimed = 0;
    2236:	f36f 0382 	bfc	r3, #2, #1
    223a:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
  TU_ASSERT(p_request->bmRequestType_bit.type < TUSB_REQ_TYPE_INVALID);
    223e:	f1bb 0f60 	cmp.w	fp, #96	; 0x60
    2242:	f04f 0300 	mov.w	r3, #0
    2246:	f8c8 3010 	str.w	r3, [r8, #16]
    224a:	d10d      	bne.n	2268 <main+0x3cc>
    default: TU_BREAKPOINT(); return false;
    224c:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    2250:	f8d3 3df0 	ldr.w	r3, [r3, #3568]	; 0xdf0
    2254:	07dc      	lsls	r4, r3, #31
    2256:	d500      	bpl.n	225a <main+0x3be>
    2258:	be00      	bkpt	0x0000
          dcd_edpt_stall(event.rhport, 0);
    225a:	2000      	movs	r0, #0
      // Send status
      TU_ASSERT( _status_stage_xact(rhport, &_ctrl_xfer.request) );
    }else
    {
      // Stall both IN and OUT control endpoint
      dcd_edpt_stall(rhport, EDPT_CTRL_OUT);
    225c:	f7fe fa08 	bl	670 <dcd_edpt_stall.constprop.0>
      dcd_edpt_stall(rhport, EDPT_CTRL_IN);
    2260:	2080      	movs	r0, #128	; 0x80
    2262:	f7fe fa05 	bl	670 <dcd_edpt_stall.constprop.0>
    2266:	e701      	b.n	206c <main+0x1d0>
  if ( p_request->bmRequestType_bit.type == TUSB_REQ_TYPE_VENDOR )
    2268:	f1bb 0f40 	cmp.w	fp, #64	; 0x40
    226c:	d10d      	bne.n	228a <main+0x3ee>
    TU_VERIFY(tud_vendor_control_xfer_cb);
    226e:	4b90      	ldr	r3, [pc, #576]	; (24b0 <main+0x614>)
    2270:	2b00      	cmp	r3, #0
    2272:	d0f2      	beq.n	225a <main+0x3be>
    return tud_vendor_control_xfer_cb(rhport, CONTROL_STAGE_SETUP, p_request);
    2274:	aa05      	add	r2, sp, #20
    2276:	2101      	movs	r1, #1
    2278:	4648      	mov	r0, r9
  _ctrl_xfer.complete_cb = fp;
    227a:	f8c8 3010 	str.w	r3, [r8, #16]
    227e:	f3af 8000 	nop.w
        if ( !process_control_request(event.rhport, &event.setup_received) )
    2282:	2800      	cmp	r0, #0
    2284:	f47f aef2 	bne.w	206c <main+0x1d0>
    2288:	e7e7      	b.n	225a <main+0x3be>
  switch ( p_request->bmRequestType_bit.recipient )
    228a:	f007 071f 	and.w	r7, r7, #31
    228e:	2f01      	cmp	r7, #1
    2290:	f000 81d7 	beq.w	2642 <main+0x7a6>
    2294:	2f02      	cmp	r7, #2
    2296:	f000 81fb 	beq.w	2690 <main+0x7f4>
    229a:	2f00      	cmp	r7, #0
    229c:	d1d6      	bne.n	224c <main+0x3b0>
      if ( TUSB_REQ_TYPE_CLASS == p_request->bmRequestType_bit.type )
    229e:	f1bb 0f20 	cmp.w	fp, #32
    22a2:	d10f      	bne.n	22c4 <main+0x428>
TU_ATTR_ALWAYS_INLINE static inline uint8_t tu_u16_low (uint16_t ui16) { return TU_U16_LOW(ui16); }
    22a4:	f89d 3018 	ldrb.w	r3, [sp, #24]
        TU_VERIFY(itf < TU_ARRAY_SIZE(_usbd_dev.itf2drv));
    22a8:	2b0f      	cmp	r3, #15
    22aa:	d8d6      	bhi.n	225a <main+0x3be>
        usbd_class_driver_t const * driver = get_driver(_usbd_dev.itf2drv[itf]);
    22ac:	4423      	add	r3, r4
    22ae:	78d8      	ldrb	r0, [r3, #3]
    22b0:	f7fe f8ae 	bl	410 <get_driver>
        TU_VERIFY(driver);
    22b4:	4601      	mov	r1, r0
    22b6:	2800      	cmp	r0, #0
    22b8:	d0cf      	beq.n	225a <main+0x3be>
        return invoke_class_control(rhport, driver, p_request);
    22ba:	aa05      	add	r2, sp, #20
        return invoke_class_control(rhport, driver, p_request);
    22bc:	4648      	mov	r0, r9
    22be:	f7fe f8c7 	bl	450 <invoke_class_control>
    22c2:	e7de      	b.n	2282 <main+0x3e6>
      if ( TUSB_REQ_TYPE_STANDARD != p_request->bmRequestType_bit.type )
    22c4:	f1bb 0f00 	cmp.w	fp, #0
    22c8:	d1c0      	bne.n	224c <main+0x3b0>
      switch ( p_request->bRequest )
    22ca:	f89d 2015 	ldrb.w	r2, [sp, #21]
    22ce:	2a09      	cmp	r2, #9
    22d0:	d8bc      	bhi.n	224c <main+0x3b0>
    22d2:	a101      	add	r1, pc, #4	; (adr r1, 22d8 <main+0x43c>)
    22d4:	f851 f022 	ldr.w	pc, [r1, r2, lsl #2]
    22d8:	0000262d 	.word	0x0000262d
    22dc:	0000261b 	.word	0x0000261b
    22e0:	0000224d 	.word	0x0000224d
    22e4:	00002607 	.word	0x00002607
    22e8:	0000224d 	.word	0x0000224d
    22ec:	00002301 	.word	0x00002301
    22f0:	0000250f 	.word	0x0000250f
    22f4:	0000224d 	.word	0x0000224d
    22f8:	00002333 	.word	0x00002333
    22fc:	00002347 	.word	0x00002347
  _dcd.pipe0.buf       = NULL;
    2300:	4a6c      	ldr	r2, [pc, #432]	; (24b4 <main+0x618>)
  _ctrl_xfer.buffer        = NULL;
    2302:	2300      	movs	r3, #0
  _ctrl_xfer.request       = (*request);
    2304:	e9dd 0105 	ldrd	r0, r1, [sp, #20]
    2308:	72d3      	strb	r3, [r2, #11]
    230a:	7313      	strb	r3, [r2, #12]
    230c:	7353      	strb	r3, [r2, #13]
    230e:	7393      	strb	r3, [r2, #14]
  _dcd.pipe0.length    = 0;
    2310:	73d3      	strb	r3, [r2, #15]
    2312:	7413      	strb	r3, [r2, #16]
  _dcd.pipe0.remaining = 0;
    2314:	7453      	strb	r3, [r2, #17]
    2316:	7493      	strb	r3, [r2, #18]
  _ctrl_xfer.data_len      = 0;
    2318:	e9c8 3302 	strd	r3, r3, [r8, #8]
  USB0->CSRL0 = USB_CSRL0_RXRDYC | USB_CSRL0_DATAEND;
    231c:	4b66      	ldr	r3, [pc, #408]	; (24b8 <main+0x61c>)
    231e:	2248      	movs	r2, #72	; 0x48
  _ctrl_xfer.request       = (*request);
    2320:	e9c8 0100 	strd	r0, r1, [r8]
    2324:	f883 2102 	strb.w	r2, [r3, #258]	; 0x102
          _usbd_dev.addressed = 1;
    2328:	7823      	ldrb	r3, [r4, #0]
    232a:	f043 0302 	orr.w	r3, r3, #2
    232e:	7023      	strb	r3, [r4, #0]
        break;
    2330:	e69c      	b.n	206c <main+0x1d0>
          uint8_t cfg_num = _usbd_dev.cfg_num;
    2332:	7863      	ldrb	r3, [r4, #1]
    2334:	f88d 300e 	strb.w	r3, [sp, #14]
          tud_control_xfer(rhport, p_request, &cfg_num, 1);
    2338:	2201      	movs	r2, #1
          tud_control_xfer(rhport, p_request, &status, 2);
    233a:	f10d 010e 	add.w	r1, sp, #14
    233e:	a805      	add	r0, sp, #20
    2340:	f7fe fd1a 	bl	d78 <tud_control_xfer.isra.0>
        break;
    2344:	e692      	b.n	206c <main+0x1d0>
          uint8_t const cfg_num = (uint8_t) p_request->wValue;
    2346:	f89d 8016 	ldrb.w	r8, [sp, #22]
          if (_usbd_dev.cfg_num != cfg_num)
    234a:	7863      	ldrb	r3, [r4, #1]
    234c:	4598      	cmp	r8, r3
    234e:	f000 80a2 	beq.w	2496 <main+0x5fa>
            if ( _usbd_dev.cfg_num )
    2352:	7863      	ldrb	r3, [r4, #1]
    2354:	2b00      	cmp	r3, #0
    2356:	d045      	beq.n	23e4 <main+0x548>
    return((uint32_t)(((NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
    2358:	4b58      	ldr	r3, [pc, #352]	; (24bc <main+0x620>)
    235a:	685d      	ldr	r5, [r3, #4]
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    235c:	f44f 5280 	mov.w	r2, #4096	; 0x1000
    2360:	f405 5580 	and.w	r5, r5, #4096	; 0x1000
    2364:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  __ASM volatile ("dsb 0xF":::"memory");
    2368:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    236c:	f3bf 8f6f 	isb	sy
  USB0->TXIE = 1; /* Enable only EP0 */
    2370:	4851      	ldr	r0, [pc, #324]	; (24b8 <main+0x61c>)
  USB0->RXIE = 0; 
    2372:	2200      	movs	r2, #0
  USB0->TXIE = 1; /* Enable only EP0 */
    2374:	2101      	movs	r1, #1
    regs->TXMAXP = 0;
    2376:	f103 43c0 	add.w	r3, r3, #1610612736	; 0x60000000
  USB0->TXIE = 1; /* Enable only EP0 */
    237a:	80c1      	strh	r1, [r0, #6]
    regs->TXMAXP = 0;
    237c:	f503 2384 	add.w	r3, r3, #270336	; 0x42000
  USB0->RXIE = 0; 
    2380:	8102      	strh	r2, [r0, #8]
      regs->TXCSRL = USB_TXCSRL1_CLRDT;
    2382:	2740      	movs	r7, #64	; 0x40
      regs->TXCSRL = USB_TXCSRL1_CLRDT | USB_TXCSRL1_FLUSH;
    2384:	f04f 0c48 	mov.w	ip, #72	; 0x48
    regs->RXMAXP = 0;
    2388:	4696      	mov	lr, r2
      regs->RXCSRL = USB_RXCSRL1_CLRDT;
    238a:	f04f 0a80 	mov.w	sl, #128	; 0x80
    regs->TXMAXP = 0;
    238e:	821a      	strh	r2, [r3, #16]
    regs->TXCSRH = 0;
    2390:	74da      	strb	r2, [r3, #19]
    if (regs->TXCSRL & USB_TXCSRL1_TXRDY)
    2392:	7c9e      	ldrb	r6, [r3, #18]
    2394:	07f6      	lsls	r6, r6, #31
      regs->TXCSRL = USB_TXCSRL1_CLRDT | USB_TXCSRL1_FLUSH;
    2396:	bf4c      	ite	mi
    2398:	f883 c012 	strbmi.w	ip, [r3, #18]
      regs->TXCSRL = USB_TXCSRL1_CLRDT;
    239c:	749f      	strbpl	r7, [r3, #18]
    regs->RXMAXP = 0;
    239e:	f8a3 e014 	strh.w	lr, [r3, #20]
    regs->RXCSRH = 0;
    23a2:	75da      	strb	r2, [r3, #23]
    if (regs->RXCSRL & USB_RXCSRL1_RXRDY)
    23a4:	7d9e      	ldrb	r6, [r3, #22]
    23a6:	07f6      	lsls	r6, r6, #31
      regs->RXCSRL = USB_RXCSRL1_CLRDT | USB_RXCSRL1_FLUSH;
    23a8:	bf44      	itt	mi
    23aa:	2690      	movmi	r6, #144	; 0x90
    23ac:	759e      	strbmi	r6, [r3, #22]
    23ae:	b2ce      	uxtb	r6, r1
  for (unsigned i = 1; i < TUP_DCD_ENDPOINT_MAX; ++i) {
    23b0:	f101 0101 	add.w	r1, r1, #1
      regs->RXCSRL = USB_RXCSRL1_CLRDT;
    23b4:	bf58      	it	pl
    23b6:	f883 a016 	strbpl.w	sl, [r3, #22]
  for (unsigned i = 1; i < TUP_DCD_ENDPOINT_MAX; ++i) {
    23ba:	2908      	cmp	r1, #8
    USB0->EPIDX     = i;
    23bc:	7386      	strb	r6, [r0, #14]
    USB0->TXFIFOSZ  = 0;
    23be:	f880 2062 	strb.w	r2, [r0, #98]	; 0x62
    USB0->TXFIFOADD = 0;
    23c2:	f8a0 2064 	strh.w	r2, [r0, #100]	; 0x64
    USB0->RXFIFOSZ  = 0;
    23c6:	f880 2063 	strb.w	r2, [r0, #99]	; 0x63
    USB0->RXFIFOADD = 0;
    23ca:	f8a0 2066 	strh.w	r2, [r0, #102]	; 0x66
  for (unsigned i = 1; i < TUP_DCD_ENDPOINT_MAX; ++i) {
    23ce:	d1de      	bne.n	238e <main+0x4f2>
  if (ie) NVIC_EnableIRQ(USB0_IRQn);
    23d0:	b11d      	cbz	r5, 23da <main+0x53e>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    23d2:	4b3a      	ldr	r3, [pc, #232]	; (24bc <main+0x620>)
    23d4:	f44f 5280 	mov.w	r2, #4096	; 0x1000
    23d8:	605a      	str	r2, [r3, #4]
              uint8_t const speed = _usbd_dev.speed;
    23da:	78a5      	ldrb	r5, [r4, #2]
              configuration_reset(rhport);
    23dc:	4648      	mov	r0, r9
    23de:	f7fe fddb 	bl	f98 <configuration_reset>
              _usbd_dev.speed = speed; // restore speed
    23e2:	70a5      	strb	r5, [r4, #2]
            if ( cfg_num ) TU_ASSERT( process_set_config(rhport, cfg_num) );
    23e4:	f1b8 0f00 	cmp.w	r8, #0
    23e8:	d055      	beq.n	2496 <main+0x5fa>
  _usbd_dev.remote_wakeup_support = (desc_cfg->bmAttributes & TUSB_DESC_CONFIG_ATT_REMOTE_WAKEUP) ? 1u : 0u;
    23ea:	7823      	ldrb	r3, [r4, #0]
  uint8_t const * p_desc   = ((uint8_t const*) desc_cfg) + sizeof(tusb_desc_configuration_t);
    23ec:	f8df a0dc 	ldr.w	sl, [pc, #220]	; 24cc <main+0x630>
  _usbd_dev.remote_wakeup_support = (desc_cfg->bmAttributes & TUSB_DESC_CONFIG_ATT_REMOTE_WAKEUP) ? 1u : 0u;
    23f0:	f023 0330 	bic.w	r3, r3, #48	; 0x30
    23f4:	7023      	strb	r3, [r4, #0]
    if ( TUSB_DESC_INTERFACE_ASSOCIATION == tu_desc_type(p_desc) )
    23f6:	f89a 3001 	ldrb.w	r3, [sl, #1]
    23fa:	2b0b      	cmp	r3, #11
    23fc:	bf03      	ittte	eq
    23fe:	f89a 3000 	ldrbeq.w	r3, [sl]
      assoc_itf_count = desc_iad->bInterfaceCount;
    2402:	f89a 6003 	ldrbeq.w	r6, [sl, #3]
    2406:	449a      	addeq	sl, r3
    uint8_t assoc_itf_count = 1;
    2408:	2601      	movne	r6, #1
    TU_ASSERT( TUSB_DESC_INTERFACE == tu_desc_type(p_desc) );
    240a:	f89a 3001 	ldrb.w	r3, [sl, #1]
    240e:	2b04      	cmp	r3, #4
    2410:	d00a      	beq.n	2428 <main+0x58c>
    TU_ASSERT(drv_id < TOTAL_DRIVER_COUNT);
    2412:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    2416:	f8d3 3df0 	ldr.w	r3, [r3, #3568]	; 0xdf0
    241a:	07df      	lsls	r7, r3, #31
    241c:	f57f af16 	bpl.w	224c <main+0x3b0>
    2420:	be00      	bkpt	0x0000
    2422:	e713      	b.n	224c <main+0x3b0>
    2424:	4682      	mov	sl, r0
    2426:	e7e6      	b.n	23f6 <main+0x55a>
    uint16_t const remaining_len = (uint16_t) (desc_end-p_desc);
    2428:	4b25      	ldr	r3, [pc, #148]	; (24c0 <main+0x624>)
    242a:	eba3 020a 	sub.w	r2, r3, sl
    242e:	b292      	uxth	r2, r2
    for (drv_id = 0; drv_id < TOTAL_DRIVER_COUNT; drv_id++)
    2430:	f04f 0b00 	mov.w	fp, #0
    2434:	4b23      	ldr	r3, [pc, #140]	; (24c4 <main+0x628>)
    2436:	781b      	ldrb	r3, [r3, #0]
    2438:	fa5f f58b 	uxtb.w	r5, fp
    243c:	3301      	adds	r3, #1
    243e:	42ab      	cmp	r3, r5
    2440:	dbe7      	blt.n	2412 <main+0x576>
      usbd_class_driver_t const *driver = get_driver(drv_id);
    2442:	4628      	mov	r0, r5
    2444:	f7fd ffe4 	bl	410 <get_driver>
      TU_ASSERT(driver);
    2448:	4607      	mov	r7, r0
    244a:	2800      	cmp	r0, #0
    244c:	d0e1      	beq.n	2412 <main+0x576>
      uint16_t const drv_len = driver->open(rhport, desc_itf, remaining_len);
    244e:	6883      	ldr	r3, [r0, #8]
    2450:	9201      	str	r2, [sp, #4]
    2452:	4651      	mov	r1, sl
    2454:	4648      	mov	r0, r9
    2456:	4798      	blx	r3
      if ( (sizeof(tusb_desc_interface_t) <= drv_len)  && (drv_len <= remaining_len) )
    2458:	2808      	cmp	r0, #8
    245a:	9a01      	ldr	r2, [sp, #4]
    245c:	d954      	bls.n	2508 <main+0x66c>
    245e:	4282      	cmp	r2, r0
    2460:	d352      	bcc.n	2508 <main+0x66c>
        if ( assoc_itf_count == 1)
    2462:	2e01      	cmp	r6, #1
    2464:	d104      	bne.n	2470 <main+0x5d4>
          if ( driver->open == cdcd_open ) assoc_itf_count = 2;
    2466:	68ba      	ldr	r2, [r7, #8]
    2468:	4b17      	ldr	r3, [pc, #92]	; (24c8 <main+0x62c>)
    246a:	429a      	cmp	r2, r3
    246c:	bf08      	it	eq
    246e:	2602      	moveq	r6, #2
        for(uint8_t i=0; i<assoc_itf_count; i++)
    2470:	2200      	movs	r2, #0
    2472:	b2d3      	uxtb	r3, r2
    2474:	429e      	cmp	r6, r3
    2476:	d82b      	bhi.n	24d0 <main+0x634>
}

void tu_edpt_bind_driver(uint8_t ep2drv[][2], tusb_desc_interface_t const* desc_itf, uint16_t desc_len, uint8_t driver_id)
{
  uint8_t const* p_desc = (uint8_t const*) desc_itf;
  uint8_t const* desc_end = p_desc + desc_len;
    2478:	4450      	add	r0, sl

  while( p_desc < desc_end )
    247a:	4550      	cmp	r0, sl
    247c:	d833      	bhi.n	24e6 <main+0x64a>
    TU_ASSERT(drv_id < TOTAL_DRIVER_COUNT);
    247e:	4b11      	ldr	r3, [pc, #68]	; (24c4 <main+0x628>)
    2480:	781b      	ldrb	r3, [r3, #0]
    2482:	3301      	adds	r3, #1
    2484:	429d      	cmp	r5, r3
    2486:	dcc4      	bgt.n	2412 <main+0x576>
  while( p_desc < desc_end )
    2488:	4b0d      	ldr	r3, [pc, #52]	; (24c0 <main+0x624>)
    248a:	4298      	cmp	r0, r3
    248c:	d3ca      	bcc.n	2424 <main+0x588>
  blink_interval_ms = BLINK_MOUNTED;
    248e:	4b07      	ldr	r3, [pc, #28]	; (24ac <main+0x610>)
    2490:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    2494:	601a      	str	r2, [r3, #0]
          _usbd_dev.cfg_num = cfg_num;
    2496:	f884 8001 	strb.w	r8, [r4, #1]
          tud_control_status(rhport, p_request);
    249a:	a805      	add	r0, sp, #20
    249c:	f7fe fc30 	bl	d00 <tud_control_status.isra.0>
        break;
    24a0:	e5e4      	b.n	206c <main+0x1d0>
    24a2:	bf00      	nop
    24a4:	2000214c 	.word	0x2000214c
    24a8:	200024a8 	.word	0x200024a8
    24ac:	20000018 	.word	0x20000018
    24b0:	00000000 	.word	0x00000000
    24b4:	20002160 	.word	0x20002160
    24b8:	40050000 	.word	0x40050000
    24bc:	e000e100 	.word	0xe000e100
    24c0:	00002bdc 	.word	0x00002bdc
    24c4:	20002020 	.word	0x20002020
    24c8:	00001ab5 	.word	0x00001ab5
    24cc:	00002b83 	.word	0x00002b83
          uint8_t const itf_num = desc_itf->bInterfaceNumber+i;
    24d0:	f89a 7002 	ldrb.w	r7, [sl, #2]
    24d4:	443b      	add	r3, r7
          TU_ASSERT(DRVID_INVALID == _usbd_dev.itf2drv[itf_num]);
    24d6:	fa54 f383 	uxtab	r3, r4, r3
    24da:	3201      	adds	r2, #1
    24dc:	78df      	ldrb	r7, [r3, #3]
    24de:	2fff      	cmp	r7, #255	; 0xff
    24e0:	d197      	bne.n	2412 <main+0x576>
          _usbd_dev.itf2drv[itf_num] = drv_id;
    24e2:	70dd      	strb	r5, [r3, #3]
    24e4:	e7c5      	b.n	2472 <main+0x5d6>
  {
    if ( TUSB_DESC_ENDPOINT == tu_desc_type(p_desc) )
    24e6:	f89a 3001 	ldrb.w	r3, [sl, #1]
    24ea:	2b05      	cmp	r3, #5
    24ec:	d108      	bne.n	2500 <main+0x664>
    {
      uint8_t const ep_addr = ((tusb_desc_endpoint_t const*) p_desc)->bEndpointAddress;
    24ee:	f89a 2002 	ldrb.w	r2, [sl, #2]

      TU_LOG(2, "  Bind EP %02x to driver id %u\r\n", ep_addr, driver_id);
      ep2drv[tu_edpt_number(ep_addr)][tu_edpt_dir(ep_addr)] = driver_id;
    24f2:	f002 037f 	and.w	r3, r2, #127	; 0x7f
    24f6:	eb04 0343 	add.w	r3, r4, r3, lsl #1
    24fa:	eb03 13d2 	add.w	r3, r3, r2, lsr #7
    24fe:	74dd      	strb	r5, [r3, #19]

// return next descriptor
TU_ATTR_ALWAYS_INLINE static inline uint8_t const * tu_desc_next(void const* desc)
{
  uint8_t const* desc8 = (uint8_t const*) desc;
  return desc8 + desc8[DESC_OFFSET_LEN];
    2500:	f89a 3000 	ldrb.w	r3, [sl]
    2504:	449a      	add	sl, r3
    2506:	e7b8      	b.n	247a <main+0x5de>
    2508:	f10b 0b01 	add.w	fp, fp, #1
    250c:	e792      	b.n	2434 <main+0x598>
  tusb_desc_type_t const desc_type = (tusb_desc_type_t) tu_u16_high(p_request->wValue);
    250e:	f8bd 0016 	ldrh.w	r0, [sp, #22]
TU_ATTR_ALWAYS_INLINE static inline uint8_t tu_u16_high(uint16_t ui16) { return TU_U16_HIGH(ui16); }
    2512:	0a03      	lsrs	r3, r0, #8
  switch(desc_type)
    2514:	1e5a      	subs	r2, r3, #1
TU_ATTR_ALWAYS_INLINE static inline uint8_t tu_u16_low (uint16_t ui16) { return TU_U16_LOW(ui16); }
    2516:	b2c0      	uxtb	r0, r0
    2518:	2a0e      	cmp	r2, #14
    251a:	f63f ae9e 	bhi.w	225a <main+0x3be>
    251e:	a101      	add	r1, pc, #4	; (adr r1, 2524 <main+0x688>)
    2520:	f851 f022 	ldr.w	pc, [r1, r2, lsl #2]
    2524:	00002561 	.word	0x00002561
    2528:	00002585 	.word	0x00002585
    252c:	000025a3 	.word	0x000025a3
    2530:	0000225b 	.word	0x0000225b
    2534:	0000225b 	.word	0x0000225b
    2538:	000025ef 	.word	0x000025ef
    253c:	00002585 	.word	0x00002585
    2540:	0000225b 	.word	0x0000225b
    2544:	0000225b 	.word	0x0000225b
    2548:	0000225b 	.word	0x0000225b
    254c:	0000225b 	.word	0x0000225b
    2550:	0000225b 	.word	0x0000225b
    2554:	0000225b 	.word	0x0000225b
    2558:	0000225b 	.word	0x0000225b
    255c:	0000256d 	.word	0x0000256d
        return tud_control_xfer(rhport, p_request, desc_device, sizeof(tusb_desc_device_t));
    2560:	49b5      	ldr	r1, [pc, #724]	; (2838 <main+0x99c>)
    2562:	2212      	movs	r2, #18
      return tud_control_xfer(rhport, p_request, (void*) (uintptr_t) desc_qualifier, tu_desc_len(desc_qualifier));
    2564:	a805      	add	r0, sp, #20
    2566:	f7fe fc07 	bl	d78 <tud_control_xfer.isra.0>
    256a:	e68a      	b.n	2282 <main+0x3e6>
      if (!tud_descriptor_bos_cb) return false;
    256c:	4bb3      	ldr	r3, [pc, #716]	; (283c <main+0x9a0>)
    256e:	2b00      	cmp	r3, #0
    2570:	f43f ae73 	beq.w	225a <main+0x3be>
      uintptr_t desc_bos = (uintptr_t) tud_descriptor_bos_cb();
    2574:	f3af 8000 	nop.w
      TU_ASSERT(desc_bos);
    2578:	4601      	mov	r1, r0
    257a:	2800      	cmp	r0, #0
    257c:	f43f ae66 	beq.w	224c <main+0x3b0>
      return tud_control_xfer(rhport, p_request, (void*) desc_config, total_len);
    2580:	884a      	ldrh	r2, [r1, #2]
    2582:	e7ef      	b.n	2564 <main+0x6c8>
      if ( desc_type == TUSB_DESC_CONFIGURATION )
    2584:	2b02      	cmp	r3, #2
    2586:	d101      	bne.n	258c <main+0x6f0>
        desc_config = (uintptr_t) tud_descriptor_configuration_cb(desc_index);
    2588:	49ad      	ldr	r1, [pc, #692]	; (2840 <main+0x9a4>)
    258a:	e7f9      	b.n	2580 <main+0x6e4>
        TU_VERIFY( tud_descriptor_other_speed_configuration_cb );
    258c:	4bad      	ldr	r3, [pc, #692]	; (2844 <main+0x9a8>)
    258e:	2b00      	cmp	r3, #0
    2590:	f43f ae63 	beq.w	225a <main+0x3be>
        desc_config = (uintptr_t) tud_descriptor_other_speed_configuration_cb(desc_index);
    2594:	f3af 8000 	nop.w
      TU_ASSERT(desc_config);
    2598:	2800      	cmp	r0, #0
    259a:	f43f ae57 	beq.w	224c <main+0x3b0>
        desc_config = (uintptr_t) tud_descriptor_other_speed_configuration_cb(desc_index);
    259e:	4601      	mov	r1, r0
    25a0:	e7ee      	b.n	2580 <main+0x6e4>
{
  (void) langid;

  uint8_t chr_count;

  if ( index == 0)
    25a2:	b960      	cbnz	r0, 25be <main+0x722>
  {
    memcpy(&_desc_str[1], string_desc_arr[0], 2);
    25a4:	4ba8      	ldr	r3, [pc, #672]	; (2848 <main+0x9ac>)
    25a6:	f240 4209 	movw	r2, #1033	; 0x409
    25aa:	805a      	strh	r2, [r3, #2]
    chr_count = 1;
    25ac:	2201      	movs	r2, #1
      _desc_str[1+i] = str[i];
    }
  }

  // first byte is length (including header), second byte is string type
  _desc_str[0] = (uint16_t) ((TUSB_DESC_STRING << 8 ) | (2*chr_count + 2));
    25ae:	3201      	adds	r2, #1
    25b0:	b2d2      	uxtb	r2, r2
    25b2:	49a5      	ldr	r1, [pc, #660]	; (2848 <main+0x9ac>)
    25b4:	0052      	lsls	r2, r2, #1
    25b6:	f442 7340 	orr.w	r3, r2, #768	; 0x300
    25ba:	800b      	strh	r3, [r1, #0]
    25bc:	e7d2      	b.n	2564 <main+0x6c8>
    if ( !(index < sizeof(string_desc_arr)/sizeof(string_desc_arr[0])) ) return NULL;
    25be:	2805      	cmp	r0, #5
    25c0:	f63f ae4b 	bhi.w	225a <main+0x3be>
    const char* str = string_desc_arr[index];
    25c4:	4ba1      	ldr	r3, [pc, #644]	; (284c <main+0x9b0>)
    25c6:	f853 4020 	ldr.w	r4, [r3, r0, lsl #2]
    chr_count = (uint8_t) strlen(str);
    25ca:	4620      	mov	r0, r4
    25cc:	f7fd fe4e 	bl	26c <strlen>
    25d0:	b2c2      	uxtb	r2, r0
    25d2:	2a1f      	cmp	r2, #31
    25d4:	bf28      	it	cs
    25d6:	221f      	movcs	r2, #31
    25d8:	4b9b      	ldr	r3, [pc, #620]	; (2848 <main+0x9ac>)
    25da:	4620      	mov	r0, r4
    25dc:	18a1      	adds	r1, r4, r2
    for(uint8_t i=0; i<chr_count; i++)
    25de:	4281      	cmp	r1, r0
    25e0:	f103 0302 	add.w	r3, r3, #2
    25e4:	d0e3      	beq.n	25ae <main+0x712>
      _desc_str[1+i] = str[i];
    25e6:	f810 4b01 	ldrb.w	r4, [r0], #1
    25ea:	801c      	strh	r4, [r3, #0]
    25ec:	e7f7      	b.n	25de <main+0x742>
      TU_VERIFY( tud_descriptor_device_qualifier_cb );
    25ee:	4b98      	ldr	r3, [pc, #608]	; (2850 <main+0x9b4>)
    25f0:	2b00      	cmp	r3, #0
    25f2:	f43f ae32 	beq.w	225a <main+0x3be>
      uint8_t const* desc_qualifier = tud_descriptor_device_qualifier_cb();
    25f6:	f3af 8000 	nop.w
      TU_VERIFY(desc_qualifier);
    25fa:	4601      	mov	r1, r0
    25fc:	2800      	cmp	r0, #0
    25fe:	f43f ae2c 	beq.w	225a <main+0x3be>
      return tud_control_xfer(rhport, p_request, (void*) (uintptr_t) desc_qualifier, tu_desc_len(desc_qualifier));
    2602:	7802      	ldrb	r2, [r0, #0]
    2604:	e7ae      	b.n	2564 <main+0x6c8>
          TU_VERIFY(TUSB_REQ_FEATURE_REMOTE_WAKEUP == p_request->wValue);
    2606:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    260a:	2b01      	cmp	r3, #1
    260c:	f47f ae25 	bne.w	225a <main+0x3be>
          _usbd_dev.remote_wakeup_en = true;
    2610:	7823      	ldrb	r3, [r4, #0]
    2612:	f043 0308 	orr.w	r3, r3, #8
    2616:	7023      	strb	r3, [r4, #0]
    2618:	e73f      	b.n	249a <main+0x5fe>
          TU_VERIFY(TUSB_REQ_FEATURE_REMOTE_WAKEUP == p_request->wValue);
    261a:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    261e:	2b01      	cmp	r3, #1
    2620:	f47f ae1b 	bne.w	225a <main+0x3be>
          _usbd_dev.remote_wakeup_en = false;
    2624:	7823      	ldrb	r3, [r4, #0]
    2626:	f36f 03c3 	bfc	r3, #3, #1
    262a:	e7f4      	b.n	2616 <main+0x77a>
          uint16_t status = (uint16_t) ((_usbd_dev.self_powered ? 1u : 0u) | (_usbd_dev.remote_wakeup_en ? 2u : 0u));
    262c:	7823      	ldrb	r3, [r4, #0]
    262e:	f3c3 1240 	ubfx	r2, r3, #5, #1
    2632:	089b      	lsrs	r3, r3, #2
    2634:	f003 0302 	and.w	r3, r3, #2
    2638:	4313      	orrs	r3, r2
    263a:	f8ad 300e 	strh.w	r3, [sp, #14]
          tud_control_xfer(rhport, p_request, &status, 2);
    263e:	2202      	movs	r2, #2
    2640:	e67b      	b.n	233a <main+0x49e>
    2642:	f89d 3018 	ldrb.w	r3, [sp, #24]
      TU_VERIFY(itf < TU_ARRAY_SIZE(_usbd_dev.itf2drv));
    2646:	2b0f      	cmp	r3, #15
    2648:	f63f ae07 	bhi.w	225a <main+0x3be>
      usbd_class_driver_t const * driver = get_driver(_usbd_dev.itf2drv[itf]);
    264c:	4423      	add	r3, r4
    264e:	78d8      	ldrb	r0, [r3, #3]
    2650:	f7fd fede 	bl	410 <get_driver>
      TU_VERIFY(driver);
    2654:	4601      	mov	r1, r0
    2656:	2800      	cmp	r0, #0
    2658:	f43f adff 	beq.w	225a <main+0x3be>
      if ( !invoke_class_control(rhport, driver, p_request) )
    265c:	aa05      	add	r2, sp, #20
    265e:	4648      	mov	r0, r9
    2660:	f7fd fef6 	bl	450 <invoke_class_control>
    2664:	2800      	cmp	r0, #0
    2666:	f47f ad01 	bne.w	206c <main+0x1d0>
        TU_VERIFY(TUSB_REQ_TYPE_STANDARD == p_request->bmRequestType_bit.type);
    266a:	f89d 3014 	ldrb.w	r3, [sp, #20]
    266e:	f013 0360 	ands.w	r3, r3, #96	; 0x60
    2672:	f47f adf2 	bne.w	225a <main+0x3be>
        switch(p_request->bRequest)
    2676:	f89d 2015 	ldrb.w	r2, [sp, #21]
    267a:	f1a2 010a 	sub.w	r1, r2, #10
    267e:	2901      	cmp	r1, #1
    2680:	f63f adeb 	bhi.w	225a <main+0x3be>
            if (TUSB_REQ_GET_INTERFACE == p_request->bRequest)
    2684:	2a0a      	cmp	r2, #10
  _ctrl_xfer.complete_cb = fp;
    2686:	f8c8 3010 	str.w	r3, [r8, #16]
    268a:	f47f af06 	bne.w	249a <main+0x5fe>
    268e:	e651      	b.n	2334 <main+0x498>
    2690:	f89d 2018 	ldrb.w	r2, [sp, #24]
      TU_ASSERT(ep_num < TU_ARRAY_SIZE(_usbd_dev.ep2drv) );
    2694:	f012 0f78 	tst.w	r2, #120	; 0x78
    2698:	f47f add8 	bne.w	224c <main+0x3b0>
  return (uint8_t)(addr & (~TUSB_DIR_IN_MASK));
    269c:	f002 017f 	and.w	r1, r2, #127	; 0x7f
      usbd_class_driver_t const * driver = get_driver(_usbd_dev.ep2drv[ep_num][ep_dir]);
    26a0:	eb04 0641 	add.w	r6, r4, r1, lsl #1
    26a4:	eb06 16d2 	add.w	r6, r6, r2, lsr #7
  return (addr & TUSB_DIR_IN_MASK) ? TUSB_DIR_IN : TUSB_DIR_OUT;
    26a8:	09d3      	lsrs	r3, r2, #7
    26aa:	7cf0      	ldrb	r0, [r6, #19]
    26ac:	9301      	str	r3, [sp, #4]
    26ae:	f7fd feaf 	bl	410 <get_driver>
    26b2:	004d      	lsls	r5, r1, #1
      if ( TUSB_REQ_TYPE_STANDARD != p_request->bmRequestType_bit.type )
    26b4:	9b01      	ldr	r3, [sp, #4]
      usbd_class_driver_t const * driver = get_driver(_usbd_dev.ep2drv[ep_num][ep_dir]);
    26b6:	4682      	mov	sl, r0
      if ( TUSB_REQ_TYPE_STANDARD != p_request->bmRequestType_bit.type )
    26b8:	f1bb 0f00 	cmp.w	fp, #0
    26bc:	d005      	beq.n	26ca <main+0x82e>
        TU_VERIFY(driver);
    26be:	2800      	cmp	r0, #0
    26c0:	f43f adcb 	beq.w	225a <main+0x3be>
        return invoke_class_control(rhport, driver, p_request);
    26c4:	aa05      	add	r2, sp, #20
    26c6:	4601      	mov	r1, r0
    26c8:	e5f8      	b.n	22bc <main+0x420>
        switch ( p_request->bRequest )
    26ca:	f89d 0015 	ldrb.w	r0, [sp, #21]
    26ce:	f000 0cfd 	and.w	ip, r0, #253	; 0xfd
    26d2:	f1bc 0f01 	cmp.w	ip, #1
    26d6:	d007      	beq.n	26e8 <main+0x84c>
    26d8:	2800      	cmp	r0, #0
    26da:	f47f adb7 	bne.w	224c <main+0x3b0>
  return _usbd_dev.ep_status[epnum][dir].stalled;
    26de:	f896 3023 	ldrb.w	r3, [r6, #35]	; 0x23
    26e2:	f3c3 0340 	ubfx	r3, r3, #1, #1
    26e6:	e7a8      	b.n	263a <main+0x79e>
            if ( TUSB_REQ_FEATURE_EDPT_HALT == p_request->wValue )
    26e8:	f8bd 7016 	ldrh.w	r7, [sp, #22]
    26ec:	bb4f      	cbnz	r7, 2742 <main+0x8a6>
              if ( TUSB_REQ_CLEAR_FEATURE ==  p_request->bRequest )
    26ee:	2801      	cmp	r0, #1
    26f0:	d13c      	bne.n	276c <main+0x8d0>
  if ( _usbd_dev.ep_status[epnum][dir].stalled )
    26f2:	f896 2023 	ldrb.w	r2, [r6, #35]	; 0x23
    26f6:	0796      	lsls	r6, r2, #30
    26f8:	d523      	bpl.n	2742 <main+0x8a6>
  return regs + epnum_minus1;
    26fa:	4a56      	ldr	r2, [pc, #344]	; (2854 <main+0x9b8>)
    26fc:	0109      	lsls	r1, r1, #4
    26fe:	440a      	add	r2, r1
    return((uint32_t)(((NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
    2700:	4955      	ldr	r1, [pc, #340]	; (2858 <main+0x9bc>)
    2702:	6848      	ldr	r0, [r1, #4]
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    2704:	f44f 5680 	mov.w	r6, #4096	; 0x1000
    2708:	f400 5080 	and.w	r0, r0, #4096	; 0x1000
    270c:	f8c1 6084 	str.w	r6, [r1, #132]	; 0x84
  __ASM volatile ("dsb 0xF":::"memory");
    2710:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    2714:	f3bf 8f6f 	isb	sy
  if (tu_edpt_dir(ep_addr)) { /* IN */
    2718:	b32b      	cbz	r3, 2766 <main+0x8ca>
    regs->TXCSRL = USB_TXCSRL1_CLRDT;
    271a:	2640      	movs	r6, #64	; 0x40
    271c:	7096      	strb	r6, [r2, #2]
  if (ie) NVIC_EnableIRQ(USB0_IRQn);
    271e:	b110      	cbz	r0, 2726 <main+0x88a>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    2720:	f44f 5280 	mov.w	r2, #4096	; 0x1000
    2724:	604a      	str	r2, [r1, #4]
    _usbd_dev.ep_status[epnum][dir].stalled = false;
    2726:	4425      	add	r5, r4
    2728:	442b      	add	r3, r5
    272a:	f893 2023 	ldrb.w	r2, [r3, #35]	; 0x23
    272e:	f36f 0241 	bfc	r2, #1, #1
    2732:	f883 2023 	strb.w	r2, [r3, #35]	; 0x23
    _usbd_dev.ep_status[epnum][dir].busy = false;
    2736:	f893 2023 	ldrb.w	r2, [r3, #35]	; 0x23
    273a:	f36f 0200 	bfc	r2, #0, #1
    273e:	f883 2023 	strb.w	r2, [r3, #35]	; 0x23
            if (driver)
    2742:	f1ba 0f00 	cmp.w	sl, #0
    2746:	f43f ac91 	beq.w	206c <main+0x1d0>
              (void) invoke_class_control(rhport, driver, p_request);
    274a:	aa05      	add	r2, sp, #20
    274c:	4651      	mov	r1, sl
    274e:	4648      	mov	r0, r9
    2750:	f7fd fe7e 	bl	450 <invoke_class_control>
    2754:	2300      	movs	r3, #0
    2756:	f8c8 3010 	str.w	r3, [r8, #16]
              if ( !_usbd_dev.ep_status[0][TUSB_DIR_IN].busy ) tud_control_status(rhport, p_request);
    275a:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
    275e:	07dd      	lsls	r5, r3, #31
    2760:	f53f ac84 	bmi.w	206c <main+0x1d0>
    2764:	e699      	b.n	249a <main+0x5fe>
    regs->RXCSRL = USB_RXCSRL1_CLRDT; 
    2766:	2680      	movs	r6, #128	; 0x80
    2768:	7196      	strb	r6, [r2, #6]
    276a:	e7d8      	b.n	271e <main+0x882>
                usbd_edpt_stall(rhport, ep_addr);
    276c:	4610      	mov	r0, r2
    276e:	f7fd ffbf 	bl	6f0 <usbd_edpt_stall.constprop.0>
    2772:	e7e6      	b.n	2742 <main+0x8a6>
        uint8_t const ep_addr = event.xfer_complete.ep_addr;
    2774:	f89d 1014 	ldrb.w	r1, [sp, #20]
        _usbd_dev.ep_status[epnum][ep_dir].busy = false;
    2778:	4b38      	ldr	r3, [pc, #224]	; (285c <main+0x9c0>)
  return (uint8_t)(addr & (~TUSB_DIR_IN_MASK));
    277a:	f001 047f 	and.w	r4, r1, #127	; 0x7f
    277e:	eb03 0344 	add.w	r3, r3, r4, lsl #1
    2782:	eb03 13d1 	add.w	r3, r3, r1, lsr #7
  return (addr & TUSB_DIR_IN_MASK) ? TUSB_DIR_IN : TUSB_DIR_OUT;
    2786:	09ce      	lsrs	r6, r1, #7
    2788:	f893 0023 	ldrb.w	r0, [r3, #35]	; 0x23
    278c:	f36f 0000 	bfc	r0, #0, #1
    2790:	f883 0023 	strb.w	r0, [r3, #35]	; 0x23
        _usbd_dev.ep_status[epnum][ep_dir].claimed = 0;
    2794:	f893 0023 	ldrb.w	r0, [r3, #35]	; 0x23
    2798:	f36f 0082 	bfc	r0, #2, #1
    279c:	f883 0023 	strb.w	r0, [r3, #35]	; 0x23
        if ( 0 == epnum )
    27a0:	2c00      	cmp	r4, #0
    27a2:	d166      	bne.n	2872 <main+0x9d6>
  if ( tu_edpt_dir(ep_addr) != _ctrl_xfer.request.bmRequestType_bit.direction )
    27a4:	4c2e      	ldr	r4, [pc, #184]	; (2860 <main+0x9c4>)
          usbd_control_xfer_cb(event.rhport, ep_addr, (xfer_result_t)event.xfer_complete.result, event.xfer_complete.len);
    27a6:	f89d 7010 	ldrb.w	r7, [sp, #16]
    27aa:	7823      	ldrb	r3, [r4, #0]
    27ac:	9d06      	ldr	r5, [sp, #24]
    27ae:	ebb6 1fd3 	cmp.w	r6, r3, lsr #7
    27b2:	d018      	beq.n	27e6 <main+0x94a>
    TU_ASSERT(0 == xferred_bytes);
    27b4:	b145      	cbz	r5, 27c8 <main+0x92c>
        TU_BREAKPOINT();
    27b6:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    27ba:	f8d3 3df0 	ldr.w	r3, [r3, #3568]	; 0xdf0
    27be:	07db      	lsls	r3, r3, #31
    27c0:	f57f ac54 	bpl.w	206c <main+0x1d0>
    27c4:	be00      	bkpt	0x0000
  {
    27c6:	e451      	b.n	206c <main+0x1d0>
    if (dcd_edpt0_status_complete) dcd_edpt0_status_complete(rhport, &_ctrl_xfer.request);
    27c8:	4b26      	ldr	r3, [pc, #152]	; (2864 <main+0x9c8>)
    27ca:	b11b      	cbz	r3, 27d4 <main+0x938>
    27cc:	4621      	mov	r1, r4
    27ce:	4638      	mov	r0, r7
    27d0:	f3af 8000 	nop.w
    if (_ctrl_xfer.complete_cb)
    27d4:	6923      	ldr	r3, [r4, #16]
    27d6:	2b00      	cmp	r3, #0
    27d8:	f43f ac48 	beq.w	206c <main+0x1d0>
      _ctrl_xfer.complete_cb(rhport, CONTROL_STAGE_ACK, &_ctrl_xfer.request);
    27dc:	4a20      	ldr	r2, [pc, #128]	; (2860 <main+0x9c4>)
    27de:	2103      	movs	r1, #3
    27e0:	4638      	mov	r0, r7
    27e2:	4798      	blx	r3
    27e4:	e442      	b.n	206c <main+0x1d0>
  if ( _ctrl_xfer.request.bmRequestType_bit.direction == TUSB_DIR_OUT )
    27e6:	f994 3000 	ldrsb.w	r3, [r4]
    27ea:	2b00      	cmp	r3, #0
    27ec:	db07      	blt.n	27fe <main+0x962>
    TU_VERIFY(_ctrl_xfer.buffer);
    27ee:	68a0      	ldr	r0, [r4, #8]
    27f0:	2800      	cmp	r0, #0
    27f2:	f43f ac3b 	beq.w	206c <main+0x1d0>
    memcpy(_ctrl_xfer.buffer, _usbd_ctrl_buf, xferred_bytes);
    27f6:	491c      	ldr	r1, [pc, #112]	; (2868 <main+0x9cc>)
    27f8:	462a      	mov	r2, r5
    27fa:	f000 f91b 	bl	2a34 <memcpy>
  _ctrl_xfer.buffer += xferred_bytes;
    27fe:	68a2      	ldr	r2, [r4, #8]
  _ctrl_xfer.total_xferred += (uint16_t) xferred_bytes;
    2800:	89e3      	ldrh	r3, [r4, #14]
  _ctrl_xfer.buffer += xferred_bytes;
    2802:	442a      	add	r2, r5
  _ctrl_xfer.total_xferred += (uint16_t) xferred_bytes;
    2804:	442b      	add	r3, r5
  _ctrl_xfer.buffer += xferred_bytes;
    2806:	60a2      	str	r2, [r4, #8]
  if ( (_ctrl_xfer.request.wLength == _ctrl_xfer.total_xferred) || (xferred_bytes < CFG_TUD_ENDPOINT0_SIZE) )
    2808:	88e2      	ldrh	r2, [r4, #6]
  _ctrl_xfer.total_xferred += (uint16_t) xferred_bytes;
    280a:	b29b      	uxth	r3, r3
  if ( (_ctrl_xfer.request.wLength == _ctrl_xfer.total_xferred) || (xferred_bytes < CFG_TUD_ENDPOINT0_SIZE) )
    280c:	429a      	cmp	r2, r3
  _ctrl_xfer.total_xferred += (uint16_t) xferred_bytes;
    280e:	81e3      	strh	r3, [r4, #14]
  if ( (_ctrl_xfer.request.wLength == _ctrl_xfer.total_xferred) || (xferred_bytes < CFG_TUD_ENDPOINT0_SIZE) )
    2810:	d001      	beq.n	2816 <main+0x97a>
    2812:	2d3f      	cmp	r5, #63	; 0x3f
    2814:	d82a      	bhi.n	286c <main+0x9d0>
    if ( _ctrl_xfer.complete_cb )
    2816:	6923      	ldr	r3, [r4, #16]
    2818:	b933      	cbnz	r3, 2828 <main+0x98c>
      TU_ASSERT( _status_stage_xact(rhport, &_ctrl_xfer.request) );
    281a:	7820      	ldrb	r0, [r4, #0]
    281c:	f7fe fa65 	bl	cea <_status_stage_xact.isra.0>
    }
  }
  else
  {
    // More data to transfer
    TU_ASSERT( _data_stage_xact(rhport) );
    2820:	2800      	cmp	r0, #0
    2822:	f47f ac23 	bne.w	206c <main+0x1d0>
    2826:	e7c6      	b.n	27b6 <main+0x91a>
      is_ok = _ctrl_xfer.complete_cb(rhport, CONTROL_STAGE_DATA, &_ctrl_xfer.request);
    2828:	4a0d      	ldr	r2, [pc, #52]	; (2860 <main+0x9c4>)
    282a:	2102      	movs	r1, #2
    282c:	4638      	mov	r0, r7
    282e:	4798      	blx	r3
    if ( is_ok )
    2830:	2800      	cmp	r0, #0
    2832:	d1f2      	bne.n	281a <main+0x97e>
    2834:	e512      	b.n	225c <main+0x3c0>
    2836:	bf00      	nop
    2838:	00002b68 	.word	0x00002b68
    283c:	00000000 	.word	0x00000000
    2840:	00002b7a 	.word	0x00002b7a
    2844:	00000000 	.word	0x00000000
    2848:	200021e8 	.word	0x200021e8
    284c:	00002bf4 	.word	0x00002bf4
    2850:	00000000 	.word	0x00000000
    2854:	40050100 	.word	0x40050100
    2858:	e000e100 	.word	0xe000e100
    285c:	200024a8 	.word	0x200024a8
    2860:	2000214c 	.word	0x2000214c
    2864:	00000000 	.word	0x00000000
    2868:	20002468 	.word	0x20002468
    TU_ASSERT( _data_stage_xact(rhport) );
    286c:	f7fe fa5a 	bl	d24 <_data_stage_xact.isra.0>
    2870:	e7d6      	b.n	2820 <main+0x984>
          usbd_class_driver_t const * driver = get_driver( _usbd_dev.ep2drv[epnum][ep_dir] );
    2872:	7cd8      	ldrb	r0, [r3, #19]
    2874:	f7fd fdcc 	bl	410 <get_driver>
          TU_ASSERT(driver, );
    2878:	2800      	cmp	r0, #0
    287a:	d13f      	bne.n	28fc <main+0xa60>
    287c:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    2880:	f8d3 3df0 	ldr.w	r3, [r3, #3568]	; 0xdf0
    2884:	07d8      	lsls	r0, r3, #31
    2886:	d500      	bpl.n	288a <main+0x9ee>
    2888:	be00      	bkpt	0x0000

uint32_t board_millis (void)
{
  return system_ticks;
    288a:	4b2f      	ldr	r3, [pc, #188]	; (2948 <main+0xaac>)
{
  static uint32_t start_ms = 0;
  static bool led_state = false;

  // Blink every interval ms
  if ( board_millis() - start_ms < blink_interval_ms) return; // not enough time
    288c:	492f      	ldr	r1, [pc, #188]	; (294c <main+0xab0>)
    288e:	4830      	ldr	r0, [pc, #192]	; (2950 <main+0xab4>)
    2890:	681a      	ldr	r2, [r3, #0]
    2892:	680b      	ldr	r3, [r1, #0]
    2894:	6800      	ldr	r0, [r0, #0]
    2896:	1ad2      	subs	r2, r2, r3
    2898:	4282      	cmp	r2, r0
    289a:	d30f      	bcc.n	28bc <main+0xa20>
  start_ms += blink_interval_ms;
    289c:	4403      	add	r3, r0

  board_led_write(led_state);
    289e:	482d      	ldr	r0, [pc, #180]	; (2954 <main+0xab8>)
  start_ms += blink_interval_ms;
    28a0:	600b      	str	r3, [r1, #0]
  board_led_write(led_state);
    28a2:	4a2d      	ldr	r2, [pc, #180]	; (2958 <main+0xabc>)
    28a4:	7803      	ldrb	r3, [r0, #0]
    port->DATA |= PinMsk;
    28a6:	f8d2 13fc 	ldr.w	r1, [r2, #1020]	; 0x3fc
  if ( state )
    28aa:	2b00      	cmp	r3, #0
    28ac:	d049      	beq.n	2942 <main+0xaa6>
    port->DATA |= PinMsk;
    28ae:	f041 0104 	orr.w	r1, r1, #4
  led_state = 1 - led_state; // toggle
    28b2:	f083 0301 	eor.w	r3, r3, #1
    port->DATA &= ~(PinMsk);
    28b6:	f8c2 13fc 	str.w	r1, [r2, #1020]	; 0x3fc
    28ba:	7003      	strb	r3, [r0, #0]
  return tu_fifo_count(&_cdcd_itf[itf].rx_ff);
    28bc:	4827      	ldr	r0, [pc, #156]	; (295c <main+0xac0>)
    28be:	f7fd fd0a 	bl	2d6 <tu_fifo_count>
    if ( tud_cdc_available() )
    28c2:	2800      	cmp	r0, #0
    28c4:	f43f abcd 	beq.w	2062 <main+0x1c6>
  return _tu_fifo_read_n(f, buffer, n, TU_FIFO_COPY_INC);
    28c8:	4824      	ldr	r0, [pc, #144]	; (295c <main+0xac0>)
    28ca:	2240      	movs	r2, #64	; 0x40
    28cc:	a904      	add	r1, sp, #16
    28ce:	f7ff f97d 	bl	1bcc <_tu_fifo_read_n.constprop.0>
    28d2:	4604      	mov	r4, r0
  _prep_out_transaction(p_cdc);
    28d4:	4822      	ldr	r0, [pc, #136]	; (2960 <main+0xac4>)
    28d6:	f7fe f9e9 	bl	cac <_prep_out_transaction.isra.0>
  if ( n == 0 ) return 0;
    28da:	b124      	cbz	r4, 28e6 <main+0xa4a>
    28dc:	4821      	ldr	r0, [pc, #132]	; (2964 <main+0xac8>)
    28de:	4622      	mov	r2, r4
    28e0:	a904      	add	r1, sp, #16
    28e2:	f7ff f9f7 	bl	1cd4 <_tu_fifo_write_n.part.0.constprop.0.isra.0>
  if ( (tu_fifo_count(&p_cdc->tx_ff) >= BULK_PACKET_SIZE) || ((CFG_TUD_CDC_TX_BUFSIZE < BULK_PACKET_SIZE) && tu_fifo_full(&p_cdc->tx_ff)) )
    28e6:	481f      	ldr	r0, [pc, #124]	; (2964 <main+0xac8>)
    28e8:	f7fd fcf5 	bl	2d6 <tu_fifo_count>
    28ec:	283f      	cmp	r0, #63	; 0x3f
    28ee:	d901      	bls.n	28f4 <main+0xa58>
    tud_cdc_n_write_flush(itf);
    28f0:	f7ff f9ba 	bl	1c68 <tud_cdc_n_write_flush.constprop.0>
  return tud_cdc_n_write_str(0, str);
}

static inline uint32_t tud_cdc_write_flush (void)
{
  return tud_cdc_n_write_flush(0);
    28f4:	f7ff f9b8 	bl	1c68 <tud_cdc_n_write_flush.constprop.0>
    28f8:	f7ff bbb3 	b.w	2062 <main+0x1c6>
          driver->xfer_cb(event.rhport, ep_addr, (xfer_result_t)event.xfer_complete.result, event.xfer_complete.len);
    28fc:	6904      	ldr	r4, [r0, #16]
    28fe:	9b06      	ldr	r3, [sp, #24]
    2900:	f89d 2015 	ldrb.w	r2, [sp, #21]
    2904:	f89d 0010 	ldrb.w	r0, [sp, #16]
    2908:	47a0      	blx	r4
    290a:	f7ff bbaf 	b.w	206c <main+0x1d0>
        if ( _usbd_dev.connected )
    290e:	4b16      	ldr	r3, [pc, #88]	; (2968 <main+0xacc>)
    2910:	781b      	ldrb	r3, [r3, #0]
    2912:	07d9      	lsls	r1, r3, #31
    2914:	f57f abaa 	bpl.w	206c <main+0x1d0>
  blink_interval_ms = BLINK_SUSPENDED;
    2918:	4b0d      	ldr	r3, [pc, #52]	; (2950 <main+0xab4>)
    291a:	f640 12c4 	movw	r2, #2500	; 0x9c4
    291e:	e467      	b.n	21f0 <main+0x354>
        if ( _usbd_dev.connected )
    2920:	4b11      	ldr	r3, [pc, #68]	; (2968 <main+0xacc>)
    2922:	781b      	ldrb	r3, [r3, #0]
    2924:	07da      	lsls	r2, r3, #31
    2926:	f57f aba1 	bpl.w	206c <main+0x1d0>
  blink_interval_ms = BLINK_MOUNTED;
    292a:	4b09      	ldr	r3, [pc, #36]	; (2950 <main+0xab4>)
    292c:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    2930:	e45e      	b.n	21f0 <main+0x354>
        if ( event.func_call.func ) event.func_call.func(event.func_call.param);
    2932:	9b05      	ldr	r3, [sp, #20]
    2934:	2b00      	cmp	r3, #0
    2936:	f43f ab99 	beq.w	206c <main+0x1d0>
    293a:	9806      	ldr	r0, [sp, #24]
    293c:	4798      	blx	r3
    293e:	f7ff bb95 	b.w	206c <main+0x1d0>
    2942:	f021 0104 	bic.w	r1, r1, #4
    2946:	e7b4      	b.n	28b2 <main+0xa16>
    2948:	200025a8 	.word	0x200025a8
    294c:	200025a4 	.word	0x200025a4
    2950:	20000018 	.word	0x20000018
    2954:	200025a1 	.word	0x200025a1
    2958:	40025000 	.word	0x40025000
    295c:	20002034 	.word	0x20002034
    2960:	20002024 	.word	0x20002024
    2964:	20002040 	.word	0x20002040
    2968:	200024a8 	.word	0x200024a8

0000296c <Reset_Handler>:
   uint8_t *psrc =(uint8_t*)&__la_data ; 
   
   /* Copy data segment to RAM */ 
   for (uint32_t i = 0; i < copySize; i++)
   {
       *pDest++ = *psrc++ ; 
    296c:	4820      	ldr	r0, [pc, #128]	; (29f0 <zero_loop+0x6e>)
    296e:	4a21      	ldr	r2, [pc, #132]	; (29f4 <zero_loop+0x72>)
    2970:	4921      	ldr	r1, [pc, #132]	; (29f8 <zero_loop+0x76>)
{
    2972:	b508      	push	{r3, lr}
       *pDest++ = *psrc++ ; 
    2974:	1a12      	subs	r2, r2, r0
    2976:	f000 f85d 	bl	2a34 <memcpy>
   }

    /* Zero fill .bss section */ 
       __asm(" ldr     r0, =__start_bss\n"
    297a:	4828      	ldr	r0, [pc, #160]	; (2a1c <zero_loop+0x9a>)
    297c:	4928      	ldr	r1, [pc, #160]	; (2a20 <zero_loop+0x9e>)
    297e:	f04f 0200 	mov.w	r2, #0

00002982 <zero_loop>:
    2982:	4288      	cmp	r0, r1
    2984:	bfb8      	it	lt
    2986:	f840 2b04 	strlt.w	r2, [r0], #4
    298a:	dbfa      	blt.n	2982 <zero_loop>

    // Enable the floating-point unit.  This must be done here to handle the
    // case where main() uses floating-point and the function prologue saves
    // floating-point registers (which will fault if floating-point is not
    // enabled).
    SCB->CPACR &= ~ (CPAC_CP10_M | CPAC_CP11_M);
    298c:	4b1b      	ldr	r3, [pc, #108]	; (29fc <zero_loop+0x7a>)
    298e:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
    2992:	f422 0270 	bic.w	r2, r2, #15728640	; 0xf00000
    2996:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
    SCB->CPACR |= (CPAC_CP10_FULL | CPAC_CP11_FULL);
    299a:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
    299e:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
    29a2:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
    uint32_t i;
#endif

  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2) |                 /* set CP10 Full Access */
    29a6:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
    29aa:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
    29ae:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
                   (3UL << 11*2)  );               /* set CP11 Full Access */
  #endif

#if(CLOCK_SETUP)
    SYSCTL->RCC2 = 0x07802810;    /* set default value */
    29b2:	4b13      	ldr	r3, [pc, #76]	; (2a00 <zero_loop+0x7e>)
    29b4:	4a13      	ldr	r2, [pc, #76]	; (2a04 <zero_loop+0x82>)
    29b6:	671a      	str	r2, [r3, #112]	; 0x70
    SYSCTL->RCC  = 0x078E3AD1;    /* set default value */
    29b8:	f502 2261 	add.w	r2, r2, #921600	; 0xe1000
    29bc:	f202 22c1 	addw	r2, r2, #705	; 0x2c1
    29c0:	661a      	str	r2, [r3, #96]	; 0x60

    SYSCTL->RCC  = (RCC_Val  | (1UL<<11) | (1UL<<13)) & ~(1UL<<22); /* set value with BYPASS, PWRDN set, USESYSDIV reset */
    29c2:	f1a2 62be 	sub.w	r2, r2, #99614720	; 0x5f00000
    29c6:	f6a2 528f 	subw	r2, r2, #3471	; 0xd8f
    29ca:	661a      	str	r2, [r3, #96]	; 0x60
    SYSCTL->RCC2 = (RCC2_Val | (1UL<<11) | (1UL<<13));              /* set value with BYPASS, PWRDN set */
    29cc:	4a0e      	ldr	r2, [pc, #56]	; (2a08 <zero_loop+0x86>)
    29ce:	671a      	str	r2, [r3, #112]	; 0x70
    for (i = 0; i < 1000; i++);   /* wait a while */

    SYSCTL->RCC  = (RCC_Val  | (1UL<<11)) & ~(1UL<<22);             /* set value with BYPASS, USESYSDIV reset */
    29d0:	4a0e      	ldr	r2, [pc, #56]	; (2a0c <zero_loop+0x8a>)
    29d2:	661a      	str	r2, [r3, #96]	; 0x60
    SYSCTL->RCC2 = (RCC2_Val | (1UL<<11));                          /* set value with BYPASS */
    29d4:	4a0e      	ldr	r2, [pc, #56]	; (2a10 <zero_loop+0x8e>)
    29d6:	671a      	str	r2, [r3, #112]	; 0x70
    for (i = 0; i < 1000; i++);   /* wait a while */

    SYSCTL->RCC  = (RCC_Val  | (1<<11));                            /* set value with BYPASS */
    29d8:	4a0e      	ldr	r2, [pc, #56]	; (2a14 <zero_loop+0x92>)
    29da:	661a      	str	r2, [r3, #96]	; 0x60

    if ( (((RCC_Val  & (1UL<<13)) == 0) && ((RCC2_Val & (1UL<<31)) == 0)) ||
         (((RCC2_Val & (1UL<<13)) == 0) && ((RCC2_Val & (1UL<<31)) != 0))   ) {
      while ((SYSCTL->RIS & (1UL<<6)) != (1UL<<6));                 /* wait until PLL is locked */
    29dc:	6d1a      	ldr	r2, [r3, #80]	; 0x50
    29de:	0652      	lsls	r2, r2, #25
    29e0:	d5fc      	bpl.n	29dc <zero_loop+0x5a>
    }

    SYSCTL->RCC  = (RCC_Val);                                       /* set value */
    29e2:	4a0d      	ldr	r2, [pc, #52]	; (2a18 <zero_loop+0x96>)
    29e4:	661a      	str	r2, [r3, #96]	; 0x60
    SYSCTL->RCC2 = (RCC2_Val);                                      /* set value */
    29e6:	f04f 72c0 	mov.w	r2, #25165824	; 0x1800000
    29ea:	671a      	str	r2, [r3, #112]	; 0x70

   //__libc_init_array();
   SystemInit();
   main() ; 
    29ec:	f7ff fa56 	bl	1e9c <main>
    29f0:	20000000 	.word	0x20000000
    29f4:	2000201c 	.word	0x2000201c
    29f8:	00002c0c 	.word	0x00002c0c
    29fc:	e000ed00 	.word	0xe000ed00
    2a00:	400fe000 	.word	0x400fe000
    2a04:	07802810 	.word	0x07802810
    2a08:	01802800 	.word	0x01802800
    2a0c:	019e0d42 	.word	0x019e0d42
    2a10:	01800800 	.word	0x01800800
    2a14:	01de0d42 	.word	0x01de0d42
    2a18:	01de0542 	.word	0x01de0542
    2a1c:	2000201c 	.word	0x2000201c
    2a20:	200025ac 	.word	0x200025ac

00002a24 <memset>:
    2a24:	4402      	add	r2, r0
    2a26:	4603      	mov	r3, r0
    2a28:	4293      	cmp	r3, r2
    2a2a:	d100      	bne.n	2a2e <memset+0xa>
    2a2c:	4770      	bx	lr
    2a2e:	f803 1b01 	strb.w	r1, [r3], #1
    2a32:	e7f9      	b.n	2a28 <memset+0x4>

00002a34 <memcpy>:
    2a34:	440a      	add	r2, r1
    2a36:	4291      	cmp	r1, r2
    2a38:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
    2a3c:	d100      	bne.n	2a40 <memcpy+0xc>
    2a3e:	4770      	bx	lr
    2a40:	b510      	push	{r4, lr}
    2a42:	f811 4b01 	ldrb.w	r4, [r1], #1
    2a46:	f803 4f01 	strb.w	r4, [r3, #1]!
    2a4a:	4291      	cmp	r1, r2
    2a4c:	d1f9      	bne.n	2a42 <memcpy+0xe>
    2a4e:	bd10      	pop	{r4, pc}

00002a50 <memmove>:
    2a50:	4288      	cmp	r0, r1
    2a52:	b510      	push	{r4, lr}
    2a54:	eb01 0402 	add.w	r4, r1, r2
    2a58:	d902      	bls.n	2a60 <memmove+0x10>
    2a5a:	4284      	cmp	r4, r0
    2a5c:	4623      	mov	r3, r4
    2a5e:	d807      	bhi.n	2a70 <memmove+0x20>
    2a60:	1e43      	subs	r3, r0, #1
    2a62:	42a1      	cmp	r1, r4
    2a64:	d008      	beq.n	2a78 <memmove+0x28>
    2a66:	f811 2b01 	ldrb.w	r2, [r1], #1
    2a6a:	f803 2f01 	strb.w	r2, [r3, #1]!
    2a6e:	e7f8      	b.n	2a62 <memmove+0x12>
    2a70:	4402      	add	r2, r0
    2a72:	4601      	mov	r1, r0
    2a74:	428a      	cmp	r2, r1
    2a76:	d100      	bne.n	2a7a <memmove+0x2a>
    2a78:	bd10      	pop	{r4, pc}
    2a7a:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
    2a7e:	f802 4d01 	strb.w	r4, [r2, #-1]!
    2a82:	e7f7      	b.n	2a74 <memmove+0x24>

00002a84 <_init>:
    2a84:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    2a86:	bf00      	nop

00002a88 <_fini>:
    2a88:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    2a8a:	bf00      	nop
    2a8c:	796e6954 	.word	0x796e6954
    2a90:	00425355 	.word	0x00425355
    2a94:	7373614d 	.word	0x7373614d
    2a98:	6f745320 	.word	0x6f745320
    2a9c:	65676172 	.word	0x65676172
    2aa0:	00          	.byte	0x00
    2aa1:	54          	.byte	0x54
    2aa2:	6e69      	.short	0x6e69
    2aa4:	42535579 	.word	0x42535579
    2aa8:	76654420 	.word	0x76654420
    2aac:	00656369 	.word	0x00656369
    2ab0:	34333231 	.word	0x34333231
    2ab4:	38373635 	.word	0x38373635
    2ab8:	32313039 	.word	0x32313039
    2abc:	6e695400 	.word	0x6e695400
    2ac0:	42535579 	.word	0x42535579
    2ac4:	43444320 	.word	0x43444320
    2ac8:	6e695400 	.word	0x6e695400
    2acc:	42535579 	.word	0x42535579
    2ad0:	43534d20 	.word	0x43534d20
    2ad4:	00000000 	.word	0x00000000

00002ad8 <CSWTCH.6>:
    2ad8:	000f4240 001c2000 001e8480 00258000     @B... ........%.
    2ae8:	00369e99 00384000 003d0900 003e8000     ..6..@8...=...>.
    2af8:	004b0000 004c4b40 004e2000 005b8d80     ..K.@KL.. N...[.
    2b08:	005dc000 00708000 007a1200 007d0000     ..]...p...z...}.
    2b18:	00989680 00b71b00 00bb8000 00cee8c0     ................
    2b28:	00da7a64 00f42400 00fa0000              dz...$......

00002b34 <__compound_literal.0>:
    2b34:	00000409                                ....

00002b38 <_usbd_driver>:
    2b38:	00000ffd 0000104d 00001ab5 00000ddd     ....M...........
    2b48:	00001dbd 00000000 00001071 00001081     ........q.......
    2b58:	00001b49 00000e85 000013dd 00000000     I...............

00002b68 <desc_device>:
    2b68:	02000112 400102ef 4003cafe 02010100     .......@...@....
    2b78:	                                         ..

00002b7a <desc_fs_configuration>:
    2b7a:	00620209 80000103 000b0832 00020202     ..b.....2.......
    2b8a:	00040900 02020100 24050400 05012000     ...........$. ..
    2b9a:	01000124 02022404 00062405 81050701     $....$...$......
    2baa:	10000803 00010409 00000a02 02050700     ................
    2bba:	00004002 02820507 09000040 02000204     .@......@.......
    2bca:	05500608 02030507 07000040 40028305     ..P.....@......@
	...

00002bdc <ops.0>:
    2bdc:	000003af 0000031b 0000052b 00000343     ........+...C...
    2bec:	0000032f 000004f1                       /.......

00002bf4 <string_desc_arr>:
    2bf4:	00002b34 00002a8c 00002aa1 00002ab0     4+...*...*...*..
    2c04:	00002abd 00002ac9                       .*...*..
